/* srmv2C.c
   Generated by gSOAP 2.7.6b from srm.v2.2.h
   Copyright (C) 2000-2005, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#include "srmv2H.h"
#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) srmv2C.c ver 2.7.6b 2010-04-29 07:52:06 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL);
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_unsignedLONG64:
		return soap_in_unsignedLONG64(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_srm2__TStatusCode:
		return soap_in_srm2__TStatusCode(soap, NULL, NULL, "srm2:TStatusCode");
	case SOAP_TYPE_srm2__TConnectionType:
		return soap_in_srm2__TConnectionType(soap, NULL, NULL, "srm2:TConnectionType");
	case SOAP_TYPE_srm2__TAccessPattern:
		return soap_in_srm2__TAccessPattern(soap, NULL, NULL, "srm2:TAccessPattern");
	case SOAP_TYPE_srm2__TFileLocality:
		return soap_in_srm2__TFileLocality(soap, NULL, NULL, "srm2:TFileLocality");
	case SOAP_TYPE_srm2__TOverwriteMode:
		return soap_in_srm2__TOverwriteMode(soap, NULL, NULL, "srm2:TOverwriteMode");
	case SOAP_TYPE_srm2__TRequestType:
		return soap_in_srm2__TRequestType(soap, NULL, NULL, "srm2:TRequestType");
	case SOAP_TYPE_srm2__TPermissionType:
		return soap_in_srm2__TPermissionType(soap, NULL, NULL, "srm2:TPermissionType");
	case SOAP_TYPE_srm2__TPermissionMode:
		return soap_in_srm2__TPermissionMode(soap, NULL, NULL, "srm2:TPermissionMode");
	case SOAP_TYPE_srm2__TAccessLatency:
		return soap_in_srm2__TAccessLatency(soap, NULL, NULL, "srm2:TAccessLatency");
	case SOAP_TYPE_srm2__TRetentionPolicy:
		return soap_in_srm2__TRetentionPolicy(soap, NULL, NULL, "srm2:TRetentionPolicy");
	case SOAP_TYPE_srm2__TFileType:
		return soap_in_srm2__TFileType(soap, NULL, NULL, "srm2:TFileType");
	case SOAP_TYPE_srm2__TFileStorageType:
		return soap_in_srm2__TFileStorageType(soap, NULL, NULL, "srm2:TFileStorageType");
	case SOAP_TYPE_xsd__boolean:
		return soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_SOAP_ENV__Reason:
		return soap_in_SOAP_ENV__Reason(soap, NULL, NULL, "SOAP-ENV:Reason");
	case SOAP_TYPE_srm2__srmPing:
		return soap_in_srm2__srmPing(soap, NULL, NULL, "srm2:srmPing");
	case SOAP_TYPE_srm2__srmPingResponse_:
		return soap_in_srm2__srmPingResponse_(soap, NULL, NULL, "srm2:srmPingResponse");
	case SOAP_TYPE_srm2__srmGetTransferProtocols:
		return soap_in_srm2__srmGetTransferProtocols(soap, NULL, NULL, "srm2:srmGetTransferProtocols");
	case SOAP_TYPE_srm2__srmGetTransferProtocolsResponse_:
		return soap_in_srm2__srmGetTransferProtocolsResponse_(soap, NULL, NULL, "srm2:srmGetTransferProtocolsResponse");
	case SOAP_TYPE_srm2__srmGetRequestTokens:
		return soap_in_srm2__srmGetRequestTokens(soap, NULL, NULL, "srm2:srmGetRequestTokens");
	case SOAP_TYPE_srm2__srmGetRequestTokensResponse_:
		return soap_in_srm2__srmGetRequestTokensResponse_(soap, NULL, NULL, "srm2:srmGetRequestTokensResponse");
	case SOAP_TYPE_srm2__srmExtendFileLifeTime:
		return soap_in_srm2__srmExtendFileLifeTime(soap, NULL, NULL, "srm2:srmExtendFileLifeTime");
	case SOAP_TYPE_srm2__srmExtendFileLifeTimeResponse_:
		return soap_in_srm2__srmExtendFileLifeTimeResponse_(soap, NULL, NULL, "srm2:srmExtendFileLifeTimeResponse");
	case SOAP_TYPE_srm2__srmGetRequestSummary:
		return soap_in_srm2__srmGetRequestSummary(soap, NULL, NULL, "srm2:srmGetRequestSummary");
	case SOAP_TYPE_srm2__srmGetRequestSummaryResponse_:
		return soap_in_srm2__srmGetRequestSummaryResponse_(soap, NULL, NULL, "srm2:srmGetRequestSummaryResponse");
	case SOAP_TYPE_srm2__srmResumeRequest:
		return soap_in_srm2__srmResumeRequest(soap, NULL, NULL, "srm2:srmResumeRequest");
	case SOAP_TYPE_srm2__srmResumeRequestResponse_:
		return soap_in_srm2__srmResumeRequestResponse_(soap, NULL, NULL, "srm2:srmResumeRequestResponse");
	case SOAP_TYPE_srm2__srmSuspendRequest:
		return soap_in_srm2__srmSuspendRequest(soap, NULL, NULL, "srm2:srmSuspendRequest");
	case SOAP_TYPE_srm2__srmSuspendRequestResponse_:
		return soap_in_srm2__srmSuspendRequestResponse_(soap, NULL, NULL, "srm2:srmSuspendRequestResponse");
	case SOAP_TYPE_srm2__srmAbortFiles:
		return soap_in_srm2__srmAbortFiles(soap, NULL, NULL, "srm2:srmAbortFiles");
	case SOAP_TYPE_srm2__srmAbortFilesResponse_:
		return soap_in_srm2__srmAbortFilesResponse_(soap, NULL, NULL, "srm2:srmAbortFilesResponse");
	case SOAP_TYPE_srm2__srmAbortRequest:
		return soap_in_srm2__srmAbortRequest(soap, NULL, NULL, "srm2:srmAbortRequest");
	case SOAP_TYPE_srm2__srmAbortRequestResponse_:
		return soap_in_srm2__srmAbortRequestResponse_(soap, NULL, NULL, "srm2:srmAbortRequestResponse");
	case SOAP_TYPE_srm2__srmPutDone:
		return soap_in_srm2__srmPutDone(soap, NULL, NULL, "srm2:srmPutDone");
	case SOAP_TYPE_srm2__srmPutDoneResponse_:
		return soap_in_srm2__srmPutDoneResponse_(soap, NULL, NULL, "srm2:srmPutDoneResponse");
	case SOAP_TYPE_srm2__srmReleaseFiles:
		return soap_in_srm2__srmReleaseFiles(soap, NULL, NULL, "srm2:srmReleaseFiles");
	case SOAP_TYPE_srm2__srmReleaseFilesResponse_:
		return soap_in_srm2__srmReleaseFilesResponse_(soap, NULL, NULL, "srm2:srmReleaseFilesResponse");
	case SOAP_TYPE_srm2__srmStatusOfCopyRequest:
		return soap_in_srm2__srmStatusOfCopyRequest(soap, NULL, NULL, "srm2:srmStatusOfCopyRequest");
	case SOAP_TYPE_srm2__srmStatusOfCopyRequestResponse_:
		return soap_in_srm2__srmStatusOfCopyRequestResponse_(soap, NULL, NULL, "srm2:srmStatusOfCopyRequestResponse");
	case SOAP_TYPE_srm2__srmCopy:
		return soap_in_srm2__srmCopy(soap, NULL, NULL, "srm2:srmCopy");
	case SOAP_TYPE_srm2__srmCopyResponse_:
		return soap_in_srm2__srmCopyResponse_(soap, NULL, NULL, "srm2:srmCopyResponse");
	case SOAP_TYPE_srm2__srmStatusOfPutRequest:
		return soap_in_srm2__srmStatusOfPutRequest(soap, NULL, NULL, "srm2:srmStatusOfPutRequest");
	case SOAP_TYPE_srm2__srmStatusOfPutRequestResponse_:
		return soap_in_srm2__srmStatusOfPutRequestResponse_(soap, NULL, NULL, "srm2:srmStatusOfPutRequestResponse");
	case SOAP_TYPE_srm2__srmPrepareToPut:
		return soap_in_srm2__srmPrepareToPut(soap, NULL, NULL, "srm2:srmPrepareToPut");
	case SOAP_TYPE_srm2__srmPrepareToPutResponse_:
		return soap_in_srm2__srmPrepareToPutResponse_(soap, NULL, NULL, "srm2:srmPrepareToPutResponse");
	case SOAP_TYPE_srm2__srmStatusOfBringOnlineRequest:
		return soap_in_srm2__srmStatusOfBringOnlineRequest(soap, NULL, NULL, "srm2:srmStatusOfBringOnlineRequest");
	case SOAP_TYPE_srm2__srmStatusOfBringOnlineRequestResponse_:
		return soap_in_srm2__srmStatusOfBringOnlineRequestResponse_(soap, NULL, NULL, "srm2:srmStatusOfBringOnlineRequestResponse");
	case SOAP_TYPE_srm2__srmBringOnline:
		return soap_in_srm2__srmBringOnline(soap, NULL, NULL, "srm2:srmBringOnline");
	case SOAP_TYPE_srm2__srmBringOnlineResponse_:
		return soap_in_srm2__srmBringOnlineResponse_(soap, NULL, NULL, "srm2:srmBringOnlineResponse");
	case SOAP_TYPE_srm2__srmStatusOfGetRequest:
		return soap_in_srm2__srmStatusOfGetRequest(soap, NULL, NULL, "srm2:srmStatusOfGetRequest");
	case SOAP_TYPE_srm2__srmStatusOfGetRequestResponse_:
		return soap_in_srm2__srmStatusOfGetRequestResponse_(soap, NULL, NULL, "srm2:srmStatusOfGetRequestResponse");
	case SOAP_TYPE_srm2__srmPrepareToGet:
		return soap_in_srm2__srmPrepareToGet(soap, NULL, NULL, "srm2:srmPrepareToGet");
	case SOAP_TYPE_srm2__srmPrepareToGetResponse_:
		return soap_in_srm2__srmPrepareToGetResponse_(soap, NULL, NULL, "srm2:srmPrepareToGetResponse");
	case SOAP_TYPE_srm2__srmMv:
		return soap_in_srm2__srmMv(soap, NULL, NULL, "srm2:srmMv");
	case SOAP_TYPE_srm2__srmMvResponse_:
		return soap_in_srm2__srmMvResponse_(soap, NULL, NULL, "srm2:srmMvResponse");
	case SOAP_TYPE_srm2__srmStatusOfLsRequest:
		return soap_in_srm2__srmStatusOfLsRequest(soap, NULL, NULL, "srm2:srmStatusOfLsRequest");
	case SOAP_TYPE_srm2__srmStatusOfLsRequestResponse_:
		return soap_in_srm2__srmStatusOfLsRequestResponse_(soap, NULL, NULL, "srm2:srmStatusOfLsRequestResponse");
	case SOAP_TYPE_srm2__srmLs:
		return soap_in_srm2__srmLs(soap, NULL, NULL, "srm2:srmLs");
	case SOAP_TYPE_srm2__srmLsResponse_:
		return soap_in_srm2__srmLsResponse_(soap, NULL, NULL, "srm2:srmLsResponse");
	case SOAP_TYPE_srm2__srmRm:
		return soap_in_srm2__srmRm(soap, NULL, NULL, "srm2:srmRm");
	case SOAP_TYPE_srm2__srmRmResponse_:
		return soap_in_srm2__srmRmResponse_(soap, NULL, NULL, "srm2:srmRmResponse");
	case SOAP_TYPE_srm2__srmRmdir:
		return soap_in_srm2__srmRmdir(soap, NULL, NULL, "srm2:srmRmdir");
	case SOAP_TYPE_srm2__srmRmdirResponse_:
		return soap_in_srm2__srmRmdirResponse_(soap, NULL, NULL, "srm2:srmRmdirResponse");
	case SOAP_TYPE_srm2__srmMkdir:
		return soap_in_srm2__srmMkdir(soap, NULL, NULL, "srm2:srmMkdir");
	case SOAP_TYPE_srm2__srmMkdirResponse_:
		return soap_in_srm2__srmMkdirResponse_(soap, NULL, NULL, "srm2:srmMkdirResponse");
	case SOAP_TYPE_srm2__srmGetPermission:
		return soap_in_srm2__srmGetPermission(soap, NULL, NULL, "srm2:srmGetPermission");
	case SOAP_TYPE_srm2__srmGetPermissionResponse_:
		return soap_in_srm2__srmGetPermissionResponse_(soap, NULL, NULL, "srm2:srmGetPermissionResponse");
	case SOAP_TYPE_srm2__srmCheckPermission:
		return soap_in_srm2__srmCheckPermission(soap, NULL, NULL, "srm2:srmCheckPermission");
	case SOAP_TYPE_srm2__srmCheckPermissionResponse_:
		return soap_in_srm2__srmCheckPermissionResponse_(soap, NULL, NULL, "srm2:srmCheckPermissionResponse");
	case SOAP_TYPE_srm2__srmSetPermission:
		return soap_in_srm2__srmSetPermission(soap, NULL, NULL, "srm2:srmSetPermission");
	case SOAP_TYPE_srm2__srmSetPermissionResponse_:
		return soap_in_srm2__srmSetPermissionResponse_(soap, NULL, NULL, "srm2:srmSetPermissionResponse");
	case SOAP_TYPE_srm2__srmGetSpaceTokens:
		return soap_in_srm2__srmGetSpaceTokens(soap, NULL, NULL, "srm2:srmGetSpaceTokens");
	case SOAP_TYPE_srm2__srmGetSpaceTokensResponse_:
		return soap_in_srm2__srmGetSpaceTokensResponse_(soap, NULL, NULL, "srm2:srmGetSpaceTokensResponse");
	case SOAP_TYPE_srm2__srmPurgeFromSpace:
		return soap_in_srm2__srmPurgeFromSpace(soap, NULL, NULL, "srm2:srmPurgeFromSpace");
	case SOAP_TYPE_srm2__srmPurgeFromSpaceResponse_:
		return soap_in_srm2__srmPurgeFromSpaceResponse_(soap, NULL, NULL, "srm2:srmPurgeFromSpaceResponse");
	case SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpace:
		return soap_in_srm2__srmExtendFileLifeTimeInSpace(soap, NULL, NULL, "srm2:srmExtendFileLifeTimeInSpace");
	case SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpaceResponse_:
		return soap_in_srm2__srmExtendFileLifeTimeInSpaceResponse_(soap, NULL, NULL, "srm2:srmExtendFileLifeTimeInSpaceResponse");
	case SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequest:
		return soap_in_srm2__srmStatusOfChangeSpaceForFilesRequest(soap, NULL, NULL, "srm2:srmStatusOfChangeSpaceForFilesRequest");
	case SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequestResponse_:
		return soap_in_srm2__srmStatusOfChangeSpaceForFilesRequestResponse_(soap, NULL, NULL, "srm2:srmStatusOfChangeSpaceForFilesRequestResponse");
	case SOAP_TYPE_srm2__srmChangeSpaceForFiles:
		return soap_in_srm2__srmChangeSpaceForFiles(soap, NULL, NULL, "srm2:srmChangeSpaceForFiles");
	case SOAP_TYPE_srm2__srmChangeSpaceForFilesResponse_:
		return soap_in_srm2__srmChangeSpaceForFilesResponse_(soap, NULL, NULL, "srm2:srmChangeSpaceForFilesResponse");
	case SOAP_TYPE_srm2__srmGetSpaceMetaData:
		return soap_in_srm2__srmGetSpaceMetaData(soap, NULL, NULL, "srm2:srmGetSpaceMetaData");
	case SOAP_TYPE_srm2__srmGetSpaceMetaDataResponse_:
		return soap_in_srm2__srmGetSpaceMetaDataResponse_(soap, NULL, NULL, "srm2:srmGetSpaceMetaDataResponse");
	case SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequest:
		return soap_in_srm2__srmStatusOfUpdateSpaceRequest(soap, NULL, NULL, "srm2:srmStatusOfUpdateSpaceRequest");
	case SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequestResponse_:
		return soap_in_srm2__srmStatusOfUpdateSpaceRequestResponse_(soap, NULL, NULL, "srm2:srmStatusOfUpdateSpaceRequestResponse");
	case SOAP_TYPE_srm2__srmUpdateSpace:
		return soap_in_srm2__srmUpdateSpace(soap, NULL, NULL, "srm2:srmUpdateSpace");
	case SOAP_TYPE_srm2__srmUpdateSpaceResponse_:
		return soap_in_srm2__srmUpdateSpaceResponse_(soap, NULL, NULL, "srm2:srmUpdateSpaceResponse");
	case SOAP_TYPE_srm2__srmReleaseSpace:
		return soap_in_srm2__srmReleaseSpace(soap, NULL, NULL, "srm2:srmReleaseSpace");
	case SOAP_TYPE_srm2__srmReleaseSpaceResponse_:
		return soap_in_srm2__srmReleaseSpaceResponse_(soap, NULL, NULL, "srm2:srmReleaseSpaceResponse");
	case SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequest:
		return soap_in_srm2__srmStatusOfReserveSpaceRequest(soap, NULL, NULL, "srm2:srmStatusOfReserveSpaceRequest");
	case SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequestResponse_:
		return soap_in_srm2__srmStatusOfReserveSpaceRequestResponse_(soap, NULL, NULL, "srm2:srmStatusOfReserveSpaceRequestResponse");
	case SOAP_TYPE_srm2__srmReserveSpace:
		return soap_in_srm2__srmReserveSpace(soap, NULL, NULL, "srm2:srmReserveSpace");
	case SOAP_TYPE_srm2__srmReserveSpaceResponse_:
		return soap_in_srm2__srmReserveSpaceResponse_(soap, NULL, NULL, "srm2:srmReserveSpaceResponse");
	case SOAP_TYPE_srm2__srmPingResponse:
		return soap_in_srm2__srmPingResponse(soap, NULL, NULL, "srm2:srmPingResponse");
	case SOAP_TYPE_srm2__srmPingRequest:
		return soap_in_srm2__srmPingRequest(soap, NULL, NULL, "srm2:srmPingRequest");
	case SOAP_TYPE_srm2__srmGetTransferProtocolsResponse:
		return soap_in_srm2__srmGetTransferProtocolsResponse(soap, NULL, NULL, "srm2:srmGetTransferProtocolsResponse");
	case SOAP_TYPE_srm2__srmGetTransferProtocolsRequest:
		return soap_in_srm2__srmGetTransferProtocolsRequest(soap, NULL, NULL, "srm2:srmGetTransferProtocolsRequest");
	case SOAP_TYPE_srm2__srmGetRequestTokensResponse:
		return soap_in_srm2__srmGetRequestTokensResponse(soap, NULL, NULL, "srm2:srmGetRequestTokensResponse");
	case SOAP_TYPE_srm2__srmGetRequestTokensRequest:
		return soap_in_srm2__srmGetRequestTokensRequest(soap, NULL, NULL, "srm2:srmGetRequestTokensRequest");
	case SOAP_TYPE_srm2__srmExtendFileLifeTimeResponse:
		return soap_in_srm2__srmExtendFileLifeTimeResponse(soap, NULL, NULL, "srm2:srmExtendFileLifeTimeResponse");
	case SOAP_TYPE_srm2__srmExtendFileLifeTimeRequest:
		return soap_in_srm2__srmExtendFileLifeTimeRequest(soap, NULL, NULL, "srm2:srmExtendFileLifeTimeRequest");
	case SOAP_TYPE_srm2__srmGetRequestSummaryResponse:
		return soap_in_srm2__srmGetRequestSummaryResponse(soap, NULL, NULL, "srm2:srmGetRequestSummaryResponse");
	case SOAP_TYPE_srm2__srmGetRequestSummaryRequest:
		return soap_in_srm2__srmGetRequestSummaryRequest(soap, NULL, NULL, "srm2:srmGetRequestSummaryRequest");
	case SOAP_TYPE_srm2__srmResumeRequestResponse:
		return soap_in_srm2__srmResumeRequestResponse(soap, NULL, NULL, "srm2:srmResumeRequestResponse");
	case SOAP_TYPE_srm2__srmResumeRequestRequest:
		return soap_in_srm2__srmResumeRequestRequest(soap, NULL, NULL, "srm2:srmResumeRequestRequest");
	case SOAP_TYPE_srm2__srmSuspendRequestResponse:
		return soap_in_srm2__srmSuspendRequestResponse(soap, NULL, NULL, "srm2:srmSuspendRequestResponse");
	case SOAP_TYPE_srm2__srmSuspendRequestRequest:
		return soap_in_srm2__srmSuspendRequestRequest(soap, NULL, NULL, "srm2:srmSuspendRequestRequest");
	case SOAP_TYPE_srm2__srmAbortFilesResponse:
		return soap_in_srm2__srmAbortFilesResponse(soap, NULL, NULL, "srm2:srmAbortFilesResponse");
	case SOAP_TYPE_srm2__srmAbortFilesRequest:
		return soap_in_srm2__srmAbortFilesRequest(soap, NULL, NULL, "srm2:srmAbortFilesRequest");
	case SOAP_TYPE_srm2__srmAbortRequestResponse:
		return soap_in_srm2__srmAbortRequestResponse(soap, NULL, NULL, "srm2:srmAbortRequestResponse");
	case SOAP_TYPE_srm2__srmAbortRequestRequest:
		return soap_in_srm2__srmAbortRequestRequest(soap, NULL, NULL, "srm2:srmAbortRequestRequest");
	case SOAP_TYPE_srm2__srmPutDoneResponse:
		return soap_in_srm2__srmPutDoneResponse(soap, NULL, NULL, "srm2:srmPutDoneResponse");
	case SOAP_TYPE_srm2__srmPutDoneRequest:
		return soap_in_srm2__srmPutDoneRequest(soap, NULL, NULL, "srm2:srmPutDoneRequest");
	case SOAP_TYPE_srm2__srmReleaseFilesResponse:
		return soap_in_srm2__srmReleaseFilesResponse(soap, NULL, NULL, "srm2:srmReleaseFilesResponse");
	case SOAP_TYPE_srm2__srmReleaseFilesRequest:
		return soap_in_srm2__srmReleaseFilesRequest(soap, NULL, NULL, "srm2:srmReleaseFilesRequest");
	case SOAP_TYPE_srm2__srmStatusOfCopyRequestResponse:
		return soap_in_srm2__srmStatusOfCopyRequestResponse(soap, NULL, NULL, "srm2:srmStatusOfCopyRequestResponse");
	case SOAP_TYPE_srm2__srmStatusOfCopyRequestRequest:
		return soap_in_srm2__srmStatusOfCopyRequestRequest(soap, NULL, NULL, "srm2:srmStatusOfCopyRequestRequest");
	case SOAP_TYPE_srm2__srmCopyResponse:
		return soap_in_srm2__srmCopyResponse(soap, NULL, NULL, "srm2:srmCopyResponse");
	case SOAP_TYPE_srm2__srmCopyRequest:
		return soap_in_srm2__srmCopyRequest(soap, NULL, NULL, "srm2:srmCopyRequest");
	case SOAP_TYPE_srm2__srmStatusOfPutRequestResponse:
		return soap_in_srm2__srmStatusOfPutRequestResponse(soap, NULL, NULL, "srm2:srmStatusOfPutRequestResponse");
	case SOAP_TYPE_srm2__srmStatusOfPutRequestRequest:
		return soap_in_srm2__srmStatusOfPutRequestRequest(soap, NULL, NULL, "srm2:srmStatusOfPutRequestRequest");
	case SOAP_TYPE_srm2__srmPrepareToPutResponse:
		return soap_in_srm2__srmPrepareToPutResponse(soap, NULL, NULL, "srm2:srmPrepareToPutResponse");
	case SOAP_TYPE_srm2__srmPrepareToPutRequest:
		return soap_in_srm2__srmPrepareToPutRequest(soap, NULL, NULL, "srm2:srmPrepareToPutRequest");
	case SOAP_TYPE_srm2__srmStatusOfBringOnlineRequestResponse:
		return soap_in_srm2__srmStatusOfBringOnlineRequestResponse(soap, NULL, NULL, "srm2:srmStatusOfBringOnlineRequestResponse");
	case SOAP_TYPE_srm2__srmStatusOfBringOnlineRequestRequest:
		return soap_in_srm2__srmStatusOfBringOnlineRequestRequest(soap, NULL, NULL, "srm2:srmStatusOfBringOnlineRequestRequest");
	case SOAP_TYPE_srm2__srmBringOnlineResponse:
		return soap_in_srm2__srmBringOnlineResponse(soap, NULL, NULL, "srm2:srmBringOnlineResponse");
	case SOAP_TYPE_srm2__srmBringOnlineRequest:
		return soap_in_srm2__srmBringOnlineRequest(soap, NULL, NULL, "srm2:srmBringOnlineRequest");
	case SOAP_TYPE_srm2__srmStatusOfGetRequestResponse:
		return soap_in_srm2__srmStatusOfGetRequestResponse(soap, NULL, NULL, "srm2:srmStatusOfGetRequestResponse");
	case SOAP_TYPE_srm2__srmStatusOfGetRequestRequest:
		return soap_in_srm2__srmStatusOfGetRequestRequest(soap, NULL, NULL, "srm2:srmStatusOfGetRequestRequest");
	case SOAP_TYPE_srm2__srmPrepareToGetResponse:
		return soap_in_srm2__srmPrepareToGetResponse(soap, NULL, NULL, "srm2:srmPrepareToGetResponse");
	case SOAP_TYPE_srm2__srmPrepareToGetRequest:
		return soap_in_srm2__srmPrepareToGetRequest(soap, NULL, NULL, "srm2:srmPrepareToGetRequest");
	case SOAP_TYPE_srm2__srmMvResponse:
		return soap_in_srm2__srmMvResponse(soap, NULL, NULL, "srm2:srmMvResponse");
	case SOAP_TYPE_srm2__srmMvRequest:
		return soap_in_srm2__srmMvRequest(soap, NULL, NULL, "srm2:srmMvRequest");
	case SOAP_TYPE_srm2__srmStatusOfLsRequestResponse:
		return soap_in_srm2__srmStatusOfLsRequestResponse(soap, NULL, NULL, "srm2:srmStatusOfLsRequestResponse");
	case SOAP_TYPE_srm2__srmStatusOfLsRequestRequest:
		return soap_in_srm2__srmStatusOfLsRequestRequest(soap, NULL, NULL, "srm2:srmStatusOfLsRequestRequest");
	case SOAP_TYPE_srm2__srmLsResponse:
		return soap_in_srm2__srmLsResponse(soap, NULL, NULL, "srm2:srmLsResponse");
	case SOAP_TYPE_srm2__srmLsRequest:
		return soap_in_srm2__srmLsRequest(soap, NULL, NULL, "srm2:srmLsRequest");
	case SOAP_TYPE_srm2__srmRmResponse:
		return soap_in_srm2__srmRmResponse(soap, NULL, NULL, "srm2:srmRmResponse");
	case SOAP_TYPE_srm2__srmRmRequest:
		return soap_in_srm2__srmRmRequest(soap, NULL, NULL, "srm2:srmRmRequest");
	case SOAP_TYPE_srm2__srmRmdirResponse:
		return soap_in_srm2__srmRmdirResponse(soap, NULL, NULL, "srm2:srmRmdirResponse");
	case SOAP_TYPE_srm2__srmRmdirRequest:
		return soap_in_srm2__srmRmdirRequest(soap, NULL, NULL, "srm2:srmRmdirRequest");
	case SOAP_TYPE_srm2__srmMkdirResponse:
		return soap_in_srm2__srmMkdirResponse(soap, NULL, NULL, "srm2:srmMkdirResponse");
	case SOAP_TYPE_srm2__srmMkdirRequest:
		return soap_in_srm2__srmMkdirRequest(soap, NULL, NULL, "srm2:srmMkdirRequest");
	case SOAP_TYPE_srm2__srmGetPermissionResponse:
		return soap_in_srm2__srmGetPermissionResponse(soap, NULL, NULL, "srm2:srmGetPermissionResponse");
	case SOAP_TYPE_srm2__srmGetPermissionRequest:
		return soap_in_srm2__srmGetPermissionRequest(soap, NULL, NULL, "srm2:srmGetPermissionRequest");
	case SOAP_TYPE_srm2__srmCheckPermissionResponse:
		return soap_in_srm2__srmCheckPermissionResponse(soap, NULL, NULL, "srm2:srmCheckPermissionResponse");
	case SOAP_TYPE_srm2__srmCheckPermissionRequest:
		return soap_in_srm2__srmCheckPermissionRequest(soap, NULL, NULL, "srm2:srmCheckPermissionRequest");
	case SOAP_TYPE_srm2__srmSetPermissionResponse:
		return soap_in_srm2__srmSetPermissionResponse(soap, NULL, NULL, "srm2:srmSetPermissionResponse");
	case SOAP_TYPE_srm2__srmSetPermissionRequest:
		return soap_in_srm2__srmSetPermissionRequest(soap, NULL, NULL, "srm2:srmSetPermissionRequest");
	case SOAP_TYPE_srm2__srmGetSpaceTokensResponse:
		return soap_in_srm2__srmGetSpaceTokensResponse(soap, NULL, NULL, "srm2:srmGetSpaceTokensResponse");
	case SOAP_TYPE_srm2__srmGetSpaceTokensRequest:
		return soap_in_srm2__srmGetSpaceTokensRequest(soap, NULL, NULL, "srm2:srmGetSpaceTokensRequest");
	case SOAP_TYPE_srm2__srmPurgeFromSpaceResponse:
		return soap_in_srm2__srmPurgeFromSpaceResponse(soap, NULL, NULL, "srm2:srmPurgeFromSpaceResponse");
	case SOAP_TYPE_srm2__srmPurgeFromSpaceRequest:
		return soap_in_srm2__srmPurgeFromSpaceRequest(soap, NULL, NULL, "srm2:srmPurgeFromSpaceRequest");
	case SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpaceResponse:
		return soap_in_srm2__srmExtendFileLifeTimeInSpaceResponse(soap, NULL, NULL, "srm2:srmExtendFileLifeTimeInSpaceResponse");
	case SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpaceRequest:
		return soap_in_srm2__srmExtendFileLifeTimeInSpaceRequest(soap, NULL, NULL, "srm2:srmExtendFileLifeTimeInSpaceRequest");
	case SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequestResponse:
		return soap_in_srm2__srmStatusOfChangeSpaceForFilesRequestResponse(soap, NULL, NULL, "srm2:srmStatusOfChangeSpaceForFilesRequestResponse");
	case SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequestRequest:
		return soap_in_srm2__srmStatusOfChangeSpaceForFilesRequestRequest(soap, NULL, NULL, "srm2:srmStatusOfChangeSpaceForFilesRequestRequest");
	case SOAP_TYPE_srm2__srmChangeSpaceForFilesResponse:
		return soap_in_srm2__srmChangeSpaceForFilesResponse(soap, NULL, NULL, "srm2:srmChangeSpaceForFilesResponse");
	case SOAP_TYPE_srm2__srmChangeSpaceForFilesRequest:
		return soap_in_srm2__srmChangeSpaceForFilesRequest(soap, NULL, NULL, "srm2:srmChangeSpaceForFilesRequest");
	case SOAP_TYPE_srm2__srmGetSpaceMetaDataResponse:
		return soap_in_srm2__srmGetSpaceMetaDataResponse(soap, NULL, NULL, "srm2:srmGetSpaceMetaDataResponse");
	case SOAP_TYPE_srm2__srmGetSpaceMetaDataRequest:
		return soap_in_srm2__srmGetSpaceMetaDataRequest(soap, NULL, NULL, "srm2:srmGetSpaceMetaDataRequest");
	case SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequestResponse:
		return soap_in_srm2__srmStatusOfUpdateSpaceRequestResponse(soap, NULL, NULL, "srm2:srmStatusOfUpdateSpaceRequestResponse");
	case SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequestRequest:
		return soap_in_srm2__srmStatusOfUpdateSpaceRequestRequest(soap, NULL, NULL, "srm2:srmStatusOfUpdateSpaceRequestRequest");
	case SOAP_TYPE_srm2__srmUpdateSpaceResponse:
		return soap_in_srm2__srmUpdateSpaceResponse(soap, NULL, NULL, "srm2:srmUpdateSpaceResponse");
	case SOAP_TYPE_srm2__srmUpdateSpaceRequest:
		return soap_in_srm2__srmUpdateSpaceRequest(soap, NULL, NULL, "srm2:srmUpdateSpaceRequest");
	case SOAP_TYPE_srm2__srmReleaseSpaceResponse:
		return soap_in_srm2__srmReleaseSpaceResponse(soap, NULL, NULL, "srm2:srmReleaseSpaceResponse");
	case SOAP_TYPE_srm2__srmReleaseSpaceRequest:
		return soap_in_srm2__srmReleaseSpaceRequest(soap, NULL, NULL, "srm2:srmReleaseSpaceRequest");
	case SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequestResponse:
		return soap_in_srm2__srmStatusOfReserveSpaceRequestResponse(soap, NULL, NULL, "srm2:srmStatusOfReserveSpaceRequestResponse");
	case SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequestRequest:
		return soap_in_srm2__srmStatusOfReserveSpaceRequestRequest(soap, NULL, NULL, "srm2:srmStatusOfReserveSpaceRequestRequest");
	case SOAP_TYPE_srm2__srmReserveSpaceResponse:
		return soap_in_srm2__srmReserveSpaceResponse(soap, NULL, NULL, "srm2:srmReserveSpaceResponse");
	case SOAP_TYPE_srm2__srmReserveSpaceRequest:
		return soap_in_srm2__srmReserveSpaceRequest(soap, NULL, NULL, "srm2:srmReserveSpaceRequest");
	case SOAP_TYPE_srm2__ArrayOfTSupportedTransferProtocol:
		return soap_in_srm2__ArrayOfTSupportedTransferProtocol(soap, NULL, NULL, "srm2:ArrayOfTSupportedTransferProtocol");
	case SOAP_TYPE_srm2__TSupportedTransferProtocol:
		return soap_in_srm2__TSupportedTransferProtocol(soap, NULL, NULL, "srm2:TSupportedTransferProtocol");
	case SOAP_TYPE_srm2__ArrayOfTRequestTokenReturn:
		return soap_in_srm2__ArrayOfTRequestTokenReturn(soap, NULL, NULL, "srm2:ArrayOfTRequestTokenReturn");
	case SOAP_TYPE_srm2__TRequestTokenReturn:
		return soap_in_srm2__TRequestTokenReturn(soap, NULL, NULL, "srm2:TRequestTokenReturn");
	case SOAP_TYPE_srm2__ArrayOfTPermissionReturn:
		return soap_in_srm2__ArrayOfTPermissionReturn(soap, NULL, NULL, "srm2:ArrayOfTPermissionReturn");
	case SOAP_TYPE_srm2__TPermissionReturn:
		return soap_in_srm2__TPermissionReturn(soap, NULL, NULL, "srm2:TPermissionReturn");
	case SOAP_TYPE_srm2__ArrayOfTSURLPermissionReturn:
		return soap_in_srm2__ArrayOfTSURLPermissionReturn(soap, NULL, NULL, "srm2:ArrayOfTSURLPermissionReturn");
	case SOAP_TYPE_srm2__TSURLPermissionReturn:
		return soap_in_srm2__TSURLPermissionReturn(soap, NULL, NULL, "srm2:TSURLPermissionReturn");
	case SOAP_TYPE_srm2__ArrayOfTRequestSummary:
		return soap_in_srm2__ArrayOfTRequestSummary(soap, NULL, NULL, "srm2:ArrayOfTRequestSummary");
	case SOAP_TYPE_srm2__TRequestSummary:
		return soap_in_srm2__TRequestSummary(soap, NULL, NULL, "srm2:TRequestSummary");
	case SOAP_TYPE_srm2__ArrayOfTCopyRequestFileStatus:
		return soap_in_srm2__ArrayOfTCopyRequestFileStatus(soap, NULL, NULL, "srm2:ArrayOfTCopyRequestFileStatus");
	case SOAP_TYPE_srm2__TCopyRequestFileStatus:
		return soap_in_srm2__TCopyRequestFileStatus(soap, NULL, NULL, "srm2:TCopyRequestFileStatus");
	case SOAP_TYPE_srm2__ArrayOfTPutRequestFileStatus:
		return soap_in_srm2__ArrayOfTPutRequestFileStatus(soap, NULL, NULL, "srm2:ArrayOfTPutRequestFileStatus");
	case SOAP_TYPE_srm2__TPutRequestFileStatus:
		return soap_in_srm2__TPutRequestFileStatus(soap, NULL, NULL, "srm2:TPutRequestFileStatus");
	case SOAP_TYPE_srm2__ArrayOfTBringOnlineRequestFileStatus:
		return soap_in_srm2__ArrayOfTBringOnlineRequestFileStatus(soap, NULL, NULL, "srm2:ArrayOfTBringOnlineRequestFileStatus");
	case SOAP_TYPE_srm2__TBringOnlineRequestFileStatus:
		return soap_in_srm2__TBringOnlineRequestFileStatus(soap, NULL, NULL, "srm2:TBringOnlineRequestFileStatus");
	case SOAP_TYPE_srm2__ArrayOfTGetRequestFileStatus:
		return soap_in_srm2__ArrayOfTGetRequestFileStatus(soap, NULL, NULL, "srm2:ArrayOfTGetRequestFileStatus");
	case SOAP_TYPE_srm2__TGetRequestFileStatus:
		return soap_in_srm2__TGetRequestFileStatus(soap, NULL, NULL, "srm2:TGetRequestFileStatus");
	case SOAP_TYPE_srm2__ArrayOfTCopyFileRequest:
		return soap_in_srm2__ArrayOfTCopyFileRequest(soap, NULL, NULL, "srm2:ArrayOfTCopyFileRequest");
	case SOAP_TYPE_srm2__TCopyFileRequest:
		return soap_in_srm2__TCopyFileRequest(soap, NULL, NULL, "srm2:TCopyFileRequest");
	case SOAP_TYPE_srm2__ArrayOfTPutFileRequest:
		return soap_in_srm2__ArrayOfTPutFileRequest(soap, NULL, NULL, "srm2:ArrayOfTPutFileRequest");
	case SOAP_TYPE_srm2__TPutFileRequest:
		return soap_in_srm2__TPutFileRequest(soap, NULL, NULL, "srm2:TPutFileRequest");
	case SOAP_TYPE_srm2__ArrayOfTGetFileRequest:
		return soap_in_srm2__ArrayOfTGetFileRequest(soap, NULL, NULL, "srm2:ArrayOfTGetFileRequest");
	case SOAP_TYPE_srm2__TGetFileRequest:
		return soap_in_srm2__TGetFileRequest(soap, NULL, NULL, "srm2:TGetFileRequest");
	case SOAP_TYPE_srm2__TTransferParameters:
		return soap_in_srm2__TTransferParameters(soap, NULL, NULL, "srm2:TTransferParameters");
	case SOAP_TYPE_srm2__ArrayOfAnyURI:
		return soap_in_srm2__ArrayOfAnyURI(soap, NULL, NULL, "srm2:ArrayOfAnyURI");
	case SOAP_TYPE_srm2__ArrayOfTExtraInfo:
		return soap_in_srm2__ArrayOfTExtraInfo(soap, NULL, NULL, "srm2:ArrayOfTExtraInfo");
	case SOAP_TYPE_srm2__TExtraInfo:
		return soap_in_srm2__TExtraInfo(soap, NULL, NULL, "srm2:TExtraInfo");
	case SOAP_TYPE_srm2__TDirOption:
		return soap_in_srm2__TDirOption(soap, NULL, NULL, "srm2:TDirOption");
	case SOAP_TYPE_srm2__ArrayOfTMetaDataSpace:
		return soap_in_srm2__ArrayOfTMetaDataSpace(soap, NULL, NULL, "srm2:ArrayOfTMetaDataSpace");
	case SOAP_TYPE_srm2__TMetaDataSpace:
		return soap_in_srm2__TMetaDataSpace(soap, NULL, NULL, "srm2:TMetaDataSpace");
	case SOAP_TYPE_srm2__ArrayOfTMetaDataPathDetail:
		return soap_in_srm2__ArrayOfTMetaDataPathDetail(soap, NULL, NULL, "srm2:ArrayOfTMetaDataPathDetail");
	case SOAP_TYPE_srm2__TMetaDataPathDetail:
		return soap_in_srm2__TMetaDataPathDetail(soap, NULL, NULL, "srm2:TMetaDataPathDetail");
	case SOAP_TYPE_srm2__ArrayOfTSURLLifetimeReturnStatus:
		return soap_in_srm2__ArrayOfTSURLLifetimeReturnStatus(soap, NULL, NULL, "srm2:ArrayOfTSURLLifetimeReturnStatus");
	case SOAP_TYPE_srm2__TSURLLifetimeReturnStatus:
		return soap_in_srm2__TSURLLifetimeReturnStatus(soap, NULL, NULL, "srm2:TSURLLifetimeReturnStatus");
	case SOAP_TYPE_srm2__ArrayOfTSURLReturnStatus:
		return soap_in_srm2__ArrayOfTSURLReturnStatus(soap, NULL, NULL, "srm2:ArrayOfTSURLReturnStatus");
	case SOAP_TYPE_srm2__TSURLReturnStatus:
		return soap_in_srm2__TSURLReturnStatus(soap, NULL, NULL, "srm2:TSURLReturnStatus");
	case SOAP_TYPE_srm2__TReturnStatus:
		return soap_in_srm2__TReturnStatus(soap, NULL, NULL, "srm2:TReturnStatus");
	case SOAP_TYPE_srm2__ArrayOfString:
		return soap_in_srm2__ArrayOfString(soap, NULL, NULL, "srm2:ArrayOfString");
	case SOAP_TYPE_srm2__ArrayOfUnsignedLong:
		return soap_in_srm2__ArrayOfUnsignedLong(soap, NULL, NULL, "srm2:ArrayOfUnsignedLong");
	case SOAP_TYPE_srm2__ArrayOfTGroupPermission:
		return soap_in_srm2__ArrayOfTGroupPermission(soap, NULL, NULL, "srm2:ArrayOfTGroupPermission");
	case SOAP_TYPE_srm2__TGroupPermission:
		return soap_in_srm2__TGroupPermission(soap, NULL, NULL, "srm2:TGroupPermission");
	case SOAP_TYPE_srm2__ArrayOfTUserPermission:
		return soap_in_srm2__ArrayOfTUserPermission(soap, NULL, NULL, "srm2:ArrayOfTUserPermission");
	case SOAP_TYPE_srm2__TUserPermission:
		return soap_in_srm2__TUserPermission(soap, NULL, NULL, "srm2:TUserPermission");
	case SOAP_TYPE_srm2__TRetentionPolicyInfo:
		return soap_in_srm2__TRetentionPolicyInfo(soap, NULL, NULL, "srm2:TRetentionPolicyInfo");
	case SOAP_TYPE_PointerToSOAP_ENV__Reason:
		return soap_in_PointerToSOAP_ENV__Reason(soap, NULL, NULL, "SOAP-ENV:Reason");
	case SOAP_TYPE_PointerTosrm2__srmPingResponse_:
		return soap_in_PointerTosrm2__srmPingResponse_(soap, NULL, NULL, "srm2:srmPingResponse");
	case SOAP_TYPE_PointerTosrm2__srmPingRequest:
		return soap_in_PointerTosrm2__srmPingRequest(soap, NULL, NULL, "srm2:srmPingRequest");
	case SOAP_TYPE_PointerTosrm2__srmPingResponse:
		return soap_in_PointerTosrm2__srmPingResponse(soap, NULL, NULL, "srm2:srmPingResponse");
	case SOAP_TYPE_PointerTosrm2__srmGetTransferProtocolsResponse_:
		return soap_in_PointerTosrm2__srmGetTransferProtocolsResponse_(soap, NULL, NULL, "srm2:srmGetTransferProtocolsResponse");
	case SOAP_TYPE_PointerTosrm2__srmGetTransferProtocolsRequest:
		return soap_in_PointerTosrm2__srmGetTransferProtocolsRequest(soap, NULL, NULL, "srm2:srmGetTransferProtocolsRequest");
	case SOAP_TYPE_PointerTosrm2__srmGetTransferProtocolsResponse:
		return soap_in_PointerTosrm2__srmGetTransferProtocolsResponse(soap, NULL, NULL, "srm2:srmGetTransferProtocolsResponse");
	case SOAP_TYPE_PointerTosrm2__srmGetRequestTokensResponse_:
		return soap_in_PointerTosrm2__srmGetRequestTokensResponse_(soap, NULL, NULL, "srm2:srmGetRequestTokensResponse");
	case SOAP_TYPE_PointerTosrm2__srmGetRequestTokensRequest:
		return soap_in_PointerTosrm2__srmGetRequestTokensRequest(soap, NULL, NULL, "srm2:srmGetRequestTokensRequest");
	case SOAP_TYPE_PointerTosrm2__srmGetRequestTokensResponse:
		return soap_in_PointerTosrm2__srmGetRequestTokensResponse(soap, NULL, NULL, "srm2:srmGetRequestTokensResponse");
	case SOAP_TYPE_PointerTosrm2__srmExtendFileLifeTimeResponse_:
		return soap_in_PointerTosrm2__srmExtendFileLifeTimeResponse_(soap, NULL, NULL, "srm2:srmExtendFileLifeTimeResponse");
	case SOAP_TYPE_PointerTosrm2__srmExtendFileLifeTimeRequest:
		return soap_in_PointerTosrm2__srmExtendFileLifeTimeRequest(soap, NULL, NULL, "srm2:srmExtendFileLifeTimeRequest");
	case SOAP_TYPE_PointerTosrm2__srmExtendFileLifeTimeResponse:
		return soap_in_PointerTosrm2__srmExtendFileLifeTimeResponse(soap, NULL, NULL, "srm2:srmExtendFileLifeTimeResponse");
	case SOAP_TYPE_PointerTosrm2__srmGetRequestSummaryResponse_:
		return soap_in_PointerTosrm2__srmGetRequestSummaryResponse_(soap, NULL, NULL, "srm2:srmGetRequestSummaryResponse");
	case SOAP_TYPE_PointerTosrm2__srmGetRequestSummaryRequest:
		return soap_in_PointerTosrm2__srmGetRequestSummaryRequest(soap, NULL, NULL, "srm2:srmGetRequestSummaryRequest");
	case SOAP_TYPE_PointerTosrm2__srmGetRequestSummaryResponse:
		return soap_in_PointerTosrm2__srmGetRequestSummaryResponse(soap, NULL, NULL, "srm2:srmGetRequestSummaryResponse");
	case SOAP_TYPE_PointerTosrm2__srmResumeRequestResponse_:
		return soap_in_PointerTosrm2__srmResumeRequestResponse_(soap, NULL, NULL, "srm2:srmResumeRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmResumeRequestRequest:
		return soap_in_PointerTosrm2__srmResumeRequestRequest(soap, NULL, NULL, "srm2:srmResumeRequestRequest");
	case SOAP_TYPE_PointerTosrm2__srmResumeRequestResponse:
		return soap_in_PointerTosrm2__srmResumeRequestResponse(soap, NULL, NULL, "srm2:srmResumeRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmSuspendRequestResponse_:
		return soap_in_PointerTosrm2__srmSuspendRequestResponse_(soap, NULL, NULL, "srm2:srmSuspendRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmSuspendRequestRequest:
		return soap_in_PointerTosrm2__srmSuspendRequestRequest(soap, NULL, NULL, "srm2:srmSuspendRequestRequest");
	case SOAP_TYPE_PointerTosrm2__srmSuspendRequestResponse:
		return soap_in_PointerTosrm2__srmSuspendRequestResponse(soap, NULL, NULL, "srm2:srmSuspendRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmAbortFilesResponse_:
		return soap_in_PointerTosrm2__srmAbortFilesResponse_(soap, NULL, NULL, "srm2:srmAbortFilesResponse");
	case SOAP_TYPE_PointerTosrm2__srmAbortFilesRequest:
		return soap_in_PointerTosrm2__srmAbortFilesRequest(soap, NULL, NULL, "srm2:srmAbortFilesRequest");
	case SOAP_TYPE_PointerTosrm2__srmAbortFilesResponse:
		return soap_in_PointerTosrm2__srmAbortFilesResponse(soap, NULL, NULL, "srm2:srmAbortFilesResponse");
	case SOAP_TYPE_PointerTosrm2__srmAbortRequestResponse_:
		return soap_in_PointerTosrm2__srmAbortRequestResponse_(soap, NULL, NULL, "srm2:srmAbortRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmAbortRequestRequest:
		return soap_in_PointerTosrm2__srmAbortRequestRequest(soap, NULL, NULL, "srm2:srmAbortRequestRequest");
	case SOAP_TYPE_PointerTosrm2__srmAbortRequestResponse:
		return soap_in_PointerTosrm2__srmAbortRequestResponse(soap, NULL, NULL, "srm2:srmAbortRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmPutDoneResponse_:
		return soap_in_PointerTosrm2__srmPutDoneResponse_(soap, NULL, NULL, "srm2:srmPutDoneResponse");
	case SOAP_TYPE_PointerTosrm2__srmPutDoneRequest:
		return soap_in_PointerTosrm2__srmPutDoneRequest(soap, NULL, NULL, "srm2:srmPutDoneRequest");
	case SOAP_TYPE_PointerTosrm2__srmPutDoneResponse:
		return soap_in_PointerTosrm2__srmPutDoneResponse(soap, NULL, NULL, "srm2:srmPutDoneResponse");
	case SOAP_TYPE_PointerTosrm2__srmReleaseFilesResponse_:
		return soap_in_PointerTosrm2__srmReleaseFilesResponse_(soap, NULL, NULL, "srm2:srmReleaseFilesResponse");
	case SOAP_TYPE_PointerTosrm2__srmReleaseFilesRequest:
		return soap_in_PointerTosrm2__srmReleaseFilesRequest(soap, NULL, NULL, "srm2:srmReleaseFilesRequest");
	case SOAP_TYPE_PointerTosrm2__srmReleaseFilesResponse:
		return soap_in_PointerTosrm2__srmReleaseFilesResponse(soap, NULL, NULL, "srm2:srmReleaseFilesResponse");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfCopyRequestResponse_:
		return soap_in_PointerTosrm2__srmStatusOfCopyRequestResponse_(soap, NULL, NULL, "srm2:srmStatusOfCopyRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfCopyRequestRequest:
		return soap_in_PointerTosrm2__srmStatusOfCopyRequestRequest(soap, NULL, NULL, "srm2:srmStatusOfCopyRequestRequest");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfCopyRequestResponse:
		return soap_in_PointerTosrm2__srmStatusOfCopyRequestResponse(soap, NULL, NULL, "srm2:srmStatusOfCopyRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmCopyResponse_:
		return soap_in_PointerTosrm2__srmCopyResponse_(soap, NULL, NULL, "srm2:srmCopyResponse");
	case SOAP_TYPE_PointerTosrm2__srmCopyRequest:
		return soap_in_PointerTosrm2__srmCopyRequest(soap, NULL, NULL, "srm2:srmCopyRequest");
	case SOAP_TYPE_PointerTosrm2__srmCopyResponse:
		return soap_in_PointerTosrm2__srmCopyResponse(soap, NULL, NULL, "srm2:srmCopyResponse");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfPutRequestResponse_:
		return soap_in_PointerTosrm2__srmStatusOfPutRequestResponse_(soap, NULL, NULL, "srm2:srmStatusOfPutRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfPutRequestRequest:
		return soap_in_PointerTosrm2__srmStatusOfPutRequestRequest(soap, NULL, NULL, "srm2:srmStatusOfPutRequestRequest");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfPutRequestResponse:
		return soap_in_PointerTosrm2__srmStatusOfPutRequestResponse(soap, NULL, NULL, "srm2:srmStatusOfPutRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmPrepareToPutResponse_:
		return soap_in_PointerTosrm2__srmPrepareToPutResponse_(soap, NULL, NULL, "srm2:srmPrepareToPutResponse");
	case SOAP_TYPE_PointerTosrm2__srmPrepareToPutRequest:
		return soap_in_PointerTosrm2__srmPrepareToPutRequest(soap, NULL, NULL, "srm2:srmPrepareToPutRequest");
	case SOAP_TYPE_PointerTosrm2__srmPrepareToPutResponse:
		return soap_in_PointerTosrm2__srmPrepareToPutResponse(soap, NULL, NULL, "srm2:srmPrepareToPutResponse");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfBringOnlineRequestResponse_:
		return soap_in_PointerTosrm2__srmStatusOfBringOnlineRequestResponse_(soap, NULL, NULL, "srm2:srmStatusOfBringOnlineRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfBringOnlineRequestRequest:
		return soap_in_PointerTosrm2__srmStatusOfBringOnlineRequestRequest(soap, NULL, NULL, "srm2:srmStatusOfBringOnlineRequestRequest");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfBringOnlineRequestResponse:
		return soap_in_PointerTosrm2__srmStatusOfBringOnlineRequestResponse(soap, NULL, NULL, "srm2:srmStatusOfBringOnlineRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmBringOnlineResponse_:
		return soap_in_PointerTosrm2__srmBringOnlineResponse_(soap, NULL, NULL, "srm2:srmBringOnlineResponse");
	case SOAP_TYPE_PointerTosrm2__srmBringOnlineRequest:
		return soap_in_PointerTosrm2__srmBringOnlineRequest(soap, NULL, NULL, "srm2:srmBringOnlineRequest");
	case SOAP_TYPE_PointerTosrm2__srmBringOnlineResponse:
		return soap_in_PointerTosrm2__srmBringOnlineResponse(soap, NULL, NULL, "srm2:srmBringOnlineResponse");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfGetRequestResponse_:
		return soap_in_PointerTosrm2__srmStatusOfGetRequestResponse_(soap, NULL, NULL, "srm2:srmStatusOfGetRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfGetRequestRequest:
		return soap_in_PointerTosrm2__srmStatusOfGetRequestRequest(soap, NULL, NULL, "srm2:srmStatusOfGetRequestRequest");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfGetRequestResponse:
		return soap_in_PointerTosrm2__srmStatusOfGetRequestResponse(soap, NULL, NULL, "srm2:srmStatusOfGetRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmPrepareToGetResponse_:
		return soap_in_PointerTosrm2__srmPrepareToGetResponse_(soap, NULL, NULL, "srm2:srmPrepareToGetResponse");
	case SOAP_TYPE_PointerTosrm2__srmPrepareToGetRequest:
		return soap_in_PointerTosrm2__srmPrepareToGetRequest(soap, NULL, NULL, "srm2:srmPrepareToGetRequest");
	case SOAP_TYPE_PointerTosrm2__srmPrepareToGetResponse:
		return soap_in_PointerTosrm2__srmPrepareToGetResponse(soap, NULL, NULL, "srm2:srmPrepareToGetResponse");
	case SOAP_TYPE_PointerTosrm2__srmMvResponse_:
		return soap_in_PointerTosrm2__srmMvResponse_(soap, NULL, NULL, "srm2:srmMvResponse");
	case SOAP_TYPE_PointerTosrm2__srmMvRequest:
		return soap_in_PointerTosrm2__srmMvRequest(soap, NULL, NULL, "srm2:srmMvRequest");
	case SOAP_TYPE_PointerTosrm2__srmMvResponse:
		return soap_in_PointerTosrm2__srmMvResponse(soap, NULL, NULL, "srm2:srmMvResponse");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfLsRequestResponse_:
		return soap_in_PointerTosrm2__srmStatusOfLsRequestResponse_(soap, NULL, NULL, "srm2:srmStatusOfLsRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfLsRequestRequest:
		return soap_in_PointerTosrm2__srmStatusOfLsRequestRequest(soap, NULL, NULL, "srm2:srmStatusOfLsRequestRequest");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfLsRequestResponse:
		return soap_in_PointerTosrm2__srmStatusOfLsRequestResponse(soap, NULL, NULL, "srm2:srmStatusOfLsRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmLsResponse_:
		return soap_in_PointerTosrm2__srmLsResponse_(soap, NULL, NULL, "srm2:srmLsResponse");
	case SOAP_TYPE_PointerTosrm2__srmLsRequest:
		return soap_in_PointerTosrm2__srmLsRequest(soap, NULL, NULL, "srm2:srmLsRequest");
	case SOAP_TYPE_PointerTosrm2__srmLsResponse:
		return soap_in_PointerTosrm2__srmLsResponse(soap, NULL, NULL, "srm2:srmLsResponse");
	case SOAP_TYPE_PointerTosrm2__srmRmResponse_:
		return soap_in_PointerTosrm2__srmRmResponse_(soap, NULL, NULL, "srm2:srmRmResponse");
	case SOAP_TYPE_PointerTosrm2__srmRmRequest:
		return soap_in_PointerTosrm2__srmRmRequest(soap, NULL, NULL, "srm2:srmRmRequest");
	case SOAP_TYPE_PointerTosrm2__srmRmResponse:
		return soap_in_PointerTosrm2__srmRmResponse(soap, NULL, NULL, "srm2:srmRmResponse");
	case SOAP_TYPE_PointerTosrm2__srmRmdirResponse_:
		return soap_in_PointerTosrm2__srmRmdirResponse_(soap, NULL, NULL, "srm2:srmRmdirResponse");
	case SOAP_TYPE_PointerTosrm2__srmRmdirRequest:
		return soap_in_PointerTosrm2__srmRmdirRequest(soap, NULL, NULL, "srm2:srmRmdirRequest");
	case SOAP_TYPE_PointerTosrm2__srmRmdirResponse:
		return soap_in_PointerTosrm2__srmRmdirResponse(soap, NULL, NULL, "srm2:srmRmdirResponse");
	case SOAP_TYPE_PointerTosrm2__srmMkdirResponse_:
		return soap_in_PointerTosrm2__srmMkdirResponse_(soap, NULL, NULL, "srm2:srmMkdirResponse");
	case SOAP_TYPE_PointerTosrm2__srmMkdirRequest:
		return soap_in_PointerTosrm2__srmMkdirRequest(soap, NULL, NULL, "srm2:srmMkdirRequest");
	case SOAP_TYPE_PointerTosrm2__srmMkdirResponse:
		return soap_in_PointerTosrm2__srmMkdirResponse(soap, NULL, NULL, "srm2:srmMkdirResponse");
	case SOAP_TYPE_PointerTosrm2__srmGetPermissionResponse_:
		return soap_in_PointerTosrm2__srmGetPermissionResponse_(soap, NULL, NULL, "srm2:srmGetPermissionResponse");
	case SOAP_TYPE_PointerTosrm2__srmGetPermissionRequest:
		return soap_in_PointerTosrm2__srmGetPermissionRequest(soap, NULL, NULL, "srm2:srmGetPermissionRequest");
	case SOAP_TYPE_PointerTosrm2__srmGetPermissionResponse:
		return soap_in_PointerTosrm2__srmGetPermissionResponse(soap, NULL, NULL, "srm2:srmGetPermissionResponse");
	case SOAP_TYPE_PointerTosrm2__srmCheckPermissionResponse_:
		return soap_in_PointerTosrm2__srmCheckPermissionResponse_(soap, NULL, NULL, "srm2:srmCheckPermissionResponse");
	case SOAP_TYPE_PointerTosrm2__srmCheckPermissionRequest:
		return soap_in_PointerTosrm2__srmCheckPermissionRequest(soap, NULL, NULL, "srm2:srmCheckPermissionRequest");
	case SOAP_TYPE_PointerTosrm2__srmCheckPermissionResponse:
		return soap_in_PointerTosrm2__srmCheckPermissionResponse(soap, NULL, NULL, "srm2:srmCheckPermissionResponse");
	case SOAP_TYPE_PointerTosrm2__srmSetPermissionResponse_:
		return soap_in_PointerTosrm2__srmSetPermissionResponse_(soap, NULL, NULL, "srm2:srmSetPermissionResponse");
	case SOAP_TYPE_PointerTosrm2__srmSetPermissionRequest:
		return soap_in_PointerTosrm2__srmSetPermissionRequest(soap, NULL, NULL, "srm2:srmSetPermissionRequest");
	case SOAP_TYPE_PointerTosrm2__srmSetPermissionResponse:
		return soap_in_PointerTosrm2__srmSetPermissionResponse(soap, NULL, NULL, "srm2:srmSetPermissionResponse");
	case SOAP_TYPE_PointerTosrm2__srmGetSpaceTokensResponse_:
		return soap_in_PointerTosrm2__srmGetSpaceTokensResponse_(soap, NULL, NULL, "srm2:srmGetSpaceTokensResponse");
	case SOAP_TYPE_PointerTosrm2__srmGetSpaceTokensRequest:
		return soap_in_PointerTosrm2__srmGetSpaceTokensRequest(soap, NULL, NULL, "srm2:srmGetSpaceTokensRequest");
	case SOAP_TYPE_PointerTosrm2__srmGetSpaceTokensResponse:
		return soap_in_PointerTosrm2__srmGetSpaceTokensResponse(soap, NULL, NULL, "srm2:srmGetSpaceTokensResponse");
	case SOAP_TYPE_PointerTosrm2__srmPurgeFromSpaceResponse_:
		return soap_in_PointerTosrm2__srmPurgeFromSpaceResponse_(soap, NULL, NULL, "srm2:srmPurgeFromSpaceResponse");
	case SOAP_TYPE_PointerTosrm2__srmPurgeFromSpaceRequest:
		return soap_in_PointerTosrm2__srmPurgeFromSpaceRequest(soap, NULL, NULL, "srm2:srmPurgeFromSpaceRequest");
	case SOAP_TYPE_PointerTosrm2__srmPurgeFromSpaceResponse:
		return soap_in_PointerTosrm2__srmPurgeFromSpaceResponse(soap, NULL, NULL, "srm2:srmPurgeFromSpaceResponse");
	case SOAP_TYPE_PointerTosrm2__srmExtendFileLifeTimeInSpaceResponse_:
		return soap_in_PointerTosrm2__srmExtendFileLifeTimeInSpaceResponse_(soap, NULL, NULL, "srm2:srmExtendFileLifeTimeInSpaceResponse");
	case SOAP_TYPE_PointerTosrm2__srmExtendFileLifeTimeInSpaceRequest:
		return soap_in_PointerTosrm2__srmExtendFileLifeTimeInSpaceRequest(soap, NULL, NULL, "srm2:srmExtendFileLifeTimeInSpaceRequest");
	case SOAP_TYPE_PointerTosrm2__srmExtendFileLifeTimeInSpaceResponse:
		return soap_in_PointerTosrm2__srmExtendFileLifeTimeInSpaceResponse(soap, NULL, NULL, "srm2:srmExtendFileLifeTimeInSpaceResponse");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestResponse_:
		return soap_in_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestResponse_(soap, NULL, NULL, "srm2:srmStatusOfChangeSpaceForFilesRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestRequest:
		return soap_in_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestRequest(soap, NULL, NULL, "srm2:srmStatusOfChangeSpaceForFilesRequestRequest");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestResponse:
		return soap_in_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestResponse(soap, NULL, NULL, "srm2:srmStatusOfChangeSpaceForFilesRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmChangeSpaceForFilesResponse_:
		return soap_in_PointerTosrm2__srmChangeSpaceForFilesResponse_(soap, NULL, NULL, "srm2:srmChangeSpaceForFilesResponse");
	case SOAP_TYPE_PointerTosrm2__srmChangeSpaceForFilesRequest:
		return soap_in_PointerTosrm2__srmChangeSpaceForFilesRequest(soap, NULL, NULL, "srm2:srmChangeSpaceForFilesRequest");
	case SOAP_TYPE_PointerTosrm2__srmChangeSpaceForFilesResponse:
		return soap_in_PointerTosrm2__srmChangeSpaceForFilesResponse(soap, NULL, NULL, "srm2:srmChangeSpaceForFilesResponse");
	case SOAP_TYPE_PointerTosrm2__srmGetSpaceMetaDataResponse_:
		return soap_in_PointerTosrm2__srmGetSpaceMetaDataResponse_(soap, NULL, NULL, "srm2:srmGetSpaceMetaDataResponse");
	case SOAP_TYPE_PointerTosrm2__srmGetSpaceMetaDataRequest:
		return soap_in_PointerTosrm2__srmGetSpaceMetaDataRequest(soap, NULL, NULL, "srm2:srmGetSpaceMetaDataRequest");
	case SOAP_TYPE_PointerTosrm2__srmGetSpaceMetaDataResponse:
		return soap_in_PointerTosrm2__srmGetSpaceMetaDataResponse(soap, NULL, NULL, "srm2:srmGetSpaceMetaDataResponse");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfUpdateSpaceRequestResponse_:
		return soap_in_PointerTosrm2__srmStatusOfUpdateSpaceRequestResponse_(soap, NULL, NULL, "srm2:srmStatusOfUpdateSpaceRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfUpdateSpaceRequestRequest:
		return soap_in_PointerTosrm2__srmStatusOfUpdateSpaceRequestRequest(soap, NULL, NULL, "srm2:srmStatusOfUpdateSpaceRequestRequest");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfUpdateSpaceRequestResponse:
		return soap_in_PointerTosrm2__srmStatusOfUpdateSpaceRequestResponse(soap, NULL, NULL, "srm2:srmStatusOfUpdateSpaceRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmUpdateSpaceResponse_:
		return soap_in_PointerTosrm2__srmUpdateSpaceResponse_(soap, NULL, NULL, "srm2:srmUpdateSpaceResponse");
	case SOAP_TYPE_PointerTosrm2__srmUpdateSpaceRequest:
		return soap_in_PointerTosrm2__srmUpdateSpaceRequest(soap, NULL, NULL, "srm2:srmUpdateSpaceRequest");
	case SOAP_TYPE_PointerTosrm2__srmUpdateSpaceResponse:
		return soap_in_PointerTosrm2__srmUpdateSpaceResponse(soap, NULL, NULL, "srm2:srmUpdateSpaceResponse");
	case SOAP_TYPE_PointerTosrm2__srmReleaseSpaceResponse_:
		return soap_in_PointerTosrm2__srmReleaseSpaceResponse_(soap, NULL, NULL, "srm2:srmReleaseSpaceResponse");
	case SOAP_TYPE_PointerTosrm2__srmReleaseSpaceRequest:
		return soap_in_PointerTosrm2__srmReleaseSpaceRequest(soap, NULL, NULL, "srm2:srmReleaseSpaceRequest");
	case SOAP_TYPE_PointerTosrm2__srmReleaseSpaceResponse:
		return soap_in_PointerTosrm2__srmReleaseSpaceResponse(soap, NULL, NULL, "srm2:srmReleaseSpaceResponse");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfReserveSpaceRequestResponse_:
		return soap_in_PointerTosrm2__srmStatusOfReserveSpaceRequestResponse_(soap, NULL, NULL, "srm2:srmStatusOfReserveSpaceRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfReserveSpaceRequestRequest:
		return soap_in_PointerTosrm2__srmStatusOfReserveSpaceRequestRequest(soap, NULL, NULL, "srm2:srmStatusOfReserveSpaceRequestRequest");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfReserveSpaceRequestResponse:
		return soap_in_PointerTosrm2__srmStatusOfReserveSpaceRequestResponse(soap, NULL, NULL, "srm2:srmStatusOfReserveSpaceRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmReserveSpaceResponse_:
		return soap_in_PointerTosrm2__srmReserveSpaceResponse_(soap, NULL, NULL, "srm2:srmReserveSpaceResponse");
	case SOAP_TYPE_PointerTosrm2__srmReserveSpaceRequest:
		return soap_in_PointerTosrm2__srmReserveSpaceRequest(soap, NULL, NULL, "srm2:srmReserveSpaceRequest");
	case SOAP_TYPE_PointerTosrm2__srmReserveSpaceResponse:
		return soap_in_PointerTosrm2__srmReserveSpaceResponse(soap, NULL, NULL, "srm2:srmReserveSpaceResponse");
	case SOAP_TYPE_PointerTosrm2__ArrayOfTSupportedTransferProtocol:
		return soap_in_PointerTosrm2__ArrayOfTSupportedTransferProtocol(soap, NULL, NULL, "srm2:ArrayOfTSupportedTransferProtocol");
	case SOAP_TYPE_PointerTosrm2__ArrayOfTRequestTokenReturn:
		return soap_in_PointerTosrm2__ArrayOfTRequestTokenReturn(soap, NULL, NULL, "srm2:ArrayOfTRequestTokenReturn");
	case SOAP_TYPE_PointerTosrm2__ArrayOfTRequestSummary:
		return soap_in_PointerTosrm2__ArrayOfTRequestSummary(soap, NULL, NULL, "srm2:ArrayOfTRequestSummary");
	case SOAP_TYPE_PointerTosrm2__ArrayOfTCopyRequestFileStatus:
		return soap_in_PointerTosrm2__ArrayOfTCopyRequestFileStatus(soap, NULL, NULL, "srm2:ArrayOfTCopyRequestFileStatus");
	case SOAP_TYPE_PointerTosrm2__ArrayOfTCopyFileRequest:
		return soap_in_PointerTosrm2__ArrayOfTCopyFileRequest(soap, NULL, NULL, "srm2:ArrayOfTCopyFileRequest");
	case SOAP_TYPE_PointerTosrm2__ArrayOfTPutRequestFileStatus:
		return soap_in_PointerTosrm2__ArrayOfTPutRequestFileStatus(soap, NULL, NULL, "srm2:ArrayOfTPutRequestFileStatus");
	case SOAP_TYPE_PointerTosrm2__TOverwriteMode:
		return soap_in_PointerTosrm2__TOverwriteMode(soap, NULL, NULL, "srm2:TOverwriteMode");
	case SOAP_TYPE_PointerTosrm2__ArrayOfTPutFileRequest:
		return soap_in_PointerTosrm2__ArrayOfTPutFileRequest(soap, NULL, NULL, "srm2:ArrayOfTPutFileRequest");
	case SOAP_TYPE_PointerTosrm2__ArrayOfTBringOnlineRequestFileStatus:
		return soap_in_PointerTosrm2__ArrayOfTBringOnlineRequestFileStatus(soap, NULL, NULL, "srm2:ArrayOfTBringOnlineRequestFileStatus");
	case SOAP_TYPE_PointerTosrm2__ArrayOfTGetRequestFileStatus:
		return soap_in_PointerTosrm2__ArrayOfTGetRequestFileStatus(soap, NULL, NULL, "srm2:ArrayOfTGetRequestFileStatus");
	case SOAP_TYPE_PointerTosrm2__ArrayOfTGetFileRequest:
		return soap_in_PointerTosrm2__ArrayOfTGetFileRequest(soap, NULL, NULL, "srm2:ArrayOfTGetFileRequest");
	case SOAP_TYPE_PointerTosrm2__ArrayOfTPermissionReturn:
		return soap_in_PointerTosrm2__ArrayOfTPermissionReturn(soap, NULL, NULL, "srm2:ArrayOfTPermissionReturn");
	case SOAP_TYPE_PointerTosrm2__ArrayOfTSURLPermissionReturn:
		return soap_in_PointerTosrm2__ArrayOfTSURLPermissionReturn(soap, NULL, NULL, "srm2:ArrayOfTSURLPermissionReturn");
	case SOAP_TYPE_PointerTosrm2__ArrayOfTSURLLifetimeReturnStatus:
		return soap_in_PointerTosrm2__ArrayOfTSURLLifetimeReturnStatus(soap, NULL, NULL, "srm2:ArrayOfTSURLLifetimeReturnStatus");
	case SOAP_TYPE_PointerTosrm2__ArrayOfTSURLReturnStatus:
		return soap_in_PointerTosrm2__ArrayOfTSURLReturnStatus(soap, NULL, NULL, "srm2:ArrayOfTSURLReturnStatus");
	case SOAP_TYPE_PointerTosrm2__ArrayOfAnyURI:
		return soap_in_PointerTosrm2__ArrayOfAnyURI(soap, NULL, NULL, "srm2:ArrayOfAnyURI");
	case SOAP_TYPE_PointerTosrm2__ArrayOfTMetaDataSpace:
		return soap_in_PointerTosrm2__ArrayOfTMetaDataSpace(soap, NULL, NULL, "srm2:ArrayOfTMetaDataSpace");
	case SOAP_TYPE_PointerTosrm2__TTransferParameters:
		return soap_in_PointerTosrm2__TTransferParameters(soap, NULL, NULL, "srm2:TTransferParameters");
	case SOAP_TYPE_PointerTosrm2__ArrayOfUnsignedLong:
		return soap_in_PointerTosrm2__ArrayOfUnsignedLong(soap, NULL, NULL, "srm2:ArrayOfUnsignedLong");
	case SOAP_TYPE_PointerToPointerTosrm2__TSupportedTransferProtocol:
		return soap_in_PointerToPointerTosrm2__TSupportedTransferProtocol(soap, NULL, NULL, "srm2:TSupportedTransferProtocol");
	case SOAP_TYPE_PointerTosrm2__TSupportedTransferProtocol:
		return soap_in_PointerTosrm2__TSupportedTransferProtocol(soap, NULL, NULL, "srm2:TSupportedTransferProtocol");
	case SOAP_TYPE_PointerToPointerTosrm2__TRequestTokenReturn:
		return soap_in_PointerToPointerTosrm2__TRequestTokenReturn(soap, NULL, NULL, "srm2:TRequestTokenReturn");
	case SOAP_TYPE_PointerTosrm2__TRequestTokenReturn:
		return soap_in_PointerTosrm2__TRequestTokenReturn(soap, NULL, NULL, "srm2:TRequestTokenReturn");
	case SOAP_TYPE_PointerToPointerTosrm2__TPermissionReturn:
		return soap_in_PointerToPointerTosrm2__TPermissionReturn(soap, NULL, NULL, "srm2:TPermissionReturn");
	case SOAP_TYPE_PointerTosrm2__TPermissionReturn:
		return soap_in_PointerTosrm2__TPermissionReturn(soap, NULL, NULL, "srm2:TPermissionReturn");
	case SOAP_TYPE_PointerTosrm2__ArrayOfTGroupPermission:
		return soap_in_PointerTosrm2__ArrayOfTGroupPermission(soap, NULL, NULL, "srm2:ArrayOfTGroupPermission");
	case SOAP_TYPE_PointerTosrm2__ArrayOfTUserPermission:
		return soap_in_PointerTosrm2__ArrayOfTUserPermission(soap, NULL, NULL, "srm2:ArrayOfTUserPermission");
	case SOAP_TYPE_PointerToPointerTosrm2__TSURLPermissionReturn:
		return soap_in_PointerToPointerTosrm2__TSURLPermissionReturn(soap, NULL, NULL, "srm2:TSURLPermissionReturn");
	case SOAP_TYPE_PointerTosrm2__TSURLPermissionReturn:
		return soap_in_PointerTosrm2__TSURLPermissionReturn(soap, NULL, NULL, "srm2:TSURLPermissionReturn");
	case SOAP_TYPE_PointerToPointerTosrm2__TRequestSummary:
		return soap_in_PointerToPointerTosrm2__TRequestSummary(soap, NULL, NULL, "srm2:TRequestSummary");
	case SOAP_TYPE_PointerTosrm2__TRequestSummary:
		return soap_in_PointerTosrm2__TRequestSummary(soap, NULL, NULL, "srm2:TRequestSummary");
	case SOAP_TYPE_PointerTosrm2__TRequestType:
		return soap_in_PointerTosrm2__TRequestType(soap, NULL, NULL, "srm2:TRequestType");
	case SOAP_TYPE_PointerToPointerTosrm2__TCopyRequestFileStatus:
		return soap_in_PointerToPointerTosrm2__TCopyRequestFileStatus(soap, NULL, NULL, "srm2:TCopyRequestFileStatus");
	case SOAP_TYPE_PointerTosrm2__TCopyRequestFileStatus:
		return soap_in_PointerTosrm2__TCopyRequestFileStatus(soap, NULL, NULL, "srm2:TCopyRequestFileStatus");
	case SOAP_TYPE_PointerToPointerTosrm2__TPutRequestFileStatus:
		return soap_in_PointerToPointerTosrm2__TPutRequestFileStatus(soap, NULL, NULL, "srm2:TPutRequestFileStatus");
	case SOAP_TYPE_PointerTosrm2__TPutRequestFileStatus:
		return soap_in_PointerTosrm2__TPutRequestFileStatus(soap, NULL, NULL, "srm2:TPutRequestFileStatus");
	case SOAP_TYPE_PointerToPointerTosrm2__TBringOnlineRequestFileStatus:
		return soap_in_PointerToPointerTosrm2__TBringOnlineRequestFileStatus(soap, NULL, NULL, "srm2:TBringOnlineRequestFileStatus");
	case SOAP_TYPE_PointerTosrm2__TBringOnlineRequestFileStatus:
		return soap_in_PointerTosrm2__TBringOnlineRequestFileStatus(soap, NULL, NULL, "srm2:TBringOnlineRequestFileStatus");
	case SOAP_TYPE_PointerToPointerTosrm2__TGetRequestFileStatus:
		return soap_in_PointerToPointerTosrm2__TGetRequestFileStatus(soap, NULL, NULL, "srm2:TGetRequestFileStatus");
	case SOAP_TYPE_PointerTosrm2__TGetRequestFileStatus:
		return soap_in_PointerTosrm2__TGetRequestFileStatus(soap, NULL, NULL, "srm2:TGetRequestFileStatus");
	case SOAP_TYPE_PointerTosrm2__ArrayOfTExtraInfo:
		return soap_in_PointerTosrm2__ArrayOfTExtraInfo(soap, NULL, NULL, "srm2:ArrayOfTExtraInfo");
	case SOAP_TYPE_PointerToPointerTosrm2__TCopyFileRequest:
		return soap_in_PointerToPointerTosrm2__TCopyFileRequest(soap, NULL, NULL, "srm2:TCopyFileRequest");
	case SOAP_TYPE_PointerTosrm2__TCopyFileRequest:
		return soap_in_PointerTosrm2__TCopyFileRequest(soap, NULL, NULL, "srm2:TCopyFileRequest");
	case SOAP_TYPE_PointerToPointerTosrm2__TPutFileRequest:
		return soap_in_PointerToPointerTosrm2__TPutFileRequest(soap, NULL, NULL, "srm2:TPutFileRequest");
	case SOAP_TYPE_PointerTosrm2__TPutFileRequest:
		return soap_in_PointerTosrm2__TPutFileRequest(soap, NULL, NULL, "srm2:TPutFileRequest");
	case SOAP_TYPE_PointerToPointerTosrm2__TGetFileRequest:
		return soap_in_PointerToPointerTosrm2__TGetFileRequest(soap, NULL, NULL, "srm2:TGetFileRequest");
	case SOAP_TYPE_PointerTosrm2__TGetFileRequest:
		return soap_in_PointerTosrm2__TGetFileRequest(soap, NULL, NULL, "srm2:TGetFileRequest");
	case SOAP_TYPE_PointerTosrm2__TDirOption:
		return soap_in_PointerTosrm2__TDirOption(soap, NULL, NULL, "srm2:TDirOption");
	case SOAP_TYPE_PointerTosrm2__TConnectionType:
		return soap_in_PointerTosrm2__TConnectionType(soap, NULL, NULL, "srm2:TConnectionType");
	case SOAP_TYPE_PointerTosrm2__TAccessPattern:
		return soap_in_PointerTosrm2__TAccessPattern(soap, NULL, NULL, "srm2:TAccessPattern");
	case SOAP_TYPE_PointerToxsd__anyURI:
		return soap_in_PointerToxsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_PointerToPointerTosrm2__TExtraInfo:
		return soap_in_PointerToPointerTosrm2__TExtraInfo(soap, NULL, NULL, "srm2:TExtraInfo");
	case SOAP_TYPE_PointerTosrm2__TExtraInfo:
		return soap_in_PointerTosrm2__TExtraInfo(soap, NULL, NULL, "srm2:TExtraInfo");
	case SOAP_TYPE_PointerToxsd__boolean:
		return soap_in_PointerToxsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerToPointerTosrm2__TMetaDataSpace:
		return soap_in_PointerToPointerTosrm2__TMetaDataSpace(soap, NULL, NULL, "srm2:TMetaDataSpace");
	case SOAP_TYPE_PointerTosrm2__TMetaDataSpace:
		return soap_in_PointerTosrm2__TMetaDataSpace(soap, NULL, NULL, "srm2:TMetaDataSpace");
	case SOAP_TYPE_PointerToPointerTosrm2__TMetaDataPathDetail:
		return soap_in_PointerToPointerTosrm2__TMetaDataPathDetail(soap, NULL, NULL, "srm2:TMetaDataPathDetail");
	case SOAP_TYPE_PointerTosrm2__TMetaDataPathDetail:
		return soap_in_PointerTosrm2__TMetaDataPathDetail(soap, NULL, NULL, "srm2:TMetaDataPathDetail");
	case SOAP_TYPE_PointerTosrm2__ArrayOfTMetaDataPathDetail:
		return soap_in_PointerTosrm2__ArrayOfTMetaDataPathDetail(soap, NULL, NULL, "srm2:ArrayOfTMetaDataPathDetail");
	case SOAP_TYPE_PointerTosrm2__TPermissionMode:
		return soap_in_PointerTosrm2__TPermissionMode(soap, NULL, NULL, "srm2:TPermissionMode");
	case SOAP_TYPE_PointerTosrm2__TFileType:
		return soap_in_PointerTosrm2__TFileType(soap, NULL, NULL, "srm2:TFileType");
	case SOAP_TYPE_PointerTosrm2__ArrayOfString:
		return soap_in_PointerTosrm2__ArrayOfString(soap, NULL, NULL, "srm2:ArrayOfString");
	case SOAP_TYPE_PointerTosrm2__TFileLocality:
		return soap_in_PointerTosrm2__TFileLocality(soap, NULL, NULL, "srm2:TFileLocality");
	case SOAP_TYPE_PointerTosrm2__TRetentionPolicyInfo:
		return soap_in_PointerTosrm2__TRetentionPolicyInfo(soap, NULL, NULL, "srm2:TRetentionPolicyInfo");
	case SOAP_TYPE_PointerTosrm2__TFileStorageType:
		return soap_in_PointerTosrm2__TFileStorageType(soap, NULL, NULL, "srm2:TFileStorageType");
	case SOAP_TYPE_PointerToPointerTosrm2__TSURLLifetimeReturnStatus:
		return soap_in_PointerToPointerTosrm2__TSURLLifetimeReturnStatus(soap, NULL, NULL, "srm2:TSURLLifetimeReturnStatus");
	case SOAP_TYPE_PointerTosrm2__TSURLLifetimeReturnStatus:
		return soap_in_PointerTosrm2__TSURLLifetimeReturnStatus(soap, NULL, NULL, "srm2:TSURLLifetimeReturnStatus");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerToPointerTosrm2__TSURLReturnStatus:
		return soap_in_PointerToPointerTosrm2__TSURLReturnStatus(soap, NULL, NULL, "srm2:TSURLReturnStatus");
	case SOAP_TYPE_PointerTosrm2__TSURLReturnStatus:
		return soap_in_PointerTosrm2__TSURLReturnStatus(soap, NULL, NULL, "srm2:TSURLReturnStatus");
	case SOAP_TYPE_PointerTosrm2__TReturnStatus:
		return soap_in_PointerTosrm2__TReturnStatus(soap, NULL, NULL, "srm2:TReturnStatus");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTounsignedLONG64:
		return soap_in_PointerTounsignedLONG64(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_PointerToPointerTosrm2__TGroupPermission:
		return soap_in_PointerToPointerTosrm2__TGroupPermission(soap, NULL, NULL, "srm2:TGroupPermission");
	case SOAP_TYPE_PointerTosrm2__TGroupPermission:
		return soap_in_PointerTosrm2__TGroupPermission(soap, NULL, NULL, "srm2:TGroupPermission");
	case SOAP_TYPE_PointerToPointerTosrm2__TUserPermission:
		return soap_in_PointerToPointerTosrm2__TUserPermission(soap, NULL, NULL, "srm2:TUserPermission");
	case SOAP_TYPE_PointerTosrm2__TUserPermission:
		return soap_in_PointerTosrm2__TUserPermission(soap, NULL, NULL, "srm2:TUserPermission");
	case SOAP_TYPE_PointerTosrm2__TAccessLatency:
		return soap_in_PointerTosrm2__TAccessLatency(soap, NULL, NULL, "srm2:TAccessLatency");
	case SOAP_TYPE_xsd__anyURI:
	{	char **s;
		s = soap_in_xsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
		return s ? *s : NULL;
	}
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_unsignedLONG64;
			return soap_in_unsignedLONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:TStatusCode"))
		{	*type = SOAP_TYPE_srm2__TStatusCode;
			return soap_in_srm2__TStatusCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:TConnectionType"))
		{	*type = SOAP_TYPE_srm2__TConnectionType;
			return soap_in_srm2__TConnectionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:TAccessPattern"))
		{	*type = SOAP_TYPE_srm2__TAccessPattern;
			return soap_in_srm2__TAccessPattern(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:TFileLocality"))
		{	*type = SOAP_TYPE_srm2__TFileLocality;
			return soap_in_srm2__TFileLocality(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:TOverwriteMode"))
		{	*type = SOAP_TYPE_srm2__TOverwriteMode;
			return soap_in_srm2__TOverwriteMode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:TRequestType"))
		{	*type = SOAP_TYPE_srm2__TRequestType;
			return soap_in_srm2__TRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:TPermissionType"))
		{	*type = SOAP_TYPE_srm2__TPermissionType;
			return soap_in_srm2__TPermissionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:TPermissionMode"))
		{	*type = SOAP_TYPE_srm2__TPermissionMode;
			return soap_in_srm2__TPermissionMode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:TAccessLatency"))
		{	*type = SOAP_TYPE_srm2__TAccessLatency;
			return soap_in_srm2__TAccessLatency(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:TRetentionPolicy"))
		{	*type = SOAP_TYPE_srm2__TRetentionPolicy;
			return soap_in_srm2__TRetentionPolicy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:TFileType"))
		{	*type = SOAP_TYPE_srm2__TFileType;
			return soap_in_srm2__TFileType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:TFileStorageType"))
		{	*type = SOAP_TYPE_srm2__TFileStorageType;
			return soap_in_srm2__TFileStorageType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean;
			return soap_in_xsd__boolean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "SOAP-ENV:Reason"))
		{	*type = SOAP_TYPE_SOAP_ENV__Reason;
			return soap_in_SOAP_ENV__Reason(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmPing"))
		{	*type = SOAP_TYPE_srm2__srmPing;
			return soap_in_srm2__srmPing(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmPingResponse"))
		{	*type = SOAP_TYPE_srm2__srmPingResponse_;
			return soap_in_srm2__srmPingResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmGetTransferProtocols"))
		{	*type = SOAP_TYPE_srm2__srmGetTransferProtocols;
			return soap_in_srm2__srmGetTransferProtocols(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmGetTransferProtocolsResponse"))
		{	*type = SOAP_TYPE_srm2__srmGetTransferProtocolsResponse_;
			return soap_in_srm2__srmGetTransferProtocolsResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmGetRequestTokens"))
		{	*type = SOAP_TYPE_srm2__srmGetRequestTokens;
			return soap_in_srm2__srmGetRequestTokens(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmGetRequestTokensResponse"))
		{	*type = SOAP_TYPE_srm2__srmGetRequestTokensResponse_;
			return soap_in_srm2__srmGetRequestTokensResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmExtendFileLifeTime"))
		{	*type = SOAP_TYPE_srm2__srmExtendFileLifeTime;
			return soap_in_srm2__srmExtendFileLifeTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmExtendFileLifeTimeResponse"))
		{	*type = SOAP_TYPE_srm2__srmExtendFileLifeTimeResponse_;
			return soap_in_srm2__srmExtendFileLifeTimeResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmGetRequestSummary"))
		{	*type = SOAP_TYPE_srm2__srmGetRequestSummary;
			return soap_in_srm2__srmGetRequestSummary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmGetRequestSummaryResponse"))
		{	*type = SOAP_TYPE_srm2__srmGetRequestSummaryResponse_;
			return soap_in_srm2__srmGetRequestSummaryResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmResumeRequest"))
		{	*type = SOAP_TYPE_srm2__srmResumeRequest;
			return soap_in_srm2__srmResumeRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmResumeRequestResponse"))
		{	*type = SOAP_TYPE_srm2__srmResumeRequestResponse_;
			return soap_in_srm2__srmResumeRequestResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmSuspendRequest"))
		{	*type = SOAP_TYPE_srm2__srmSuspendRequest;
			return soap_in_srm2__srmSuspendRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmSuspendRequestResponse"))
		{	*type = SOAP_TYPE_srm2__srmSuspendRequestResponse_;
			return soap_in_srm2__srmSuspendRequestResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmAbortFiles"))
		{	*type = SOAP_TYPE_srm2__srmAbortFiles;
			return soap_in_srm2__srmAbortFiles(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmAbortFilesResponse"))
		{	*type = SOAP_TYPE_srm2__srmAbortFilesResponse_;
			return soap_in_srm2__srmAbortFilesResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmAbortRequest"))
		{	*type = SOAP_TYPE_srm2__srmAbortRequest;
			return soap_in_srm2__srmAbortRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmAbortRequestResponse"))
		{	*type = SOAP_TYPE_srm2__srmAbortRequestResponse_;
			return soap_in_srm2__srmAbortRequestResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmPutDone"))
		{	*type = SOAP_TYPE_srm2__srmPutDone;
			return soap_in_srm2__srmPutDone(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmPutDoneResponse"))
		{	*type = SOAP_TYPE_srm2__srmPutDoneResponse_;
			return soap_in_srm2__srmPutDoneResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmReleaseFiles"))
		{	*type = SOAP_TYPE_srm2__srmReleaseFiles;
			return soap_in_srm2__srmReleaseFiles(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmReleaseFilesResponse"))
		{	*type = SOAP_TYPE_srm2__srmReleaseFilesResponse_;
			return soap_in_srm2__srmReleaseFilesResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmStatusOfCopyRequest"))
		{	*type = SOAP_TYPE_srm2__srmStatusOfCopyRequest;
			return soap_in_srm2__srmStatusOfCopyRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmStatusOfCopyRequestResponse"))
		{	*type = SOAP_TYPE_srm2__srmStatusOfCopyRequestResponse_;
			return soap_in_srm2__srmStatusOfCopyRequestResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmCopy"))
		{	*type = SOAP_TYPE_srm2__srmCopy;
			return soap_in_srm2__srmCopy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmCopyResponse"))
		{	*type = SOAP_TYPE_srm2__srmCopyResponse_;
			return soap_in_srm2__srmCopyResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmStatusOfPutRequest"))
		{	*type = SOAP_TYPE_srm2__srmStatusOfPutRequest;
			return soap_in_srm2__srmStatusOfPutRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmStatusOfPutRequestResponse"))
		{	*type = SOAP_TYPE_srm2__srmStatusOfPutRequestResponse_;
			return soap_in_srm2__srmStatusOfPutRequestResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmPrepareToPut"))
		{	*type = SOAP_TYPE_srm2__srmPrepareToPut;
			return soap_in_srm2__srmPrepareToPut(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmPrepareToPutResponse"))
		{	*type = SOAP_TYPE_srm2__srmPrepareToPutResponse_;
			return soap_in_srm2__srmPrepareToPutResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmStatusOfBringOnlineRequest"))
		{	*type = SOAP_TYPE_srm2__srmStatusOfBringOnlineRequest;
			return soap_in_srm2__srmStatusOfBringOnlineRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmStatusOfBringOnlineRequestResponse"))
		{	*type = SOAP_TYPE_srm2__srmStatusOfBringOnlineRequestResponse_;
			return soap_in_srm2__srmStatusOfBringOnlineRequestResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmBringOnline"))
		{	*type = SOAP_TYPE_srm2__srmBringOnline;
			return soap_in_srm2__srmBringOnline(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmBringOnlineResponse"))
		{	*type = SOAP_TYPE_srm2__srmBringOnlineResponse_;
			return soap_in_srm2__srmBringOnlineResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmStatusOfGetRequest"))
		{	*type = SOAP_TYPE_srm2__srmStatusOfGetRequest;
			return soap_in_srm2__srmStatusOfGetRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmStatusOfGetRequestResponse"))
		{	*type = SOAP_TYPE_srm2__srmStatusOfGetRequestResponse_;
			return soap_in_srm2__srmStatusOfGetRequestResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmPrepareToGet"))
		{	*type = SOAP_TYPE_srm2__srmPrepareToGet;
			return soap_in_srm2__srmPrepareToGet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmPrepareToGetResponse"))
		{	*type = SOAP_TYPE_srm2__srmPrepareToGetResponse_;
			return soap_in_srm2__srmPrepareToGetResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmMv"))
		{	*type = SOAP_TYPE_srm2__srmMv;
			return soap_in_srm2__srmMv(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmMvResponse"))
		{	*type = SOAP_TYPE_srm2__srmMvResponse_;
			return soap_in_srm2__srmMvResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmStatusOfLsRequest"))
		{	*type = SOAP_TYPE_srm2__srmStatusOfLsRequest;
			return soap_in_srm2__srmStatusOfLsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmStatusOfLsRequestResponse"))
		{	*type = SOAP_TYPE_srm2__srmStatusOfLsRequestResponse_;
			return soap_in_srm2__srmStatusOfLsRequestResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmLs"))
		{	*type = SOAP_TYPE_srm2__srmLs;
			return soap_in_srm2__srmLs(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmLsResponse"))
		{	*type = SOAP_TYPE_srm2__srmLsResponse_;
			return soap_in_srm2__srmLsResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmRm"))
		{	*type = SOAP_TYPE_srm2__srmRm;
			return soap_in_srm2__srmRm(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmRmResponse"))
		{	*type = SOAP_TYPE_srm2__srmRmResponse_;
			return soap_in_srm2__srmRmResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmRmdir"))
		{	*type = SOAP_TYPE_srm2__srmRmdir;
			return soap_in_srm2__srmRmdir(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmRmdirResponse"))
		{	*type = SOAP_TYPE_srm2__srmRmdirResponse_;
			return soap_in_srm2__srmRmdirResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmMkdir"))
		{	*type = SOAP_TYPE_srm2__srmMkdir;
			return soap_in_srm2__srmMkdir(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmMkdirResponse"))
		{	*type = SOAP_TYPE_srm2__srmMkdirResponse_;
			return soap_in_srm2__srmMkdirResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmGetPermission"))
		{	*type = SOAP_TYPE_srm2__srmGetPermission;
			return soap_in_srm2__srmGetPermission(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmGetPermissionResponse"))
		{	*type = SOAP_TYPE_srm2__srmGetPermissionResponse_;
			return soap_in_srm2__srmGetPermissionResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmCheckPermission"))
		{	*type = SOAP_TYPE_srm2__srmCheckPermission;
			return soap_in_srm2__srmCheckPermission(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmCheckPermissionResponse"))
		{	*type = SOAP_TYPE_srm2__srmCheckPermissionResponse_;
			return soap_in_srm2__srmCheckPermissionResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmSetPermission"))
		{	*type = SOAP_TYPE_srm2__srmSetPermission;
			return soap_in_srm2__srmSetPermission(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmSetPermissionResponse"))
		{	*type = SOAP_TYPE_srm2__srmSetPermissionResponse_;
			return soap_in_srm2__srmSetPermissionResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmGetSpaceTokens"))
		{	*type = SOAP_TYPE_srm2__srmGetSpaceTokens;
			return soap_in_srm2__srmGetSpaceTokens(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmGetSpaceTokensResponse"))
		{	*type = SOAP_TYPE_srm2__srmGetSpaceTokensResponse_;
			return soap_in_srm2__srmGetSpaceTokensResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmPurgeFromSpace"))
		{	*type = SOAP_TYPE_srm2__srmPurgeFromSpace;
			return soap_in_srm2__srmPurgeFromSpace(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmPurgeFromSpaceResponse"))
		{	*type = SOAP_TYPE_srm2__srmPurgeFromSpaceResponse_;
			return soap_in_srm2__srmPurgeFromSpaceResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmExtendFileLifeTimeInSpace"))
		{	*type = SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpace;
			return soap_in_srm2__srmExtendFileLifeTimeInSpace(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmExtendFileLifeTimeInSpaceResponse"))
		{	*type = SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpaceResponse_;
			return soap_in_srm2__srmExtendFileLifeTimeInSpaceResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmStatusOfChangeSpaceForFilesRequest"))
		{	*type = SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequest;
			return soap_in_srm2__srmStatusOfChangeSpaceForFilesRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmStatusOfChangeSpaceForFilesRequestResponse"))
		{	*type = SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequestResponse_;
			return soap_in_srm2__srmStatusOfChangeSpaceForFilesRequestResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmChangeSpaceForFiles"))
		{	*type = SOAP_TYPE_srm2__srmChangeSpaceForFiles;
			return soap_in_srm2__srmChangeSpaceForFiles(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmChangeSpaceForFilesResponse"))
		{	*type = SOAP_TYPE_srm2__srmChangeSpaceForFilesResponse_;
			return soap_in_srm2__srmChangeSpaceForFilesResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmGetSpaceMetaData"))
		{	*type = SOAP_TYPE_srm2__srmGetSpaceMetaData;
			return soap_in_srm2__srmGetSpaceMetaData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmGetSpaceMetaDataResponse"))
		{	*type = SOAP_TYPE_srm2__srmGetSpaceMetaDataResponse_;
			return soap_in_srm2__srmGetSpaceMetaDataResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmStatusOfUpdateSpaceRequest"))
		{	*type = SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequest;
			return soap_in_srm2__srmStatusOfUpdateSpaceRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmStatusOfUpdateSpaceRequestResponse"))
		{	*type = SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequestResponse_;
			return soap_in_srm2__srmStatusOfUpdateSpaceRequestResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmUpdateSpace"))
		{	*type = SOAP_TYPE_srm2__srmUpdateSpace;
			return soap_in_srm2__srmUpdateSpace(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmUpdateSpaceResponse"))
		{	*type = SOAP_TYPE_srm2__srmUpdateSpaceResponse_;
			return soap_in_srm2__srmUpdateSpaceResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmReleaseSpace"))
		{	*type = SOAP_TYPE_srm2__srmReleaseSpace;
			return soap_in_srm2__srmReleaseSpace(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmReleaseSpaceResponse"))
		{	*type = SOAP_TYPE_srm2__srmReleaseSpaceResponse_;
			return soap_in_srm2__srmReleaseSpaceResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmStatusOfReserveSpaceRequest"))
		{	*type = SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequest;
			return soap_in_srm2__srmStatusOfReserveSpaceRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmStatusOfReserveSpaceRequestResponse"))
		{	*type = SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequestResponse_;
			return soap_in_srm2__srmStatusOfReserveSpaceRequestResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmReserveSpace"))
		{	*type = SOAP_TYPE_srm2__srmReserveSpace;
			return soap_in_srm2__srmReserveSpace(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmReserveSpaceResponse"))
		{	*type = SOAP_TYPE_srm2__srmReserveSpaceResponse_;
			return soap_in_srm2__srmReserveSpaceResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmPingResponse"))
		{	*type = SOAP_TYPE_srm2__srmPingResponse;
			return soap_in_srm2__srmPingResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmPingRequest"))
		{	*type = SOAP_TYPE_srm2__srmPingRequest;
			return soap_in_srm2__srmPingRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmGetTransferProtocolsResponse"))
		{	*type = SOAP_TYPE_srm2__srmGetTransferProtocolsResponse;
			return soap_in_srm2__srmGetTransferProtocolsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmGetTransferProtocolsRequest"))
		{	*type = SOAP_TYPE_srm2__srmGetTransferProtocolsRequest;
			return soap_in_srm2__srmGetTransferProtocolsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmGetRequestTokensResponse"))
		{	*type = SOAP_TYPE_srm2__srmGetRequestTokensResponse;
			return soap_in_srm2__srmGetRequestTokensResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmGetRequestTokensRequest"))
		{	*type = SOAP_TYPE_srm2__srmGetRequestTokensRequest;
			return soap_in_srm2__srmGetRequestTokensRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmExtendFileLifeTimeResponse"))
		{	*type = SOAP_TYPE_srm2__srmExtendFileLifeTimeResponse;
			return soap_in_srm2__srmExtendFileLifeTimeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmExtendFileLifeTimeRequest"))
		{	*type = SOAP_TYPE_srm2__srmExtendFileLifeTimeRequest;
			return soap_in_srm2__srmExtendFileLifeTimeRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmGetRequestSummaryResponse"))
		{	*type = SOAP_TYPE_srm2__srmGetRequestSummaryResponse;
			return soap_in_srm2__srmGetRequestSummaryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmGetRequestSummaryRequest"))
		{	*type = SOAP_TYPE_srm2__srmGetRequestSummaryRequest;
			return soap_in_srm2__srmGetRequestSummaryRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmResumeRequestResponse"))
		{	*type = SOAP_TYPE_srm2__srmResumeRequestResponse;
			return soap_in_srm2__srmResumeRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmResumeRequestRequest"))
		{	*type = SOAP_TYPE_srm2__srmResumeRequestRequest;
			return soap_in_srm2__srmResumeRequestRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmSuspendRequestResponse"))
		{	*type = SOAP_TYPE_srm2__srmSuspendRequestResponse;
			return soap_in_srm2__srmSuspendRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmSuspendRequestRequest"))
		{	*type = SOAP_TYPE_srm2__srmSuspendRequestRequest;
			return soap_in_srm2__srmSuspendRequestRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmAbortFilesResponse"))
		{	*type = SOAP_TYPE_srm2__srmAbortFilesResponse;
			return soap_in_srm2__srmAbortFilesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmAbortFilesRequest"))
		{	*type = SOAP_TYPE_srm2__srmAbortFilesRequest;
			return soap_in_srm2__srmAbortFilesRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmAbortRequestResponse"))
		{	*type = SOAP_TYPE_srm2__srmAbortRequestResponse;
			return soap_in_srm2__srmAbortRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmAbortRequestRequest"))
		{	*type = SOAP_TYPE_srm2__srmAbortRequestRequest;
			return soap_in_srm2__srmAbortRequestRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmPutDoneResponse"))
		{	*type = SOAP_TYPE_srm2__srmPutDoneResponse;
			return soap_in_srm2__srmPutDoneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmPutDoneRequest"))
		{	*type = SOAP_TYPE_srm2__srmPutDoneRequest;
			return soap_in_srm2__srmPutDoneRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmReleaseFilesResponse"))
		{	*type = SOAP_TYPE_srm2__srmReleaseFilesResponse;
			return soap_in_srm2__srmReleaseFilesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmReleaseFilesRequest"))
		{	*type = SOAP_TYPE_srm2__srmReleaseFilesRequest;
			return soap_in_srm2__srmReleaseFilesRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmStatusOfCopyRequestResponse"))
		{	*type = SOAP_TYPE_srm2__srmStatusOfCopyRequestResponse;
			return soap_in_srm2__srmStatusOfCopyRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmStatusOfCopyRequestRequest"))
		{	*type = SOAP_TYPE_srm2__srmStatusOfCopyRequestRequest;
			return soap_in_srm2__srmStatusOfCopyRequestRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmCopyResponse"))
		{	*type = SOAP_TYPE_srm2__srmCopyResponse;
			return soap_in_srm2__srmCopyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmCopyRequest"))
		{	*type = SOAP_TYPE_srm2__srmCopyRequest;
			return soap_in_srm2__srmCopyRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmStatusOfPutRequestResponse"))
		{	*type = SOAP_TYPE_srm2__srmStatusOfPutRequestResponse;
			return soap_in_srm2__srmStatusOfPutRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmStatusOfPutRequestRequest"))
		{	*type = SOAP_TYPE_srm2__srmStatusOfPutRequestRequest;
			return soap_in_srm2__srmStatusOfPutRequestRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmPrepareToPutResponse"))
		{	*type = SOAP_TYPE_srm2__srmPrepareToPutResponse;
			return soap_in_srm2__srmPrepareToPutResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmPrepareToPutRequest"))
		{	*type = SOAP_TYPE_srm2__srmPrepareToPutRequest;
			return soap_in_srm2__srmPrepareToPutRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmStatusOfBringOnlineRequestResponse"))
		{	*type = SOAP_TYPE_srm2__srmStatusOfBringOnlineRequestResponse;
			return soap_in_srm2__srmStatusOfBringOnlineRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmStatusOfBringOnlineRequestRequest"))
		{	*type = SOAP_TYPE_srm2__srmStatusOfBringOnlineRequestRequest;
			return soap_in_srm2__srmStatusOfBringOnlineRequestRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmBringOnlineResponse"))
		{	*type = SOAP_TYPE_srm2__srmBringOnlineResponse;
			return soap_in_srm2__srmBringOnlineResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmBringOnlineRequest"))
		{	*type = SOAP_TYPE_srm2__srmBringOnlineRequest;
			return soap_in_srm2__srmBringOnlineRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmStatusOfGetRequestResponse"))
		{	*type = SOAP_TYPE_srm2__srmStatusOfGetRequestResponse;
			return soap_in_srm2__srmStatusOfGetRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmStatusOfGetRequestRequest"))
		{	*type = SOAP_TYPE_srm2__srmStatusOfGetRequestRequest;
			return soap_in_srm2__srmStatusOfGetRequestRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmPrepareToGetResponse"))
		{	*type = SOAP_TYPE_srm2__srmPrepareToGetResponse;
			return soap_in_srm2__srmPrepareToGetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmPrepareToGetRequest"))
		{	*type = SOAP_TYPE_srm2__srmPrepareToGetRequest;
			return soap_in_srm2__srmPrepareToGetRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmMvResponse"))
		{	*type = SOAP_TYPE_srm2__srmMvResponse;
			return soap_in_srm2__srmMvResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmMvRequest"))
		{	*type = SOAP_TYPE_srm2__srmMvRequest;
			return soap_in_srm2__srmMvRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmStatusOfLsRequestResponse"))
		{	*type = SOAP_TYPE_srm2__srmStatusOfLsRequestResponse;
			return soap_in_srm2__srmStatusOfLsRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmStatusOfLsRequestRequest"))
		{	*type = SOAP_TYPE_srm2__srmStatusOfLsRequestRequest;
			return soap_in_srm2__srmStatusOfLsRequestRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmLsResponse"))
		{	*type = SOAP_TYPE_srm2__srmLsResponse;
			return soap_in_srm2__srmLsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmLsRequest"))
		{	*type = SOAP_TYPE_srm2__srmLsRequest;
			return soap_in_srm2__srmLsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmRmResponse"))
		{	*type = SOAP_TYPE_srm2__srmRmResponse;
			return soap_in_srm2__srmRmResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmRmRequest"))
		{	*type = SOAP_TYPE_srm2__srmRmRequest;
			return soap_in_srm2__srmRmRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmRmdirResponse"))
		{	*type = SOAP_TYPE_srm2__srmRmdirResponse;
			return soap_in_srm2__srmRmdirResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmRmdirRequest"))
		{	*type = SOAP_TYPE_srm2__srmRmdirRequest;
			return soap_in_srm2__srmRmdirRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmMkdirResponse"))
		{	*type = SOAP_TYPE_srm2__srmMkdirResponse;
			return soap_in_srm2__srmMkdirResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmMkdirRequest"))
		{	*type = SOAP_TYPE_srm2__srmMkdirRequest;
			return soap_in_srm2__srmMkdirRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmGetPermissionResponse"))
		{	*type = SOAP_TYPE_srm2__srmGetPermissionResponse;
			return soap_in_srm2__srmGetPermissionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmGetPermissionRequest"))
		{	*type = SOAP_TYPE_srm2__srmGetPermissionRequest;
			return soap_in_srm2__srmGetPermissionRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmCheckPermissionResponse"))
		{	*type = SOAP_TYPE_srm2__srmCheckPermissionResponse;
			return soap_in_srm2__srmCheckPermissionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmCheckPermissionRequest"))
		{	*type = SOAP_TYPE_srm2__srmCheckPermissionRequest;
			return soap_in_srm2__srmCheckPermissionRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmSetPermissionResponse"))
		{	*type = SOAP_TYPE_srm2__srmSetPermissionResponse;
			return soap_in_srm2__srmSetPermissionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmSetPermissionRequest"))
		{	*type = SOAP_TYPE_srm2__srmSetPermissionRequest;
			return soap_in_srm2__srmSetPermissionRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmGetSpaceTokensResponse"))
		{	*type = SOAP_TYPE_srm2__srmGetSpaceTokensResponse;
			return soap_in_srm2__srmGetSpaceTokensResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmGetSpaceTokensRequest"))
		{	*type = SOAP_TYPE_srm2__srmGetSpaceTokensRequest;
			return soap_in_srm2__srmGetSpaceTokensRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmPurgeFromSpaceResponse"))
		{	*type = SOAP_TYPE_srm2__srmPurgeFromSpaceResponse;
			return soap_in_srm2__srmPurgeFromSpaceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmPurgeFromSpaceRequest"))
		{	*type = SOAP_TYPE_srm2__srmPurgeFromSpaceRequest;
			return soap_in_srm2__srmPurgeFromSpaceRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmExtendFileLifeTimeInSpaceResponse"))
		{	*type = SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpaceResponse;
			return soap_in_srm2__srmExtendFileLifeTimeInSpaceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmExtendFileLifeTimeInSpaceRequest"))
		{	*type = SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpaceRequest;
			return soap_in_srm2__srmExtendFileLifeTimeInSpaceRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmStatusOfChangeSpaceForFilesRequestResponse"))
		{	*type = SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequestResponse;
			return soap_in_srm2__srmStatusOfChangeSpaceForFilesRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmStatusOfChangeSpaceForFilesRequestRequest"))
		{	*type = SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequestRequest;
			return soap_in_srm2__srmStatusOfChangeSpaceForFilesRequestRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmChangeSpaceForFilesResponse"))
		{	*type = SOAP_TYPE_srm2__srmChangeSpaceForFilesResponse;
			return soap_in_srm2__srmChangeSpaceForFilesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmChangeSpaceForFilesRequest"))
		{	*type = SOAP_TYPE_srm2__srmChangeSpaceForFilesRequest;
			return soap_in_srm2__srmChangeSpaceForFilesRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmGetSpaceMetaDataResponse"))
		{	*type = SOAP_TYPE_srm2__srmGetSpaceMetaDataResponse;
			return soap_in_srm2__srmGetSpaceMetaDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmGetSpaceMetaDataRequest"))
		{	*type = SOAP_TYPE_srm2__srmGetSpaceMetaDataRequest;
			return soap_in_srm2__srmGetSpaceMetaDataRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmStatusOfUpdateSpaceRequestResponse"))
		{	*type = SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequestResponse;
			return soap_in_srm2__srmStatusOfUpdateSpaceRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmStatusOfUpdateSpaceRequestRequest"))
		{	*type = SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequestRequest;
			return soap_in_srm2__srmStatusOfUpdateSpaceRequestRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmUpdateSpaceResponse"))
		{	*type = SOAP_TYPE_srm2__srmUpdateSpaceResponse;
			return soap_in_srm2__srmUpdateSpaceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmUpdateSpaceRequest"))
		{	*type = SOAP_TYPE_srm2__srmUpdateSpaceRequest;
			return soap_in_srm2__srmUpdateSpaceRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmReleaseSpaceResponse"))
		{	*type = SOAP_TYPE_srm2__srmReleaseSpaceResponse;
			return soap_in_srm2__srmReleaseSpaceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmReleaseSpaceRequest"))
		{	*type = SOAP_TYPE_srm2__srmReleaseSpaceRequest;
			return soap_in_srm2__srmReleaseSpaceRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmStatusOfReserveSpaceRequestResponse"))
		{	*type = SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequestResponse;
			return soap_in_srm2__srmStatusOfReserveSpaceRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmStatusOfReserveSpaceRequestRequest"))
		{	*type = SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequestRequest;
			return soap_in_srm2__srmStatusOfReserveSpaceRequestRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmReserveSpaceResponse"))
		{	*type = SOAP_TYPE_srm2__srmReserveSpaceResponse;
			return soap_in_srm2__srmReserveSpaceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:srmReserveSpaceRequest"))
		{	*type = SOAP_TYPE_srm2__srmReserveSpaceRequest;
			return soap_in_srm2__srmReserveSpaceRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:ArrayOfTSupportedTransferProtocol"))
		{	*type = SOAP_TYPE_srm2__ArrayOfTSupportedTransferProtocol;
			return soap_in_srm2__ArrayOfTSupportedTransferProtocol(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:TSupportedTransferProtocol"))
		{	*type = SOAP_TYPE_srm2__TSupportedTransferProtocol;
			return soap_in_srm2__TSupportedTransferProtocol(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:ArrayOfTRequestTokenReturn"))
		{	*type = SOAP_TYPE_srm2__ArrayOfTRequestTokenReturn;
			return soap_in_srm2__ArrayOfTRequestTokenReturn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:TRequestTokenReturn"))
		{	*type = SOAP_TYPE_srm2__TRequestTokenReturn;
			return soap_in_srm2__TRequestTokenReturn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:ArrayOfTPermissionReturn"))
		{	*type = SOAP_TYPE_srm2__ArrayOfTPermissionReturn;
			return soap_in_srm2__ArrayOfTPermissionReturn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:TPermissionReturn"))
		{	*type = SOAP_TYPE_srm2__TPermissionReturn;
			return soap_in_srm2__TPermissionReturn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:ArrayOfTSURLPermissionReturn"))
		{	*type = SOAP_TYPE_srm2__ArrayOfTSURLPermissionReturn;
			return soap_in_srm2__ArrayOfTSURLPermissionReturn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:TSURLPermissionReturn"))
		{	*type = SOAP_TYPE_srm2__TSURLPermissionReturn;
			return soap_in_srm2__TSURLPermissionReturn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:ArrayOfTRequestSummary"))
		{	*type = SOAP_TYPE_srm2__ArrayOfTRequestSummary;
			return soap_in_srm2__ArrayOfTRequestSummary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:TRequestSummary"))
		{	*type = SOAP_TYPE_srm2__TRequestSummary;
			return soap_in_srm2__TRequestSummary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:ArrayOfTCopyRequestFileStatus"))
		{	*type = SOAP_TYPE_srm2__ArrayOfTCopyRequestFileStatus;
			return soap_in_srm2__ArrayOfTCopyRequestFileStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:TCopyRequestFileStatus"))
		{	*type = SOAP_TYPE_srm2__TCopyRequestFileStatus;
			return soap_in_srm2__TCopyRequestFileStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:ArrayOfTPutRequestFileStatus"))
		{	*type = SOAP_TYPE_srm2__ArrayOfTPutRequestFileStatus;
			return soap_in_srm2__ArrayOfTPutRequestFileStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:TPutRequestFileStatus"))
		{	*type = SOAP_TYPE_srm2__TPutRequestFileStatus;
			return soap_in_srm2__TPutRequestFileStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:ArrayOfTBringOnlineRequestFileStatus"))
		{	*type = SOAP_TYPE_srm2__ArrayOfTBringOnlineRequestFileStatus;
			return soap_in_srm2__ArrayOfTBringOnlineRequestFileStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:TBringOnlineRequestFileStatus"))
		{	*type = SOAP_TYPE_srm2__TBringOnlineRequestFileStatus;
			return soap_in_srm2__TBringOnlineRequestFileStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:ArrayOfTGetRequestFileStatus"))
		{	*type = SOAP_TYPE_srm2__ArrayOfTGetRequestFileStatus;
			return soap_in_srm2__ArrayOfTGetRequestFileStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:TGetRequestFileStatus"))
		{	*type = SOAP_TYPE_srm2__TGetRequestFileStatus;
			return soap_in_srm2__TGetRequestFileStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:ArrayOfTCopyFileRequest"))
		{	*type = SOAP_TYPE_srm2__ArrayOfTCopyFileRequest;
			return soap_in_srm2__ArrayOfTCopyFileRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:TCopyFileRequest"))
		{	*type = SOAP_TYPE_srm2__TCopyFileRequest;
			return soap_in_srm2__TCopyFileRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:ArrayOfTPutFileRequest"))
		{	*type = SOAP_TYPE_srm2__ArrayOfTPutFileRequest;
			return soap_in_srm2__ArrayOfTPutFileRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:TPutFileRequest"))
		{	*type = SOAP_TYPE_srm2__TPutFileRequest;
			return soap_in_srm2__TPutFileRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:ArrayOfTGetFileRequest"))
		{	*type = SOAP_TYPE_srm2__ArrayOfTGetFileRequest;
			return soap_in_srm2__ArrayOfTGetFileRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:TGetFileRequest"))
		{	*type = SOAP_TYPE_srm2__TGetFileRequest;
			return soap_in_srm2__TGetFileRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:TTransferParameters"))
		{	*type = SOAP_TYPE_srm2__TTransferParameters;
			return soap_in_srm2__TTransferParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:ArrayOfAnyURI"))
		{	*type = SOAP_TYPE_srm2__ArrayOfAnyURI;
			return soap_in_srm2__ArrayOfAnyURI(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:ArrayOfTExtraInfo"))
		{	*type = SOAP_TYPE_srm2__ArrayOfTExtraInfo;
			return soap_in_srm2__ArrayOfTExtraInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:TExtraInfo"))
		{	*type = SOAP_TYPE_srm2__TExtraInfo;
			return soap_in_srm2__TExtraInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:TDirOption"))
		{	*type = SOAP_TYPE_srm2__TDirOption;
			return soap_in_srm2__TDirOption(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:ArrayOfTMetaDataSpace"))
		{	*type = SOAP_TYPE_srm2__ArrayOfTMetaDataSpace;
			return soap_in_srm2__ArrayOfTMetaDataSpace(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:TMetaDataSpace"))
		{	*type = SOAP_TYPE_srm2__TMetaDataSpace;
			return soap_in_srm2__TMetaDataSpace(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:ArrayOfTMetaDataPathDetail"))
		{	*type = SOAP_TYPE_srm2__ArrayOfTMetaDataPathDetail;
			return soap_in_srm2__ArrayOfTMetaDataPathDetail(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:TMetaDataPathDetail"))
		{	*type = SOAP_TYPE_srm2__TMetaDataPathDetail;
			return soap_in_srm2__TMetaDataPathDetail(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:ArrayOfTSURLLifetimeReturnStatus"))
		{	*type = SOAP_TYPE_srm2__ArrayOfTSURLLifetimeReturnStatus;
			return soap_in_srm2__ArrayOfTSURLLifetimeReturnStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:TSURLLifetimeReturnStatus"))
		{	*type = SOAP_TYPE_srm2__TSURLLifetimeReturnStatus;
			return soap_in_srm2__TSURLLifetimeReturnStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:ArrayOfTSURLReturnStatus"))
		{	*type = SOAP_TYPE_srm2__ArrayOfTSURLReturnStatus;
			return soap_in_srm2__ArrayOfTSURLReturnStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:TSURLReturnStatus"))
		{	*type = SOAP_TYPE_srm2__TSURLReturnStatus;
			return soap_in_srm2__TSURLReturnStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:TReturnStatus"))
		{	*type = SOAP_TYPE_srm2__TReturnStatus;
			return soap_in_srm2__TReturnStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:ArrayOfString"))
		{	*type = SOAP_TYPE_srm2__ArrayOfString;
			return soap_in_srm2__ArrayOfString(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:ArrayOfUnsignedLong"))
		{	*type = SOAP_TYPE_srm2__ArrayOfUnsignedLong;
			return soap_in_srm2__ArrayOfUnsignedLong(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:ArrayOfTGroupPermission"))
		{	*type = SOAP_TYPE_srm2__ArrayOfTGroupPermission;
			return soap_in_srm2__ArrayOfTGroupPermission(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:TGroupPermission"))
		{	*type = SOAP_TYPE_srm2__TGroupPermission;
			return soap_in_srm2__TGroupPermission(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:ArrayOfTUserPermission"))
		{	*type = SOAP_TYPE_srm2__ArrayOfTUserPermission;
			return soap_in_srm2__ArrayOfTUserPermission(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:TUserPermission"))
		{	*type = SOAP_TYPE_srm2__TUserPermission;
			return soap_in_srm2__TUserPermission(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "srm2:TRetentionPolicyInfo"))
		{	*type = SOAP_TYPE_srm2__TRetentionPolicyInfo;
			return soap_in_srm2__TRetentionPolicyInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	char **s;
			*type = SOAP_TYPE_xsd__anyURI;
			s = soap_in_xsd__anyURI(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
			return soap->error = SOAP_TAG_MISMATCH;
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unknown element '%s' (level=%u, %d)\n", soap->tag, soap->level, soap->body));
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_unsignedLONG64:
		return soap_out_unsignedLONG64(soap, tag, id, (const ULONG64 *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_srm2__TStatusCode:
		return soap_out_srm2__TStatusCode(soap, tag, id, (const enum srm2__TStatusCode *)ptr, "srm2:TStatusCode");
	case SOAP_TYPE_srm2__TConnectionType:
		return soap_out_srm2__TConnectionType(soap, tag, id, (const enum srm2__TConnectionType *)ptr, "srm2:TConnectionType");
	case SOAP_TYPE_srm2__TAccessPattern:
		return soap_out_srm2__TAccessPattern(soap, tag, id, (const enum srm2__TAccessPattern *)ptr, "srm2:TAccessPattern");
	case SOAP_TYPE_srm2__TFileLocality:
		return soap_out_srm2__TFileLocality(soap, tag, id, (const enum srm2__TFileLocality *)ptr, "srm2:TFileLocality");
	case SOAP_TYPE_srm2__TOverwriteMode:
		return soap_out_srm2__TOverwriteMode(soap, tag, id, (const enum srm2__TOverwriteMode *)ptr, "srm2:TOverwriteMode");
	case SOAP_TYPE_srm2__TRequestType:
		return soap_out_srm2__TRequestType(soap, tag, id, (const enum srm2__TRequestType *)ptr, "srm2:TRequestType");
	case SOAP_TYPE_srm2__TPermissionType:
		return soap_out_srm2__TPermissionType(soap, tag, id, (const enum srm2__TPermissionType *)ptr, "srm2:TPermissionType");
	case SOAP_TYPE_srm2__TPermissionMode:
		return soap_out_srm2__TPermissionMode(soap, tag, id, (const enum srm2__TPermissionMode *)ptr, "srm2:TPermissionMode");
	case SOAP_TYPE_srm2__TAccessLatency:
		return soap_out_srm2__TAccessLatency(soap, tag, id, (const enum srm2__TAccessLatency *)ptr, "srm2:TAccessLatency");
	case SOAP_TYPE_srm2__TRetentionPolicy:
		return soap_out_srm2__TRetentionPolicy(soap, tag, id, (const enum srm2__TRetentionPolicy *)ptr, "srm2:TRetentionPolicy");
	case SOAP_TYPE_srm2__TFileType:
		return soap_out_srm2__TFileType(soap, tag, id, (const enum srm2__TFileType *)ptr, "srm2:TFileType");
	case SOAP_TYPE_srm2__TFileStorageType:
		return soap_out_srm2__TFileStorageType(soap, tag, id, (const enum srm2__TFileStorageType *)ptr, "srm2:TFileStorageType");
	case SOAP_TYPE_xsd__boolean:
		return soap_out_xsd__boolean(soap, tag, id, (const enum xsd__boolean *)ptr, "xsd:boolean");
	case SOAP_TYPE_SOAP_ENV__Reason:
		return soap_out_SOAP_ENV__Reason(soap, tag, id, (const struct SOAP_ENV__Reason *)ptr, "SOAP-ENV:Reason");
	case SOAP_TYPE_srm2__srmPing:
		return soap_out_srm2__srmPing(soap, tag, id, (const struct srm2__srmPing *)ptr, "srm2:srmPing");
	case SOAP_TYPE_srm2__srmPingResponse_:
		return soap_out_srm2__srmPingResponse_(soap, tag, id, (const struct srm2__srmPingResponse_ *)ptr, "srm2:srmPingResponse");
	case SOAP_TYPE_srm2__srmGetTransferProtocols:
		return soap_out_srm2__srmGetTransferProtocols(soap, tag, id, (const struct srm2__srmGetTransferProtocols *)ptr, "srm2:srmGetTransferProtocols");
	case SOAP_TYPE_srm2__srmGetTransferProtocolsResponse_:
		return soap_out_srm2__srmGetTransferProtocolsResponse_(soap, tag, id, (const struct srm2__srmGetTransferProtocolsResponse_ *)ptr, "srm2:srmGetTransferProtocolsResponse");
	case SOAP_TYPE_srm2__srmGetRequestTokens:
		return soap_out_srm2__srmGetRequestTokens(soap, tag, id, (const struct srm2__srmGetRequestTokens *)ptr, "srm2:srmGetRequestTokens");
	case SOAP_TYPE_srm2__srmGetRequestTokensResponse_:
		return soap_out_srm2__srmGetRequestTokensResponse_(soap, tag, id, (const struct srm2__srmGetRequestTokensResponse_ *)ptr, "srm2:srmGetRequestTokensResponse");
	case SOAP_TYPE_srm2__srmExtendFileLifeTime:
		return soap_out_srm2__srmExtendFileLifeTime(soap, tag, id, (const struct srm2__srmExtendFileLifeTime *)ptr, "srm2:srmExtendFileLifeTime");
	case SOAP_TYPE_srm2__srmExtendFileLifeTimeResponse_:
		return soap_out_srm2__srmExtendFileLifeTimeResponse_(soap, tag, id, (const struct srm2__srmExtendFileLifeTimeResponse_ *)ptr, "srm2:srmExtendFileLifeTimeResponse");
	case SOAP_TYPE_srm2__srmGetRequestSummary:
		return soap_out_srm2__srmGetRequestSummary(soap, tag, id, (const struct srm2__srmGetRequestSummary *)ptr, "srm2:srmGetRequestSummary");
	case SOAP_TYPE_srm2__srmGetRequestSummaryResponse_:
		return soap_out_srm2__srmGetRequestSummaryResponse_(soap, tag, id, (const struct srm2__srmGetRequestSummaryResponse_ *)ptr, "srm2:srmGetRequestSummaryResponse");
	case SOAP_TYPE_srm2__srmResumeRequest:
		return soap_out_srm2__srmResumeRequest(soap, tag, id, (const struct srm2__srmResumeRequest *)ptr, "srm2:srmResumeRequest");
	case SOAP_TYPE_srm2__srmResumeRequestResponse_:
		return soap_out_srm2__srmResumeRequestResponse_(soap, tag, id, (const struct srm2__srmResumeRequestResponse_ *)ptr, "srm2:srmResumeRequestResponse");
	case SOAP_TYPE_srm2__srmSuspendRequest:
		return soap_out_srm2__srmSuspendRequest(soap, tag, id, (const struct srm2__srmSuspendRequest *)ptr, "srm2:srmSuspendRequest");
	case SOAP_TYPE_srm2__srmSuspendRequestResponse_:
		return soap_out_srm2__srmSuspendRequestResponse_(soap, tag, id, (const struct srm2__srmSuspendRequestResponse_ *)ptr, "srm2:srmSuspendRequestResponse");
	case SOAP_TYPE_srm2__srmAbortFiles:
		return soap_out_srm2__srmAbortFiles(soap, tag, id, (const struct srm2__srmAbortFiles *)ptr, "srm2:srmAbortFiles");
	case SOAP_TYPE_srm2__srmAbortFilesResponse_:
		return soap_out_srm2__srmAbortFilesResponse_(soap, tag, id, (const struct srm2__srmAbortFilesResponse_ *)ptr, "srm2:srmAbortFilesResponse");
	case SOAP_TYPE_srm2__srmAbortRequest:
		return soap_out_srm2__srmAbortRequest(soap, tag, id, (const struct srm2__srmAbortRequest *)ptr, "srm2:srmAbortRequest");
	case SOAP_TYPE_srm2__srmAbortRequestResponse_:
		return soap_out_srm2__srmAbortRequestResponse_(soap, tag, id, (const struct srm2__srmAbortRequestResponse_ *)ptr, "srm2:srmAbortRequestResponse");
	case SOAP_TYPE_srm2__srmPutDone:
		return soap_out_srm2__srmPutDone(soap, tag, id, (const struct srm2__srmPutDone *)ptr, "srm2:srmPutDone");
	case SOAP_TYPE_srm2__srmPutDoneResponse_:
		return soap_out_srm2__srmPutDoneResponse_(soap, tag, id, (const struct srm2__srmPutDoneResponse_ *)ptr, "srm2:srmPutDoneResponse");
	case SOAP_TYPE_srm2__srmReleaseFiles:
		return soap_out_srm2__srmReleaseFiles(soap, tag, id, (const struct srm2__srmReleaseFiles *)ptr, "srm2:srmReleaseFiles");
	case SOAP_TYPE_srm2__srmReleaseFilesResponse_:
		return soap_out_srm2__srmReleaseFilesResponse_(soap, tag, id, (const struct srm2__srmReleaseFilesResponse_ *)ptr, "srm2:srmReleaseFilesResponse");
	case SOAP_TYPE_srm2__srmStatusOfCopyRequest:
		return soap_out_srm2__srmStatusOfCopyRequest(soap, tag, id, (const struct srm2__srmStatusOfCopyRequest *)ptr, "srm2:srmStatusOfCopyRequest");
	case SOAP_TYPE_srm2__srmStatusOfCopyRequestResponse_:
		return soap_out_srm2__srmStatusOfCopyRequestResponse_(soap, tag, id, (const struct srm2__srmStatusOfCopyRequestResponse_ *)ptr, "srm2:srmStatusOfCopyRequestResponse");
	case SOAP_TYPE_srm2__srmCopy:
		return soap_out_srm2__srmCopy(soap, tag, id, (const struct srm2__srmCopy *)ptr, "srm2:srmCopy");
	case SOAP_TYPE_srm2__srmCopyResponse_:
		return soap_out_srm2__srmCopyResponse_(soap, tag, id, (const struct srm2__srmCopyResponse_ *)ptr, "srm2:srmCopyResponse");
	case SOAP_TYPE_srm2__srmStatusOfPutRequest:
		return soap_out_srm2__srmStatusOfPutRequest(soap, tag, id, (const struct srm2__srmStatusOfPutRequest *)ptr, "srm2:srmStatusOfPutRequest");
	case SOAP_TYPE_srm2__srmStatusOfPutRequestResponse_:
		return soap_out_srm2__srmStatusOfPutRequestResponse_(soap, tag, id, (const struct srm2__srmStatusOfPutRequestResponse_ *)ptr, "srm2:srmStatusOfPutRequestResponse");
	case SOAP_TYPE_srm2__srmPrepareToPut:
		return soap_out_srm2__srmPrepareToPut(soap, tag, id, (const struct srm2__srmPrepareToPut *)ptr, "srm2:srmPrepareToPut");
	case SOAP_TYPE_srm2__srmPrepareToPutResponse_:
		return soap_out_srm2__srmPrepareToPutResponse_(soap, tag, id, (const struct srm2__srmPrepareToPutResponse_ *)ptr, "srm2:srmPrepareToPutResponse");
	case SOAP_TYPE_srm2__srmStatusOfBringOnlineRequest:
		return soap_out_srm2__srmStatusOfBringOnlineRequest(soap, tag, id, (const struct srm2__srmStatusOfBringOnlineRequest *)ptr, "srm2:srmStatusOfBringOnlineRequest");
	case SOAP_TYPE_srm2__srmStatusOfBringOnlineRequestResponse_:
		return soap_out_srm2__srmStatusOfBringOnlineRequestResponse_(soap, tag, id, (const struct srm2__srmStatusOfBringOnlineRequestResponse_ *)ptr, "srm2:srmStatusOfBringOnlineRequestResponse");
	case SOAP_TYPE_srm2__srmBringOnline:
		return soap_out_srm2__srmBringOnline(soap, tag, id, (const struct srm2__srmBringOnline *)ptr, "srm2:srmBringOnline");
	case SOAP_TYPE_srm2__srmBringOnlineResponse_:
		return soap_out_srm2__srmBringOnlineResponse_(soap, tag, id, (const struct srm2__srmBringOnlineResponse_ *)ptr, "srm2:srmBringOnlineResponse");
	case SOAP_TYPE_srm2__srmStatusOfGetRequest:
		return soap_out_srm2__srmStatusOfGetRequest(soap, tag, id, (const struct srm2__srmStatusOfGetRequest *)ptr, "srm2:srmStatusOfGetRequest");
	case SOAP_TYPE_srm2__srmStatusOfGetRequestResponse_:
		return soap_out_srm2__srmStatusOfGetRequestResponse_(soap, tag, id, (const struct srm2__srmStatusOfGetRequestResponse_ *)ptr, "srm2:srmStatusOfGetRequestResponse");
	case SOAP_TYPE_srm2__srmPrepareToGet:
		return soap_out_srm2__srmPrepareToGet(soap, tag, id, (const struct srm2__srmPrepareToGet *)ptr, "srm2:srmPrepareToGet");
	case SOAP_TYPE_srm2__srmPrepareToGetResponse_:
		return soap_out_srm2__srmPrepareToGetResponse_(soap, tag, id, (const struct srm2__srmPrepareToGetResponse_ *)ptr, "srm2:srmPrepareToGetResponse");
	case SOAP_TYPE_srm2__srmMv:
		return soap_out_srm2__srmMv(soap, tag, id, (const struct srm2__srmMv *)ptr, "srm2:srmMv");
	case SOAP_TYPE_srm2__srmMvResponse_:
		return soap_out_srm2__srmMvResponse_(soap, tag, id, (const struct srm2__srmMvResponse_ *)ptr, "srm2:srmMvResponse");
	case SOAP_TYPE_srm2__srmStatusOfLsRequest:
		return soap_out_srm2__srmStatusOfLsRequest(soap, tag, id, (const struct srm2__srmStatusOfLsRequest *)ptr, "srm2:srmStatusOfLsRequest");
	case SOAP_TYPE_srm2__srmStatusOfLsRequestResponse_:
		return soap_out_srm2__srmStatusOfLsRequestResponse_(soap, tag, id, (const struct srm2__srmStatusOfLsRequestResponse_ *)ptr, "srm2:srmStatusOfLsRequestResponse");
	case SOAP_TYPE_srm2__srmLs:
		return soap_out_srm2__srmLs(soap, tag, id, (const struct srm2__srmLs *)ptr, "srm2:srmLs");
	case SOAP_TYPE_srm2__srmLsResponse_:
		return soap_out_srm2__srmLsResponse_(soap, tag, id, (const struct srm2__srmLsResponse_ *)ptr, "srm2:srmLsResponse");
	case SOAP_TYPE_srm2__srmRm:
		return soap_out_srm2__srmRm(soap, tag, id, (const struct srm2__srmRm *)ptr, "srm2:srmRm");
	case SOAP_TYPE_srm2__srmRmResponse_:
		return soap_out_srm2__srmRmResponse_(soap, tag, id, (const struct srm2__srmRmResponse_ *)ptr, "srm2:srmRmResponse");
	case SOAP_TYPE_srm2__srmRmdir:
		return soap_out_srm2__srmRmdir(soap, tag, id, (const struct srm2__srmRmdir *)ptr, "srm2:srmRmdir");
	case SOAP_TYPE_srm2__srmRmdirResponse_:
		return soap_out_srm2__srmRmdirResponse_(soap, tag, id, (const struct srm2__srmRmdirResponse_ *)ptr, "srm2:srmRmdirResponse");
	case SOAP_TYPE_srm2__srmMkdir:
		return soap_out_srm2__srmMkdir(soap, tag, id, (const struct srm2__srmMkdir *)ptr, "srm2:srmMkdir");
	case SOAP_TYPE_srm2__srmMkdirResponse_:
		return soap_out_srm2__srmMkdirResponse_(soap, tag, id, (const struct srm2__srmMkdirResponse_ *)ptr, "srm2:srmMkdirResponse");
	case SOAP_TYPE_srm2__srmGetPermission:
		return soap_out_srm2__srmGetPermission(soap, tag, id, (const struct srm2__srmGetPermission *)ptr, "srm2:srmGetPermission");
	case SOAP_TYPE_srm2__srmGetPermissionResponse_:
		return soap_out_srm2__srmGetPermissionResponse_(soap, tag, id, (const struct srm2__srmGetPermissionResponse_ *)ptr, "srm2:srmGetPermissionResponse");
	case SOAP_TYPE_srm2__srmCheckPermission:
		return soap_out_srm2__srmCheckPermission(soap, tag, id, (const struct srm2__srmCheckPermission *)ptr, "srm2:srmCheckPermission");
	case SOAP_TYPE_srm2__srmCheckPermissionResponse_:
		return soap_out_srm2__srmCheckPermissionResponse_(soap, tag, id, (const struct srm2__srmCheckPermissionResponse_ *)ptr, "srm2:srmCheckPermissionResponse");
	case SOAP_TYPE_srm2__srmSetPermission:
		return soap_out_srm2__srmSetPermission(soap, tag, id, (const struct srm2__srmSetPermission *)ptr, "srm2:srmSetPermission");
	case SOAP_TYPE_srm2__srmSetPermissionResponse_:
		return soap_out_srm2__srmSetPermissionResponse_(soap, tag, id, (const struct srm2__srmSetPermissionResponse_ *)ptr, "srm2:srmSetPermissionResponse");
	case SOAP_TYPE_srm2__srmGetSpaceTokens:
		return soap_out_srm2__srmGetSpaceTokens(soap, tag, id, (const struct srm2__srmGetSpaceTokens *)ptr, "srm2:srmGetSpaceTokens");
	case SOAP_TYPE_srm2__srmGetSpaceTokensResponse_:
		return soap_out_srm2__srmGetSpaceTokensResponse_(soap, tag, id, (const struct srm2__srmGetSpaceTokensResponse_ *)ptr, "srm2:srmGetSpaceTokensResponse");
	case SOAP_TYPE_srm2__srmPurgeFromSpace:
		return soap_out_srm2__srmPurgeFromSpace(soap, tag, id, (const struct srm2__srmPurgeFromSpace *)ptr, "srm2:srmPurgeFromSpace");
	case SOAP_TYPE_srm2__srmPurgeFromSpaceResponse_:
		return soap_out_srm2__srmPurgeFromSpaceResponse_(soap, tag, id, (const struct srm2__srmPurgeFromSpaceResponse_ *)ptr, "srm2:srmPurgeFromSpaceResponse");
	case SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpace:
		return soap_out_srm2__srmExtendFileLifeTimeInSpace(soap, tag, id, (const struct srm2__srmExtendFileLifeTimeInSpace *)ptr, "srm2:srmExtendFileLifeTimeInSpace");
	case SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpaceResponse_:
		return soap_out_srm2__srmExtendFileLifeTimeInSpaceResponse_(soap, tag, id, (const struct srm2__srmExtendFileLifeTimeInSpaceResponse_ *)ptr, "srm2:srmExtendFileLifeTimeInSpaceResponse");
	case SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequest:
		return soap_out_srm2__srmStatusOfChangeSpaceForFilesRequest(soap, tag, id, (const struct srm2__srmStatusOfChangeSpaceForFilesRequest *)ptr, "srm2:srmStatusOfChangeSpaceForFilesRequest");
	case SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequestResponse_:
		return soap_out_srm2__srmStatusOfChangeSpaceForFilesRequestResponse_(soap, tag, id, (const struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse_ *)ptr, "srm2:srmStatusOfChangeSpaceForFilesRequestResponse");
	case SOAP_TYPE_srm2__srmChangeSpaceForFiles:
		return soap_out_srm2__srmChangeSpaceForFiles(soap, tag, id, (const struct srm2__srmChangeSpaceForFiles *)ptr, "srm2:srmChangeSpaceForFiles");
	case SOAP_TYPE_srm2__srmChangeSpaceForFilesResponse_:
		return soap_out_srm2__srmChangeSpaceForFilesResponse_(soap, tag, id, (const struct srm2__srmChangeSpaceForFilesResponse_ *)ptr, "srm2:srmChangeSpaceForFilesResponse");
	case SOAP_TYPE_srm2__srmGetSpaceMetaData:
		return soap_out_srm2__srmGetSpaceMetaData(soap, tag, id, (const struct srm2__srmGetSpaceMetaData *)ptr, "srm2:srmGetSpaceMetaData");
	case SOAP_TYPE_srm2__srmGetSpaceMetaDataResponse_:
		return soap_out_srm2__srmGetSpaceMetaDataResponse_(soap, tag, id, (const struct srm2__srmGetSpaceMetaDataResponse_ *)ptr, "srm2:srmGetSpaceMetaDataResponse");
	case SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequest:
		return soap_out_srm2__srmStatusOfUpdateSpaceRequest(soap, tag, id, (const struct srm2__srmStatusOfUpdateSpaceRequest *)ptr, "srm2:srmStatusOfUpdateSpaceRequest");
	case SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequestResponse_:
		return soap_out_srm2__srmStatusOfUpdateSpaceRequestResponse_(soap, tag, id, (const struct srm2__srmStatusOfUpdateSpaceRequestResponse_ *)ptr, "srm2:srmStatusOfUpdateSpaceRequestResponse");
	case SOAP_TYPE_srm2__srmUpdateSpace:
		return soap_out_srm2__srmUpdateSpace(soap, tag, id, (const struct srm2__srmUpdateSpace *)ptr, "srm2:srmUpdateSpace");
	case SOAP_TYPE_srm2__srmUpdateSpaceResponse_:
		return soap_out_srm2__srmUpdateSpaceResponse_(soap, tag, id, (const struct srm2__srmUpdateSpaceResponse_ *)ptr, "srm2:srmUpdateSpaceResponse");
	case SOAP_TYPE_srm2__srmReleaseSpace:
		return soap_out_srm2__srmReleaseSpace(soap, tag, id, (const struct srm2__srmReleaseSpace *)ptr, "srm2:srmReleaseSpace");
	case SOAP_TYPE_srm2__srmReleaseSpaceResponse_:
		return soap_out_srm2__srmReleaseSpaceResponse_(soap, tag, id, (const struct srm2__srmReleaseSpaceResponse_ *)ptr, "srm2:srmReleaseSpaceResponse");
	case SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequest:
		return soap_out_srm2__srmStatusOfReserveSpaceRequest(soap, tag, id, (const struct srm2__srmStatusOfReserveSpaceRequest *)ptr, "srm2:srmStatusOfReserveSpaceRequest");
	case SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequestResponse_:
		return soap_out_srm2__srmStatusOfReserveSpaceRequestResponse_(soap, tag, id, (const struct srm2__srmStatusOfReserveSpaceRequestResponse_ *)ptr, "srm2:srmStatusOfReserveSpaceRequestResponse");
	case SOAP_TYPE_srm2__srmReserveSpace:
		return soap_out_srm2__srmReserveSpace(soap, tag, id, (const struct srm2__srmReserveSpace *)ptr, "srm2:srmReserveSpace");
	case SOAP_TYPE_srm2__srmReserveSpaceResponse_:
		return soap_out_srm2__srmReserveSpaceResponse_(soap, tag, id, (const struct srm2__srmReserveSpaceResponse_ *)ptr, "srm2:srmReserveSpaceResponse");
	case SOAP_TYPE_srm2__srmPingResponse:
		return soap_out_srm2__srmPingResponse(soap, tag, id, (const struct srm2__srmPingResponse *)ptr, "srm2:srmPingResponse");
	case SOAP_TYPE_srm2__srmPingRequest:
		return soap_out_srm2__srmPingRequest(soap, tag, id, (const struct srm2__srmPingRequest *)ptr, "srm2:srmPingRequest");
	case SOAP_TYPE_srm2__srmGetTransferProtocolsResponse:
		return soap_out_srm2__srmGetTransferProtocolsResponse(soap, tag, id, (const struct srm2__srmGetTransferProtocolsResponse *)ptr, "srm2:srmGetTransferProtocolsResponse");
	case SOAP_TYPE_srm2__srmGetTransferProtocolsRequest:
		return soap_out_srm2__srmGetTransferProtocolsRequest(soap, tag, id, (const struct srm2__srmGetTransferProtocolsRequest *)ptr, "srm2:srmGetTransferProtocolsRequest");
	case SOAP_TYPE_srm2__srmGetRequestTokensResponse:
		return soap_out_srm2__srmGetRequestTokensResponse(soap, tag, id, (const struct srm2__srmGetRequestTokensResponse *)ptr, "srm2:srmGetRequestTokensResponse");
	case SOAP_TYPE_srm2__srmGetRequestTokensRequest:
		return soap_out_srm2__srmGetRequestTokensRequest(soap, tag, id, (const struct srm2__srmGetRequestTokensRequest *)ptr, "srm2:srmGetRequestTokensRequest");
	case SOAP_TYPE_srm2__srmExtendFileLifeTimeResponse:
		return soap_out_srm2__srmExtendFileLifeTimeResponse(soap, tag, id, (const struct srm2__srmExtendFileLifeTimeResponse *)ptr, "srm2:srmExtendFileLifeTimeResponse");
	case SOAP_TYPE_srm2__srmExtendFileLifeTimeRequest:
		return soap_out_srm2__srmExtendFileLifeTimeRequest(soap, tag, id, (const struct srm2__srmExtendFileLifeTimeRequest *)ptr, "srm2:srmExtendFileLifeTimeRequest");
	case SOAP_TYPE_srm2__srmGetRequestSummaryResponse:
		return soap_out_srm2__srmGetRequestSummaryResponse(soap, tag, id, (const struct srm2__srmGetRequestSummaryResponse *)ptr, "srm2:srmGetRequestSummaryResponse");
	case SOAP_TYPE_srm2__srmGetRequestSummaryRequest:
		return soap_out_srm2__srmGetRequestSummaryRequest(soap, tag, id, (const struct srm2__srmGetRequestSummaryRequest *)ptr, "srm2:srmGetRequestSummaryRequest");
	case SOAP_TYPE_srm2__srmResumeRequestResponse:
		return soap_out_srm2__srmResumeRequestResponse(soap, tag, id, (const struct srm2__srmResumeRequestResponse *)ptr, "srm2:srmResumeRequestResponse");
	case SOAP_TYPE_srm2__srmResumeRequestRequest:
		return soap_out_srm2__srmResumeRequestRequest(soap, tag, id, (const struct srm2__srmResumeRequestRequest *)ptr, "srm2:srmResumeRequestRequest");
	case SOAP_TYPE_srm2__srmSuspendRequestResponse:
		return soap_out_srm2__srmSuspendRequestResponse(soap, tag, id, (const struct srm2__srmSuspendRequestResponse *)ptr, "srm2:srmSuspendRequestResponse");
	case SOAP_TYPE_srm2__srmSuspendRequestRequest:
		return soap_out_srm2__srmSuspendRequestRequest(soap, tag, id, (const struct srm2__srmSuspendRequestRequest *)ptr, "srm2:srmSuspendRequestRequest");
	case SOAP_TYPE_srm2__srmAbortFilesResponse:
		return soap_out_srm2__srmAbortFilesResponse(soap, tag, id, (const struct srm2__srmAbortFilesResponse *)ptr, "srm2:srmAbortFilesResponse");
	case SOAP_TYPE_srm2__srmAbortFilesRequest:
		return soap_out_srm2__srmAbortFilesRequest(soap, tag, id, (const struct srm2__srmAbortFilesRequest *)ptr, "srm2:srmAbortFilesRequest");
	case SOAP_TYPE_srm2__srmAbortRequestResponse:
		return soap_out_srm2__srmAbortRequestResponse(soap, tag, id, (const struct srm2__srmAbortRequestResponse *)ptr, "srm2:srmAbortRequestResponse");
	case SOAP_TYPE_srm2__srmAbortRequestRequest:
		return soap_out_srm2__srmAbortRequestRequest(soap, tag, id, (const struct srm2__srmAbortRequestRequest *)ptr, "srm2:srmAbortRequestRequest");
	case SOAP_TYPE_srm2__srmPutDoneResponse:
		return soap_out_srm2__srmPutDoneResponse(soap, tag, id, (const struct srm2__srmPutDoneResponse *)ptr, "srm2:srmPutDoneResponse");
	case SOAP_TYPE_srm2__srmPutDoneRequest:
		return soap_out_srm2__srmPutDoneRequest(soap, tag, id, (const struct srm2__srmPutDoneRequest *)ptr, "srm2:srmPutDoneRequest");
	case SOAP_TYPE_srm2__srmReleaseFilesResponse:
		return soap_out_srm2__srmReleaseFilesResponse(soap, tag, id, (const struct srm2__srmReleaseFilesResponse *)ptr, "srm2:srmReleaseFilesResponse");
	case SOAP_TYPE_srm2__srmReleaseFilesRequest:
		return soap_out_srm2__srmReleaseFilesRequest(soap, tag, id, (const struct srm2__srmReleaseFilesRequest *)ptr, "srm2:srmReleaseFilesRequest");
	case SOAP_TYPE_srm2__srmStatusOfCopyRequestResponse:
		return soap_out_srm2__srmStatusOfCopyRequestResponse(soap, tag, id, (const struct srm2__srmStatusOfCopyRequestResponse *)ptr, "srm2:srmStatusOfCopyRequestResponse");
	case SOAP_TYPE_srm2__srmStatusOfCopyRequestRequest:
		return soap_out_srm2__srmStatusOfCopyRequestRequest(soap, tag, id, (const struct srm2__srmStatusOfCopyRequestRequest *)ptr, "srm2:srmStatusOfCopyRequestRequest");
	case SOAP_TYPE_srm2__srmCopyResponse:
		return soap_out_srm2__srmCopyResponse(soap, tag, id, (const struct srm2__srmCopyResponse *)ptr, "srm2:srmCopyResponse");
	case SOAP_TYPE_srm2__srmCopyRequest:
		return soap_out_srm2__srmCopyRequest(soap, tag, id, (const struct srm2__srmCopyRequest *)ptr, "srm2:srmCopyRequest");
	case SOAP_TYPE_srm2__srmStatusOfPutRequestResponse:
		return soap_out_srm2__srmStatusOfPutRequestResponse(soap, tag, id, (const struct srm2__srmStatusOfPutRequestResponse *)ptr, "srm2:srmStatusOfPutRequestResponse");
	case SOAP_TYPE_srm2__srmStatusOfPutRequestRequest:
		return soap_out_srm2__srmStatusOfPutRequestRequest(soap, tag, id, (const struct srm2__srmStatusOfPutRequestRequest *)ptr, "srm2:srmStatusOfPutRequestRequest");
	case SOAP_TYPE_srm2__srmPrepareToPutResponse:
		return soap_out_srm2__srmPrepareToPutResponse(soap, tag, id, (const struct srm2__srmPrepareToPutResponse *)ptr, "srm2:srmPrepareToPutResponse");
	case SOAP_TYPE_srm2__srmPrepareToPutRequest:
		return soap_out_srm2__srmPrepareToPutRequest(soap, tag, id, (const struct srm2__srmPrepareToPutRequest *)ptr, "srm2:srmPrepareToPutRequest");
	case SOAP_TYPE_srm2__srmStatusOfBringOnlineRequestResponse:
		return soap_out_srm2__srmStatusOfBringOnlineRequestResponse(soap, tag, id, (const struct srm2__srmStatusOfBringOnlineRequestResponse *)ptr, "srm2:srmStatusOfBringOnlineRequestResponse");
	case SOAP_TYPE_srm2__srmStatusOfBringOnlineRequestRequest:
		return soap_out_srm2__srmStatusOfBringOnlineRequestRequest(soap, tag, id, (const struct srm2__srmStatusOfBringOnlineRequestRequest *)ptr, "srm2:srmStatusOfBringOnlineRequestRequest");
	case SOAP_TYPE_srm2__srmBringOnlineResponse:
		return soap_out_srm2__srmBringOnlineResponse(soap, tag, id, (const struct srm2__srmBringOnlineResponse *)ptr, "srm2:srmBringOnlineResponse");
	case SOAP_TYPE_srm2__srmBringOnlineRequest:
		return soap_out_srm2__srmBringOnlineRequest(soap, tag, id, (const struct srm2__srmBringOnlineRequest *)ptr, "srm2:srmBringOnlineRequest");
	case SOAP_TYPE_srm2__srmStatusOfGetRequestResponse:
		return soap_out_srm2__srmStatusOfGetRequestResponse(soap, tag, id, (const struct srm2__srmStatusOfGetRequestResponse *)ptr, "srm2:srmStatusOfGetRequestResponse");
	case SOAP_TYPE_srm2__srmStatusOfGetRequestRequest:
		return soap_out_srm2__srmStatusOfGetRequestRequest(soap, tag, id, (const struct srm2__srmStatusOfGetRequestRequest *)ptr, "srm2:srmStatusOfGetRequestRequest");
	case SOAP_TYPE_srm2__srmPrepareToGetResponse:
		return soap_out_srm2__srmPrepareToGetResponse(soap, tag, id, (const struct srm2__srmPrepareToGetResponse *)ptr, "srm2:srmPrepareToGetResponse");
	case SOAP_TYPE_srm2__srmPrepareToGetRequest:
		return soap_out_srm2__srmPrepareToGetRequest(soap, tag, id, (const struct srm2__srmPrepareToGetRequest *)ptr, "srm2:srmPrepareToGetRequest");
	case SOAP_TYPE_srm2__srmMvResponse:
		return soap_out_srm2__srmMvResponse(soap, tag, id, (const struct srm2__srmMvResponse *)ptr, "srm2:srmMvResponse");
	case SOAP_TYPE_srm2__srmMvRequest:
		return soap_out_srm2__srmMvRequest(soap, tag, id, (const struct srm2__srmMvRequest *)ptr, "srm2:srmMvRequest");
	case SOAP_TYPE_srm2__srmStatusOfLsRequestResponse:
		return soap_out_srm2__srmStatusOfLsRequestResponse(soap, tag, id, (const struct srm2__srmStatusOfLsRequestResponse *)ptr, "srm2:srmStatusOfLsRequestResponse");
	case SOAP_TYPE_srm2__srmStatusOfLsRequestRequest:
		return soap_out_srm2__srmStatusOfLsRequestRequest(soap, tag, id, (const struct srm2__srmStatusOfLsRequestRequest *)ptr, "srm2:srmStatusOfLsRequestRequest");
	case SOAP_TYPE_srm2__srmLsResponse:
		return soap_out_srm2__srmLsResponse(soap, tag, id, (const struct srm2__srmLsResponse *)ptr, "srm2:srmLsResponse");
	case SOAP_TYPE_srm2__srmLsRequest:
		return soap_out_srm2__srmLsRequest(soap, tag, id, (const struct srm2__srmLsRequest *)ptr, "srm2:srmLsRequest");
	case SOAP_TYPE_srm2__srmRmResponse:
		return soap_out_srm2__srmRmResponse(soap, tag, id, (const struct srm2__srmRmResponse *)ptr, "srm2:srmRmResponse");
	case SOAP_TYPE_srm2__srmRmRequest:
		return soap_out_srm2__srmRmRequest(soap, tag, id, (const struct srm2__srmRmRequest *)ptr, "srm2:srmRmRequest");
	case SOAP_TYPE_srm2__srmRmdirResponse:
		return soap_out_srm2__srmRmdirResponse(soap, tag, id, (const struct srm2__srmRmdirResponse *)ptr, "srm2:srmRmdirResponse");
	case SOAP_TYPE_srm2__srmRmdirRequest:
		return soap_out_srm2__srmRmdirRequest(soap, tag, id, (const struct srm2__srmRmdirRequest *)ptr, "srm2:srmRmdirRequest");
	case SOAP_TYPE_srm2__srmMkdirResponse:
		return soap_out_srm2__srmMkdirResponse(soap, tag, id, (const struct srm2__srmMkdirResponse *)ptr, "srm2:srmMkdirResponse");
	case SOAP_TYPE_srm2__srmMkdirRequest:
		return soap_out_srm2__srmMkdirRequest(soap, tag, id, (const struct srm2__srmMkdirRequest *)ptr, "srm2:srmMkdirRequest");
	case SOAP_TYPE_srm2__srmGetPermissionResponse:
		return soap_out_srm2__srmGetPermissionResponse(soap, tag, id, (const struct srm2__srmGetPermissionResponse *)ptr, "srm2:srmGetPermissionResponse");
	case SOAP_TYPE_srm2__srmGetPermissionRequest:
		return soap_out_srm2__srmGetPermissionRequest(soap, tag, id, (const struct srm2__srmGetPermissionRequest *)ptr, "srm2:srmGetPermissionRequest");
	case SOAP_TYPE_srm2__srmCheckPermissionResponse:
		return soap_out_srm2__srmCheckPermissionResponse(soap, tag, id, (const struct srm2__srmCheckPermissionResponse *)ptr, "srm2:srmCheckPermissionResponse");
	case SOAP_TYPE_srm2__srmCheckPermissionRequest:
		return soap_out_srm2__srmCheckPermissionRequest(soap, tag, id, (const struct srm2__srmCheckPermissionRequest *)ptr, "srm2:srmCheckPermissionRequest");
	case SOAP_TYPE_srm2__srmSetPermissionResponse:
		return soap_out_srm2__srmSetPermissionResponse(soap, tag, id, (const struct srm2__srmSetPermissionResponse *)ptr, "srm2:srmSetPermissionResponse");
	case SOAP_TYPE_srm2__srmSetPermissionRequest:
		return soap_out_srm2__srmSetPermissionRequest(soap, tag, id, (const struct srm2__srmSetPermissionRequest *)ptr, "srm2:srmSetPermissionRequest");
	case SOAP_TYPE_srm2__srmGetSpaceTokensResponse:
		return soap_out_srm2__srmGetSpaceTokensResponse(soap, tag, id, (const struct srm2__srmGetSpaceTokensResponse *)ptr, "srm2:srmGetSpaceTokensResponse");
	case SOAP_TYPE_srm2__srmGetSpaceTokensRequest:
		return soap_out_srm2__srmGetSpaceTokensRequest(soap, tag, id, (const struct srm2__srmGetSpaceTokensRequest *)ptr, "srm2:srmGetSpaceTokensRequest");
	case SOAP_TYPE_srm2__srmPurgeFromSpaceResponse:
		return soap_out_srm2__srmPurgeFromSpaceResponse(soap, tag, id, (const struct srm2__srmPurgeFromSpaceResponse *)ptr, "srm2:srmPurgeFromSpaceResponse");
	case SOAP_TYPE_srm2__srmPurgeFromSpaceRequest:
		return soap_out_srm2__srmPurgeFromSpaceRequest(soap, tag, id, (const struct srm2__srmPurgeFromSpaceRequest *)ptr, "srm2:srmPurgeFromSpaceRequest");
	case SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpaceResponse:
		return soap_out_srm2__srmExtendFileLifeTimeInSpaceResponse(soap, tag, id, (const struct srm2__srmExtendFileLifeTimeInSpaceResponse *)ptr, "srm2:srmExtendFileLifeTimeInSpaceResponse");
	case SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpaceRequest:
		return soap_out_srm2__srmExtendFileLifeTimeInSpaceRequest(soap, tag, id, (const struct srm2__srmExtendFileLifeTimeInSpaceRequest *)ptr, "srm2:srmExtendFileLifeTimeInSpaceRequest");
	case SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequestResponse:
		return soap_out_srm2__srmStatusOfChangeSpaceForFilesRequestResponse(soap, tag, id, (const struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse *)ptr, "srm2:srmStatusOfChangeSpaceForFilesRequestResponse");
	case SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequestRequest:
		return soap_out_srm2__srmStatusOfChangeSpaceForFilesRequestRequest(soap, tag, id, (const struct srm2__srmStatusOfChangeSpaceForFilesRequestRequest *)ptr, "srm2:srmStatusOfChangeSpaceForFilesRequestRequest");
	case SOAP_TYPE_srm2__srmChangeSpaceForFilesResponse:
		return soap_out_srm2__srmChangeSpaceForFilesResponse(soap, tag, id, (const struct srm2__srmChangeSpaceForFilesResponse *)ptr, "srm2:srmChangeSpaceForFilesResponse");
	case SOAP_TYPE_srm2__srmChangeSpaceForFilesRequest:
		return soap_out_srm2__srmChangeSpaceForFilesRequest(soap, tag, id, (const struct srm2__srmChangeSpaceForFilesRequest *)ptr, "srm2:srmChangeSpaceForFilesRequest");
	case SOAP_TYPE_srm2__srmGetSpaceMetaDataResponse:
		return soap_out_srm2__srmGetSpaceMetaDataResponse(soap, tag, id, (const struct srm2__srmGetSpaceMetaDataResponse *)ptr, "srm2:srmGetSpaceMetaDataResponse");
	case SOAP_TYPE_srm2__srmGetSpaceMetaDataRequest:
		return soap_out_srm2__srmGetSpaceMetaDataRequest(soap, tag, id, (const struct srm2__srmGetSpaceMetaDataRequest *)ptr, "srm2:srmGetSpaceMetaDataRequest");
	case SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequestResponse:
		return soap_out_srm2__srmStatusOfUpdateSpaceRequestResponse(soap, tag, id, (const struct srm2__srmStatusOfUpdateSpaceRequestResponse *)ptr, "srm2:srmStatusOfUpdateSpaceRequestResponse");
	case SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequestRequest:
		return soap_out_srm2__srmStatusOfUpdateSpaceRequestRequest(soap, tag, id, (const struct srm2__srmStatusOfUpdateSpaceRequestRequest *)ptr, "srm2:srmStatusOfUpdateSpaceRequestRequest");
	case SOAP_TYPE_srm2__srmUpdateSpaceResponse:
		return soap_out_srm2__srmUpdateSpaceResponse(soap, tag, id, (const struct srm2__srmUpdateSpaceResponse *)ptr, "srm2:srmUpdateSpaceResponse");
	case SOAP_TYPE_srm2__srmUpdateSpaceRequest:
		return soap_out_srm2__srmUpdateSpaceRequest(soap, tag, id, (const struct srm2__srmUpdateSpaceRequest *)ptr, "srm2:srmUpdateSpaceRequest");
	case SOAP_TYPE_srm2__srmReleaseSpaceResponse:
		return soap_out_srm2__srmReleaseSpaceResponse(soap, tag, id, (const struct srm2__srmReleaseSpaceResponse *)ptr, "srm2:srmReleaseSpaceResponse");
	case SOAP_TYPE_srm2__srmReleaseSpaceRequest:
		return soap_out_srm2__srmReleaseSpaceRequest(soap, tag, id, (const struct srm2__srmReleaseSpaceRequest *)ptr, "srm2:srmReleaseSpaceRequest");
	case SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequestResponse:
		return soap_out_srm2__srmStatusOfReserveSpaceRequestResponse(soap, tag, id, (const struct srm2__srmStatusOfReserveSpaceRequestResponse *)ptr, "srm2:srmStatusOfReserveSpaceRequestResponse");
	case SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequestRequest:
		return soap_out_srm2__srmStatusOfReserveSpaceRequestRequest(soap, tag, id, (const struct srm2__srmStatusOfReserveSpaceRequestRequest *)ptr, "srm2:srmStatusOfReserveSpaceRequestRequest");
	case SOAP_TYPE_srm2__srmReserveSpaceResponse:
		return soap_out_srm2__srmReserveSpaceResponse(soap, tag, id, (const struct srm2__srmReserveSpaceResponse *)ptr, "srm2:srmReserveSpaceResponse");
	case SOAP_TYPE_srm2__srmReserveSpaceRequest:
		return soap_out_srm2__srmReserveSpaceRequest(soap, tag, id, (const struct srm2__srmReserveSpaceRequest *)ptr, "srm2:srmReserveSpaceRequest");
	case SOAP_TYPE_srm2__ArrayOfTSupportedTransferProtocol:
		return soap_out_srm2__ArrayOfTSupportedTransferProtocol(soap, tag, id, (const struct srm2__ArrayOfTSupportedTransferProtocol *)ptr, "srm2:ArrayOfTSupportedTransferProtocol");
	case SOAP_TYPE_srm2__TSupportedTransferProtocol:
		return soap_out_srm2__TSupportedTransferProtocol(soap, tag, id, (const struct srm2__TSupportedTransferProtocol *)ptr, "srm2:TSupportedTransferProtocol");
	case SOAP_TYPE_srm2__ArrayOfTRequestTokenReturn:
		return soap_out_srm2__ArrayOfTRequestTokenReturn(soap, tag, id, (const struct srm2__ArrayOfTRequestTokenReturn *)ptr, "srm2:ArrayOfTRequestTokenReturn");
	case SOAP_TYPE_srm2__TRequestTokenReturn:
		return soap_out_srm2__TRequestTokenReturn(soap, tag, id, (const struct srm2__TRequestTokenReturn *)ptr, "srm2:TRequestTokenReturn");
	case SOAP_TYPE_srm2__ArrayOfTPermissionReturn:
		return soap_out_srm2__ArrayOfTPermissionReturn(soap, tag, id, (const struct srm2__ArrayOfTPermissionReturn *)ptr, "srm2:ArrayOfTPermissionReturn");
	case SOAP_TYPE_srm2__TPermissionReturn:
		return soap_out_srm2__TPermissionReturn(soap, tag, id, (const struct srm2__TPermissionReturn *)ptr, "srm2:TPermissionReturn");
	case SOAP_TYPE_srm2__ArrayOfTSURLPermissionReturn:
		return soap_out_srm2__ArrayOfTSURLPermissionReturn(soap, tag, id, (const struct srm2__ArrayOfTSURLPermissionReturn *)ptr, "srm2:ArrayOfTSURLPermissionReturn");
	case SOAP_TYPE_srm2__TSURLPermissionReturn:
		return soap_out_srm2__TSURLPermissionReturn(soap, tag, id, (const struct srm2__TSURLPermissionReturn *)ptr, "srm2:TSURLPermissionReturn");
	case SOAP_TYPE_srm2__ArrayOfTRequestSummary:
		return soap_out_srm2__ArrayOfTRequestSummary(soap, tag, id, (const struct srm2__ArrayOfTRequestSummary *)ptr, "srm2:ArrayOfTRequestSummary");
	case SOAP_TYPE_srm2__TRequestSummary:
		return soap_out_srm2__TRequestSummary(soap, tag, id, (const struct srm2__TRequestSummary *)ptr, "srm2:TRequestSummary");
	case SOAP_TYPE_srm2__ArrayOfTCopyRequestFileStatus:
		return soap_out_srm2__ArrayOfTCopyRequestFileStatus(soap, tag, id, (const struct srm2__ArrayOfTCopyRequestFileStatus *)ptr, "srm2:ArrayOfTCopyRequestFileStatus");
	case SOAP_TYPE_srm2__TCopyRequestFileStatus:
		return soap_out_srm2__TCopyRequestFileStatus(soap, tag, id, (const struct srm2__TCopyRequestFileStatus *)ptr, "srm2:TCopyRequestFileStatus");
	case SOAP_TYPE_srm2__ArrayOfTPutRequestFileStatus:
		return soap_out_srm2__ArrayOfTPutRequestFileStatus(soap, tag, id, (const struct srm2__ArrayOfTPutRequestFileStatus *)ptr, "srm2:ArrayOfTPutRequestFileStatus");
	case SOAP_TYPE_srm2__TPutRequestFileStatus:
		return soap_out_srm2__TPutRequestFileStatus(soap, tag, id, (const struct srm2__TPutRequestFileStatus *)ptr, "srm2:TPutRequestFileStatus");
	case SOAP_TYPE_srm2__ArrayOfTBringOnlineRequestFileStatus:
		return soap_out_srm2__ArrayOfTBringOnlineRequestFileStatus(soap, tag, id, (const struct srm2__ArrayOfTBringOnlineRequestFileStatus *)ptr, "srm2:ArrayOfTBringOnlineRequestFileStatus");
	case SOAP_TYPE_srm2__TBringOnlineRequestFileStatus:
		return soap_out_srm2__TBringOnlineRequestFileStatus(soap, tag, id, (const struct srm2__TBringOnlineRequestFileStatus *)ptr, "srm2:TBringOnlineRequestFileStatus");
	case SOAP_TYPE_srm2__ArrayOfTGetRequestFileStatus:
		return soap_out_srm2__ArrayOfTGetRequestFileStatus(soap, tag, id, (const struct srm2__ArrayOfTGetRequestFileStatus *)ptr, "srm2:ArrayOfTGetRequestFileStatus");
	case SOAP_TYPE_srm2__TGetRequestFileStatus:
		return soap_out_srm2__TGetRequestFileStatus(soap, tag, id, (const struct srm2__TGetRequestFileStatus *)ptr, "srm2:TGetRequestFileStatus");
	case SOAP_TYPE_srm2__ArrayOfTCopyFileRequest:
		return soap_out_srm2__ArrayOfTCopyFileRequest(soap, tag, id, (const struct srm2__ArrayOfTCopyFileRequest *)ptr, "srm2:ArrayOfTCopyFileRequest");
	case SOAP_TYPE_srm2__TCopyFileRequest:
		return soap_out_srm2__TCopyFileRequest(soap, tag, id, (const struct srm2__TCopyFileRequest *)ptr, "srm2:TCopyFileRequest");
	case SOAP_TYPE_srm2__ArrayOfTPutFileRequest:
		return soap_out_srm2__ArrayOfTPutFileRequest(soap, tag, id, (const struct srm2__ArrayOfTPutFileRequest *)ptr, "srm2:ArrayOfTPutFileRequest");
	case SOAP_TYPE_srm2__TPutFileRequest:
		return soap_out_srm2__TPutFileRequest(soap, tag, id, (const struct srm2__TPutFileRequest *)ptr, "srm2:TPutFileRequest");
	case SOAP_TYPE_srm2__ArrayOfTGetFileRequest:
		return soap_out_srm2__ArrayOfTGetFileRequest(soap, tag, id, (const struct srm2__ArrayOfTGetFileRequest *)ptr, "srm2:ArrayOfTGetFileRequest");
	case SOAP_TYPE_srm2__TGetFileRequest:
		return soap_out_srm2__TGetFileRequest(soap, tag, id, (const struct srm2__TGetFileRequest *)ptr, "srm2:TGetFileRequest");
	case SOAP_TYPE_srm2__TTransferParameters:
		return soap_out_srm2__TTransferParameters(soap, tag, id, (const struct srm2__TTransferParameters *)ptr, "srm2:TTransferParameters");
	case SOAP_TYPE_srm2__ArrayOfAnyURI:
		return soap_out_srm2__ArrayOfAnyURI(soap, tag, id, (const struct srm2__ArrayOfAnyURI *)ptr, "srm2:ArrayOfAnyURI");
	case SOAP_TYPE_srm2__ArrayOfTExtraInfo:
		return soap_out_srm2__ArrayOfTExtraInfo(soap, tag, id, (const struct srm2__ArrayOfTExtraInfo *)ptr, "srm2:ArrayOfTExtraInfo");
	case SOAP_TYPE_srm2__TExtraInfo:
		return soap_out_srm2__TExtraInfo(soap, tag, id, (const struct srm2__TExtraInfo *)ptr, "srm2:TExtraInfo");
	case SOAP_TYPE_srm2__TDirOption:
		return soap_out_srm2__TDirOption(soap, tag, id, (const struct srm2__TDirOption *)ptr, "srm2:TDirOption");
	case SOAP_TYPE_srm2__ArrayOfTMetaDataSpace:
		return soap_out_srm2__ArrayOfTMetaDataSpace(soap, tag, id, (const struct srm2__ArrayOfTMetaDataSpace *)ptr, "srm2:ArrayOfTMetaDataSpace");
	case SOAP_TYPE_srm2__TMetaDataSpace:
		return soap_out_srm2__TMetaDataSpace(soap, tag, id, (const struct srm2__TMetaDataSpace *)ptr, "srm2:TMetaDataSpace");
	case SOAP_TYPE_srm2__ArrayOfTMetaDataPathDetail:
		return soap_out_srm2__ArrayOfTMetaDataPathDetail(soap, tag, id, (const struct srm2__ArrayOfTMetaDataPathDetail *)ptr, "srm2:ArrayOfTMetaDataPathDetail");
	case SOAP_TYPE_srm2__TMetaDataPathDetail:
		return soap_out_srm2__TMetaDataPathDetail(soap, tag, id, (const struct srm2__TMetaDataPathDetail *)ptr, "srm2:TMetaDataPathDetail");
	case SOAP_TYPE_srm2__ArrayOfTSURLLifetimeReturnStatus:
		return soap_out_srm2__ArrayOfTSURLLifetimeReturnStatus(soap, tag, id, (const struct srm2__ArrayOfTSURLLifetimeReturnStatus *)ptr, "srm2:ArrayOfTSURLLifetimeReturnStatus");
	case SOAP_TYPE_srm2__TSURLLifetimeReturnStatus:
		return soap_out_srm2__TSURLLifetimeReturnStatus(soap, tag, id, (const struct srm2__TSURLLifetimeReturnStatus *)ptr, "srm2:TSURLLifetimeReturnStatus");
	case SOAP_TYPE_srm2__ArrayOfTSURLReturnStatus:
		return soap_out_srm2__ArrayOfTSURLReturnStatus(soap, tag, id, (const struct srm2__ArrayOfTSURLReturnStatus *)ptr, "srm2:ArrayOfTSURLReturnStatus");
	case SOAP_TYPE_srm2__TSURLReturnStatus:
		return soap_out_srm2__TSURLReturnStatus(soap, tag, id, (const struct srm2__TSURLReturnStatus *)ptr, "srm2:TSURLReturnStatus");
	case SOAP_TYPE_srm2__TReturnStatus:
		return soap_out_srm2__TReturnStatus(soap, tag, id, (const struct srm2__TReturnStatus *)ptr, "srm2:TReturnStatus");
	case SOAP_TYPE_srm2__ArrayOfString:
		return soap_out_srm2__ArrayOfString(soap, tag, id, (const struct srm2__ArrayOfString *)ptr, "srm2:ArrayOfString");
	case SOAP_TYPE_srm2__ArrayOfUnsignedLong:
		return soap_out_srm2__ArrayOfUnsignedLong(soap, tag, id, (const struct srm2__ArrayOfUnsignedLong *)ptr, "srm2:ArrayOfUnsignedLong");
	case SOAP_TYPE_srm2__ArrayOfTGroupPermission:
		return soap_out_srm2__ArrayOfTGroupPermission(soap, tag, id, (const struct srm2__ArrayOfTGroupPermission *)ptr, "srm2:ArrayOfTGroupPermission");
	case SOAP_TYPE_srm2__TGroupPermission:
		return soap_out_srm2__TGroupPermission(soap, tag, id, (const struct srm2__TGroupPermission *)ptr, "srm2:TGroupPermission");
	case SOAP_TYPE_srm2__ArrayOfTUserPermission:
		return soap_out_srm2__ArrayOfTUserPermission(soap, tag, id, (const struct srm2__ArrayOfTUserPermission *)ptr, "srm2:ArrayOfTUserPermission");
	case SOAP_TYPE_srm2__TUserPermission:
		return soap_out_srm2__TUserPermission(soap, tag, id, (const struct srm2__TUserPermission *)ptr, "srm2:TUserPermission");
	case SOAP_TYPE_srm2__TRetentionPolicyInfo:
		return soap_out_srm2__TRetentionPolicyInfo(soap, tag, id, (const struct srm2__TRetentionPolicyInfo *)ptr, "srm2:TRetentionPolicyInfo");
	case SOAP_TYPE_PointerToSOAP_ENV__Reason:
		return soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, (struct SOAP_ENV__Reason *const*)ptr, "SOAP-ENV:Reason");
	case SOAP_TYPE_PointerTosrm2__srmPingResponse_:
		return soap_out_PointerTosrm2__srmPingResponse_(soap, tag, id, (struct srm2__srmPingResponse_ *const*)ptr, "srm2:srmPingResponse");
	case SOAP_TYPE_PointerTosrm2__srmPingRequest:
		return soap_out_PointerTosrm2__srmPingRequest(soap, tag, id, (struct srm2__srmPingRequest *const*)ptr, "srm2:srmPingRequest");
	case SOAP_TYPE_PointerTosrm2__srmPingResponse:
		return soap_out_PointerTosrm2__srmPingResponse(soap, tag, id, (struct srm2__srmPingResponse *const*)ptr, "srm2:srmPingResponse");
	case SOAP_TYPE_PointerTosrm2__srmGetTransferProtocolsResponse_:
		return soap_out_PointerTosrm2__srmGetTransferProtocolsResponse_(soap, tag, id, (struct srm2__srmGetTransferProtocolsResponse_ *const*)ptr, "srm2:srmGetTransferProtocolsResponse");
	case SOAP_TYPE_PointerTosrm2__srmGetTransferProtocolsRequest:
		return soap_out_PointerTosrm2__srmGetTransferProtocolsRequest(soap, tag, id, (struct srm2__srmGetTransferProtocolsRequest *const*)ptr, "srm2:srmGetTransferProtocolsRequest");
	case SOAP_TYPE_PointerTosrm2__srmGetTransferProtocolsResponse:
		return soap_out_PointerTosrm2__srmGetTransferProtocolsResponse(soap, tag, id, (struct srm2__srmGetTransferProtocolsResponse *const*)ptr, "srm2:srmGetTransferProtocolsResponse");
	case SOAP_TYPE_PointerTosrm2__srmGetRequestTokensResponse_:
		return soap_out_PointerTosrm2__srmGetRequestTokensResponse_(soap, tag, id, (struct srm2__srmGetRequestTokensResponse_ *const*)ptr, "srm2:srmGetRequestTokensResponse");
	case SOAP_TYPE_PointerTosrm2__srmGetRequestTokensRequest:
		return soap_out_PointerTosrm2__srmGetRequestTokensRequest(soap, tag, id, (struct srm2__srmGetRequestTokensRequest *const*)ptr, "srm2:srmGetRequestTokensRequest");
	case SOAP_TYPE_PointerTosrm2__srmGetRequestTokensResponse:
		return soap_out_PointerTosrm2__srmGetRequestTokensResponse(soap, tag, id, (struct srm2__srmGetRequestTokensResponse *const*)ptr, "srm2:srmGetRequestTokensResponse");
	case SOAP_TYPE_PointerTosrm2__srmExtendFileLifeTimeResponse_:
		return soap_out_PointerTosrm2__srmExtendFileLifeTimeResponse_(soap, tag, id, (struct srm2__srmExtendFileLifeTimeResponse_ *const*)ptr, "srm2:srmExtendFileLifeTimeResponse");
	case SOAP_TYPE_PointerTosrm2__srmExtendFileLifeTimeRequest:
		return soap_out_PointerTosrm2__srmExtendFileLifeTimeRequest(soap, tag, id, (struct srm2__srmExtendFileLifeTimeRequest *const*)ptr, "srm2:srmExtendFileLifeTimeRequest");
	case SOAP_TYPE_PointerTosrm2__srmExtendFileLifeTimeResponse:
		return soap_out_PointerTosrm2__srmExtendFileLifeTimeResponse(soap, tag, id, (struct srm2__srmExtendFileLifeTimeResponse *const*)ptr, "srm2:srmExtendFileLifeTimeResponse");
	case SOAP_TYPE_PointerTosrm2__srmGetRequestSummaryResponse_:
		return soap_out_PointerTosrm2__srmGetRequestSummaryResponse_(soap, tag, id, (struct srm2__srmGetRequestSummaryResponse_ *const*)ptr, "srm2:srmGetRequestSummaryResponse");
	case SOAP_TYPE_PointerTosrm2__srmGetRequestSummaryRequest:
		return soap_out_PointerTosrm2__srmGetRequestSummaryRequest(soap, tag, id, (struct srm2__srmGetRequestSummaryRequest *const*)ptr, "srm2:srmGetRequestSummaryRequest");
	case SOAP_TYPE_PointerTosrm2__srmGetRequestSummaryResponse:
		return soap_out_PointerTosrm2__srmGetRequestSummaryResponse(soap, tag, id, (struct srm2__srmGetRequestSummaryResponse *const*)ptr, "srm2:srmGetRequestSummaryResponse");
	case SOAP_TYPE_PointerTosrm2__srmResumeRequestResponse_:
		return soap_out_PointerTosrm2__srmResumeRequestResponse_(soap, tag, id, (struct srm2__srmResumeRequestResponse_ *const*)ptr, "srm2:srmResumeRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmResumeRequestRequest:
		return soap_out_PointerTosrm2__srmResumeRequestRequest(soap, tag, id, (struct srm2__srmResumeRequestRequest *const*)ptr, "srm2:srmResumeRequestRequest");
	case SOAP_TYPE_PointerTosrm2__srmResumeRequestResponse:
		return soap_out_PointerTosrm2__srmResumeRequestResponse(soap, tag, id, (struct srm2__srmResumeRequestResponse *const*)ptr, "srm2:srmResumeRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmSuspendRequestResponse_:
		return soap_out_PointerTosrm2__srmSuspendRequestResponse_(soap, tag, id, (struct srm2__srmSuspendRequestResponse_ *const*)ptr, "srm2:srmSuspendRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmSuspendRequestRequest:
		return soap_out_PointerTosrm2__srmSuspendRequestRequest(soap, tag, id, (struct srm2__srmSuspendRequestRequest *const*)ptr, "srm2:srmSuspendRequestRequest");
	case SOAP_TYPE_PointerTosrm2__srmSuspendRequestResponse:
		return soap_out_PointerTosrm2__srmSuspendRequestResponse(soap, tag, id, (struct srm2__srmSuspendRequestResponse *const*)ptr, "srm2:srmSuspendRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmAbortFilesResponse_:
		return soap_out_PointerTosrm2__srmAbortFilesResponse_(soap, tag, id, (struct srm2__srmAbortFilesResponse_ *const*)ptr, "srm2:srmAbortFilesResponse");
	case SOAP_TYPE_PointerTosrm2__srmAbortFilesRequest:
		return soap_out_PointerTosrm2__srmAbortFilesRequest(soap, tag, id, (struct srm2__srmAbortFilesRequest *const*)ptr, "srm2:srmAbortFilesRequest");
	case SOAP_TYPE_PointerTosrm2__srmAbortFilesResponse:
		return soap_out_PointerTosrm2__srmAbortFilesResponse(soap, tag, id, (struct srm2__srmAbortFilesResponse *const*)ptr, "srm2:srmAbortFilesResponse");
	case SOAP_TYPE_PointerTosrm2__srmAbortRequestResponse_:
		return soap_out_PointerTosrm2__srmAbortRequestResponse_(soap, tag, id, (struct srm2__srmAbortRequestResponse_ *const*)ptr, "srm2:srmAbortRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmAbortRequestRequest:
		return soap_out_PointerTosrm2__srmAbortRequestRequest(soap, tag, id, (struct srm2__srmAbortRequestRequest *const*)ptr, "srm2:srmAbortRequestRequest");
	case SOAP_TYPE_PointerTosrm2__srmAbortRequestResponse:
		return soap_out_PointerTosrm2__srmAbortRequestResponse(soap, tag, id, (struct srm2__srmAbortRequestResponse *const*)ptr, "srm2:srmAbortRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmPutDoneResponse_:
		return soap_out_PointerTosrm2__srmPutDoneResponse_(soap, tag, id, (struct srm2__srmPutDoneResponse_ *const*)ptr, "srm2:srmPutDoneResponse");
	case SOAP_TYPE_PointerTosrm2__srmPutDoneRequest:
		return soap_out_PointerTosrm2__srmPutDoneRequest(soap, tag, id, (struct srm2__srmPutDoneRequest *const*)ptr, "srm2:srmPutDoneRequest");
	case SOAP_TYPE_PointerTosrm2__srmPutDoneResponse:
		return soap_out_PointerTosrm2__srmPutDoneResponse(soap, tag, id, (struct srm2__srmPutDoneResponse *const*)ptr, "srm2:srmPutDoneResponse");
	case SOAP_TYPE_PointerTosrm2__srmReleaseFilesResponse_:
		return soap_out_PointerTosrm2__srmReleaseFilesResponse_(soap, tag, id, (struct srm2__srmReleaseFilesResponse_ *const*)ptr, "srm2:srmReleaseFilesResponse");
	case SOAP_TYPE_PointerTosrm2__srmReleaseFilesRequest:
		return soap_out_PointerTosrm2__srmReleaseFilesRequest(soap, tag, id, (struct srm2__srmReleaseFilesRequest *const*)ptr, "srm2:srmReleaseFilesRequest");
	case SOAP_TYPE_PointerTosrm2__srmReleaseFilesResponse:
		return soap_out_PointerTosrm2__srmReleaseFilesResponse(soap, tag, id, (struct srm2__srmReleaseFilesResponse *const*)ptr, "srm2:srmReleaseFilesResponse");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfCopyRequestResponse_:
		return soap_out_PointerTosrm2__srmStatusOfCopyRequestResponse_(soap, tag, id, (struct srm2__srmStatusOfCopyRequestResponse_ *const*)ptr, "srm2:srmStatusOfCopyRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfCopyRequestRequest:
		return soap_out_PointerTosrm2__srmStatusOfCopyRequestRequest(soap, tag, id, (struct srm2__srmStatusOfCopyRequestRequest *const*)ptr, "srm2:srmStatusOfCopyRequestRequest");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfCopyRequestResponse:
		return soap_out_PointerTosrm2__srmStatusOfCopyRequestResponse(soap, tag, id, (struct srm2__srmStatusOfCopyRequestResponse *const*)ptr, "srm2:srmStatusOfCopyRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmCopyResponse_:
		return soap_out_PointerTosrm2__srmCopyResponse_(soap, tag, id, (struct srm2__srmCopyResponse_ *const*)ptr, "srm2:srmCopyResponse");
	case SOAP_TYPE_PointerTosrm2__srmCopyRequest:
		return soap_out_PointerTosrm2__srmCopyRequest(soap, tag, id, (struct srm2__srmCopyRequest *const*)ptr, "srm2:srmCopyRequest");
	case SOAP_TYPE_PointerTosrm2__srmCopyResponse:
		return soap_out_PointerTosrm2__srmCopyResponse(soap, tag, id, (struct srm2__srmCopyResponse *const*)ptr, "srm2:srmCopyResponse");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfPutRequestResponse_:
		return soap_out_PointerTosrm2__srmStatusOfPutRequestResponse_(soap, tag, id, (struct srm2__srmStatusOfPutRequestResponse_ *const*)ptr, "srm2:srmStatusOfPutRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfPutRequestRequest:
		return soap_out_PointerTosrm2__srmStatusOfPutRequestRequest(soap, tag, id, (struct srm2__srmStatusOfPutRequestRequest *const*)ptr, "srm2:srmStatusOfPutRequestRequest");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfPutRequestResponse:
		return soap_out_PointerTosrm2__srmStatusOfPutRequestResponse(soap, tag, id, (struct srm2__srmStatusOfPutRequestResponse *const*)ptr, "srm2:srmStatusOfPutRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmPrepareToPutResponse_:
		return soap_out_PointerTosrm2__srmPrepareToPutResponse_(soap, tag, id, (struct srm2__srmPrepareToPutResponse_ *const*)ptr, "srm2:srmPrepareToPutResponse");
	case SOAP_TYPE_PointerTosrm2__srmPrepareToPutRequest:
		return soap_out_PointerTosrm2__srmPrepareToPutRequest(soap, tag, id, (struct srm2__srmPrepareToPutRequest *const*)ptr, "srm2:srmPrepareToPutRequest");
	case SOAP_TYPE_PointerTosrm2__srmPrepareToPutResponse:
		return soap_out_PointerTosrm2__srmPrepareToPutResponse(soap, tag, id, (struct srm2__srmPrepareToPutResponse *const*)ptr, "srm2:srmPrepareToPutResponse");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfBringOnlineRequestResponse_:
		return soap_out_PointerTosrm2__srmStatusOfBringOnlineRequestResponse_(soap, tag, id, (struct srm2__srmStatusOfBringOnlineRequestResponse_ *const*)ptr, "srm2:srmStatusOfBringOnlineRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfBringOnlineRequestRequest:
		return soap_out_PointerTosrm2__srmStatusOfBringOnlineRequestRequest(soap, tag, id, (struct srm2__srmStatusOfBringOnlineRequestRequest *const*)ptr, "srm2:srmStatusOfBringOnlineRequestRequest");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfBringOnlineRequestResponse:
		return soap_out_PointerTosrm2__srmStatusOfBringOnlineRequestResponse(soap, tag, id, (struct srm2__srmStatusOfBringOnlineRequestResponse *const*)ptr, "srm2:srmStatusOfBringOnlineRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmBringOnlineResponse_:
		return soap_out_PointerTosrm2__srmBringOnlineResponse_(soap, tag, id, (struct srm2__srmBringOnlineResponse_ *const*)ptr, "srm2:srmBringOnlineResponse");
	case SOAP_TYPE_PointerTosrm2__srmBringOnlineRequest:
		return soap_out_PointerTosrm2__srmBringOnlineRequest(soap, tag, id, (struct srm2__srmBringOnlineRequest *const*)ptr, "srm2:srmBringOnlineRequest");
	case SOAP_TYPE_PointerTosrm2__srmBringOnlineResponse:
		return soap_out_PointerTosrm2__srmBringOnlineResponse(soap, tag, id, (struct srm2__srmBringOnlineResponse *const*)ptr, "srm2:srmBringOnlineResponse");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfGetRequestResponse_:
		return soap_out_PointerTosrm2__srmStatusOfGetRequestResponse_(soap, tag, id, (struct srm2__srmStatusOfGetRequestResponse_ *const*)ptr, "srm2:srmStatusOfGetRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfGetRequestRequest:
		return soap_out_PointerTosrm2__srmStatusOfGetRequestRequest(soap, tag, id, (struct srm2__srmStatusOfGetRequestRequest *const*)ptr, "srm2:srmStatusOfGetRequestRequest");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfGetRequestResponse:
		return soap_out_PointerTosrm2__srmStatusOfGetRequestResponse(soap, tag, id, (struct srm2__srmStatusOfGetRequestResponse *const*)ptr, "srm2:srmStatusOfGetRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmPrepareToGetResponse_:
		return soap_out_PointerTosrm2__srmPrepareToGetResponse_(soap, tag, id, (struct srm2__srmPrepareToGetResponse_ *const*)ptr, "srm2:srmPrepareToGetResponse");
	case SOAP_TYPE_PointerTosrm2__srmPrepareToGetRequest:
		return soap_out_PointerTosrm2__srmPrepareToGetRequest(soap, tag, id, (struct srm2__srmPrepareToGetRequest *const*)ptr, "srm2:srmPrepareToGetRequest");
	case SOAP_TYPE_PointerTosrm2__srmPrepareToGetResponse:
		return soap_out_PointerTosrm2__srmPrepareToGetResponse(soap, tag, id, (struct srm2__srmPrepareToGetResponse *const*)ptr, "srm2:srmPrepareToGetResponse");
	case SOAP_TYPE_PointerTosrm2__srmMvResponse_:
		return soap_out_PointerTosrm2__srmMvResponse_(soap, tag, id, (struct srm2__srmMvResponse_ *const*)ptr, "srm2:srmMvResponse");
	case SOAP_TYPE_PointerTosrm2__srmMvRequest:
		return soap_out_PointerTosrm2__srmMvRequest(soap, tag, id, (struct srm2__srmMvRequest *const*)ptr, "srm2:srmMvRequest");
	case SOAP_TYPE_PointerTosrm2__srmMvResponse:
		return soap_out_PointerTosrm2__srmMvResponse(soap, tag, id, (struct srm2__srmMvResponse *const*)ptr, "srm2:srmMvResponse");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfLsRequestResponse_:
		return soap_out_PointerTosrm2__srmStatusOfLsRequestResponse_(soap, tag, id, (struct srm2__srmStatusOfLsRequestResponse_ *const*)ptr, "srm2:srmStatusOfLsRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfLsRequestRequest:
		return soap_out_PointerTosrm2__srmStatusOfLsRequestRequest(soap, tag, id, (struct srm2__srmStatusOfLsRequestRequest *const*)ptr, "srm2:srmStatusOfLsRequestRequest");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfLsRequestResponse:
		return soap_out_PointerTosrm2__srmStatusOfLsRequestResponse(soap, tag, id, (struct srm2__srmStatusOfLsRequestResponse *const*)ptr, "srm2:srmStatusOfLsRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmLsResponse_:
		return soap_out_PointerTosrm2__srmLsResponse_(soap, tag, id, (struct srm2__srmLsResponse_ *const*)ptr, "srm2:srmLsResponse");
	case SOAP_TYPE_PointerTosrm2__srmLsRequest:
		return soap_out_PointerTosrm2__srmLsRequest(soap, tag, id, (struct srm2__srmLsRequest *const*)ptr, "srm2:srmLsRequest");
	case SOAP_TYPE_PointerTosrm2__srmLsResponse:
		return soap_out_PointerTosrm2__srmLsResponse(soap, tag, id, (struct srm2__srmLsResponse *const*)ptr, "srm2:srmLsResponse");
	case SOAP_TYPE_PointerTosrm2__srmRmResponse_:
		return soap_out_PointerTosrm2__srmRmResponse_(soap, tag, id, (struct srm2__srmRmResponse_ *const*)ptr, "srm2:srmRmResponse");
	case SOAP_TYPE_PointerTosrm2__srmRmRequest:
		return soap_out_PointerTosrm2__srmRmRequest(soap, tag, id, (struct srm2__srmRmRequest *const*)ptr, "srm2:srmRmRequest");
	case SOAP_TYPE_PointerTosrm2__srmRmResponse:
		return soap_out_PointerTosrm2__srmRmResponse(soap, tag, id, (struct srm2__srmRmResponse *const*)ptr, "srm2:srmRmResponse");
	case SOAP_TYPE_PointerTosrm2__srmRmdirResponse_:
		return soap_out_PointerTosrm2__srmRmdirResponse_(soap, tag, id, (struct srm2__srmRmdirResponse_ *const*)ptr, "srm2:srmRmdirResponse");
	case SOAP_TYPE_PointerTosrm2__srmRmdirRequest:
		return soap_out_PointerTosrm2__srmRmdirRequest(soap, tag, id, (struct srm2__srmRmdirRequest *const*)ptr, "srm2:srmRmdirRequest");
	case SOAP_TYPE_PointerTosrm2__srmRmdirResponse:
		return soap_out_PointerTosrm2__srmRmdirResponse(soap, tag, id, (struct srm2__srmRmdirResponse *const*)ptr, "srm2:srmRmdirResponse");
	case SOAP_TYPE_PointerTosrm2__srmMkdirResponse_:
		return soap_out_PointerTosrm2__srmMkdirResponse_(soap, tag, id, (struct srm2__srmMkdirResponse_ *const*)ptr, "srm2:srmMkdirResponse");
	case SOAP_TYPE_PointerTosrm2__srmMkdirRequest:
		return soap_out_PointerTosrm2__srmMkdirRequest(soap, tag, id, (struct srm2__srmMkdirRequest *const*)ptr, "srm2:srmMkdirRequest");
	case SOAP_TYPE_PointerTosrm2__srmMkdirResponse:
		return soap_out_PointerTosrm2__srmMkdirResponse(soap, tag, id, (struct srm2__srmMkdirResponse *const*)ptr, "srm2:srmMkdirResponse");
	case SOAP_TYPE_PointerTosrm2__srmGetPermissionResponse_:
		return soap_out_PointerTosrm2__srmGetPermissionResponse_(soap, tag, id, (struct srm2__srmGetPermissionResponse_ *const*)ptr, "srm2:srmGetPermissionResponse");
	case SOAP_TYPE_PointerTosrm2__srmGetPermissionRequest:
		return soap_out_PointerTosrm2__srmGetPermissionRequest(soap, tag, id, (struct srm2__srmGetPermissionRequest *const*)ptr, "srm2:srmGetPermissionRequest");
	case SOAP_TYPE_PointerTosrm2__srmGetPermissionResponse:
		return soap_out_PointerTosrm2__srmGetPermissionResponse(soap, tag, id, (struct srm2__srmGetPermissionResponse *const*)ptr, "srm2:srmGetPermissionResponse");
	case SOAP_TYPE_PointerTosrm2__srmCheckPermissionResponse_:
		return soap_out_PointerTosrm2__srmCheckPermissionResponse_(soap, tag, id, (struct srm2__srmCheckPermissionResponse_ *const*)ptr, "srm2:srmCheckPermissionResponse");
	case SOAP_TYPE_PointerTosrm2__srmCheckPermissionRequest:
		return soap_out_PointerTosrm2__srmCheckPermissionRequest(soap, tag, id, (struct srm2__srmCheckPermissionRequest *const*)ptr, "srm2:srmCheckPermissionRequest");
	case SOAP_TYPE_PointerTosrm2__srmCheckPermissionResponse:
		return soap_out_PointerTosrm2__srmCheckPermissionResponse(soap, tag, id, (struct srm2__srmCheckPermissionResponse *const*)ptr, "srm2:srmCheckPermissionResponse");
	case SOAP_TYPE_PointerTosrm2__srmSetPermissionResponse_:
		return soap_out_PointerTosrm2__srmSetPermissionResponse_(soap, tag, id, (struct srm2__srmSetPermissionResponse_ *const*)ptr, "srm2:srmSetPermissionResponse");
	case SOAP_TYPE_PointerTosrm2__srmSetPermissionRequest:
		return soap_out_PointerTosrm2__srmSetPermissionRequest(soap, tag, id, (struct srm2__srmSetPermissionRequest *const*)ptr, "srm2:srmSetPermissionRequest");
	case SOAP_TYPE_PointerTosrm2__srmSetPermissionResponse:
		return soap_out_PointerTosrm2__srmSetPermissionResponse(soap, tag, id, (struct srm2__srmSetPermissionResponse *const*)ptr, "srm2:srmSetPermissionResponse");
	case SOAP_TYPE_PointerTosrm2__srmGetSpaceTokensResponse_:
		return soap_out_PointerTosrm2__srmGetSpaceTokensResponse_(soap, tag, id, (struct srm2__srmGetSpaceTokensResponse_ *const*)ptr, "srm2:srmGetSpaceTokensResponse");
	case SOAP_TYPE_PointerTosrm2__srmGetSpaceTokensRequest:
		return soap_out_PointerTosrm2__srmGetSpaceTokensRequest(soap, tag, id, (struct srm2__srmGetSpaceTokensRequest *const*)ptr, "srm2:srmGetSpaceTokensRequest");
	case SOAP_TYPE_PointerTosrm2__srmGetSpaceTokensResponse:
		return soap_out_PointerTosrm2__srmGetSpaceTokensResponse(soap, tag, id, (struct srm2__srmGetSpaceTokensResponse *const*)ptr, "srm2:srmGetSpaceTokensResponse");
	case SOAP_TYPE_PointerTosrm2__srmPurgeFromSpaceResponse_:
		return soap_out_PointerTosrm2__srmPurgeFromSpaceResponse_(soap, tag, id, (struct srm2__srmPurgeFromSpaceResponse_ *const*)ptr, "srm2:srmPurgeFromSpaceResponse");
	case SOAP_TYPE_PointerTosrm2__srmPurgeFromSpaceRequest:
		return soap_out_PointerTosrm2__srmPurgeFromSpaceRequest(soap, tag, id, (struct srm2__srmPurgeFromSpaceRequest *const*)ptr, "srm2:srmPurgeFromSpaceRequest");
	case SOAP_TYPE_PointerTosrm2__srmPurgeFromSpaceResponse:
		return soap_out_PointerTosrm2__srmPurgeFromSpaceResponse(soap, tag, id, (struct srm2__srmPurgeFromSpaceResponse *const*)ptr, "srm2:srmPurgeFromSpaceResponse");
	case SOAP_TYPE_PointerTosrm2__srmExtendFileLifeTimeInSpaceResponse_:
		return soap_out_PointerTosrm2__srmExtendFileLifeTimeInSpaceResponse_(soap, tag, id, (struct srm2__srmExtendFileLifeTimeInSpaceResponse_ *const*)ptr, "srm2:srmExtendFileLifeTimeInSpaceResponse");
	case SOAP_TYPE_PointerTosrm2__srmExtendFileLifeTimeInSpaceRequest:
		return soap_out_PointerTosrm2__srmExtendFileLifeTimeInSpaceRequest(soap, tag, id, (struct srm2__srmExtendFileLifeTimeInSpaceRequest *const*)ptr, "srm2:srmExtendFileLifeTimeInSpaceRequest");
	case SOAP_TYPE_PointerTosrm2__srmExtendFileLifeTimeInSpaceResponse:
		return soap_out_PointerTosrm2__srmExtendFileLifeTimeInSpaceResponse(soap, tag, id, (struct srm2__srmExtendFileLifeTimeInSpaceResponse *const*)ptr, "srm2:srmExtendFileLifeTimeInSpaceResponse");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestResponse_:
		return soap_out_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestResponse_(soap, tag, id, (struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse_ *const*)ptr, "srm2:srmStatusOfChangeSpaceForFilesRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestRequest:
		return soap_out_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestRequest(soap, tag, id, (struct srm2__srmStatusOfChangeSpaceForFilesRequestRequest *const*)ptr, "srm2:srmStatusOfChangeSpaceForFilesRequestRequest");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestResponse:
		return soap_out_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestResponse(soap, tag, id, (struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse *const*)ptr, "srm2:srmStatusOfChangeSpaceForFilesRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmChangeSpaceForFilesResponse_:
		return soap_out_PointerTosrm2__srmChangeSpaceForFilesResponse_(soap, tag, id, (struct srm2__srmChangeSpaceForFilesResponse_ *const*)ptr, "srm2:srmChangeSpaceForFilesResponse");
	case SOAP_TYPE_PointerTosrm2__srmChangeSpaceForFilesRequest:
		return soap_out_PointerTosrm2__srmChangeSpaceForFilesRequest(soap, tag, id, (struct srm2__srmChangeSpaceForFilesRequest *const*)ptr, "srm2:srmChangeSpaceForFilesRequest");
	case SOAP_TYPE_PointerTosrm2__srmChangeSpaceForFilesResponse:
		return soap_out_PointerTosrm2__srmChangeSpaceForFilesResponse(soap, tag, id, (struct srm2__srmChangeSpaceForFilesResponse *const*)ptr, "srm2:srmChangeSpaceForFilesResponse");
	case SOAP_TYPE_PointerTosrm2__srmGetSpaceMetaDataResponse_:
		return soap_out_PointerTosrm2__srmGetSpaceMetaDataResponse_(soap, tag, id, (struct srm2__srmGetSpaceMetaDataResponse_ *const*)ptr, "srm2:srmGetSpaceMetaDataResponse");
	case SOAP_TYPE_PointerTosrm2__srmGetSpaceMetaDataRequest:
		return soap_out_PointerTosrm2__srmGetSpaceMetaDataRequest(soap, tag, id, (struct srm2__srmGetSpaceMetaDataRequest *const*)ptr, "srm2:srmGetSpaceMetaDataRequest");
	case SOAP_TYPE_PointerTosrm2__srmGetSpaceMetaDataResponse:
		return soap_out_PointerTosrm2__srmGetSpaceMetaDataResponse(soap, tag, id, (struct srm2__srmGetSpaceMetaDataResponse *const*)ptr, "srm2:srmGetSpaceMetaDataResponse");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfUpdateSpaceRequestResponse_:
		return soap_out_PointerTosrm2__srmStatusOfUpdateSpaceRequestResponse_(soap, tag, id, (struct srm2__srmStatusOfUpdateSpaceRequestResponse_ *const*)ptr, "srm2:srmStatusOfUpdateSpaceRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfUpdateSpaceRequestRequest:
		return soap_out_PointerTosrm2__srmStatusOfUpdateSpaceRequestRequest(soap, tag, id, (struct srm2__srmStatusOfUpdateSpaceRequestRequest *const*)ptr, "srm2:srmStatusOfUpdateSpaceRequestRequest");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfUpdateSpaceRequestResponse:
		return soap_out_PointerTosrm2__srmStatusOfUpdateSpaceRequestResponse(soap, tag, id, (struct srm2__srmStatusOfUpdateSpaceRequestResponse *const*)ptr, "srm2:srmStatusOfUpdateSpaceRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmUpdateSpaceResponse_:
		return soap_out_PointerTosrm2__srmUpdateSpaceResponse_(soap, tag, id, (struct srm2__srmUpdateSpaceResponse_ *const*)ptr, "srm2:srmUpdateSpaceResponse");
	case SOAP_TYPE_PointerTosrm2__srmUpdateSpaceRequest:
		return soap_out_PointerTosrm2__srmUpdateSpaceRequest(soap, tag, id, (struct srm2__srmUpdateSpaceRequest *const*)ptr, "srm2:srmUpdateSpaceRequest");
	case SOAP_TYPE_PointerTosrm2__srmUpdateSpaceResponse:
		return soap_out_PointerTosrm2__srmUpdateSpaceResponse(soap, tag, id, (struct srm2__srmUpdateSpaceResponse *const*)ptr, "srm2:srmUpdateSpaceResponse");
	case SOAP_TYPE_PointerTosrm2__srmReleaseSpaceResponse_:
		return soap_out_PointerTosrm2__srmReleaseSpaceResponse_(soap, tag, id, (struct srm2__srmReleaseSpaceResponse_ *const*)ptr, "srm2:srmReleaseSpaceResponse");
	case SOAP_TYPE_PointerTosrm2__srmReleaseSpaceRequest:
		return soap_out_PointerTosrm2__srmReleaseSpaceRequest(soap, tag, id, (struct srm2__srmReleaseSpaceRequest *const*)ptr, "srm2:srmReleaseSpaceRequest");
	case SOAP_TYPE_PointerTosrm2__srmReleaseSpaceResponse:
		return soap_out_PointerTosrm2__srmReleaseSpaceResponse(soap, tag, id, (struct srm2__srmReleaseSpaceResponse *const*)ptr, "srm2:srmReleaseSpaceResponse");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfReserveSpaceRequestResponse_:
		return soap_out_PointerTosrm2__srmStatusOfReserveSpaceRequestResponse_(soap, tag, id, (struct srm2__srmStatusOfReserveSpaceRequestResponse_ *const*)ptr, "srm2:srmStatusOfReserveSpaceRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfReserveSpaceRequestRequest:
		return soap_out_PointerTosrm2__srmStatusOfReserveSpaceRequestRequest(soap, tag, id, (struct srm2__srmStatusOfReserveSpaceRequestRequest *const*)ptr, "srm2:srmStatusOfReserveSpaceRequestRequest");
	case SOAP_TYPE_PointerTosrm2__srmStatusOfReserveSpaceRequestResponse:
		return soap_out_PointerTosrm2__srmStatusOfReserveSpaceRequestResponse(soap, tag, id, (struct srm2__srmStatusOfReserveSpaceRequestResponse *const*)ptr, "srm2:srmStatusOfReserveSpaceRequestResponse");
	case SOAP_TYPE_PointerTosrm2__srmReserveSpaceResponse_:
		return soap_out_PointerTosrm2__srmReserveSpaceResponse_(soap, tag, id, (struct srm2__srmReserveSpaceResponse_ *const*)ptr, "srm2:srmReserveSpaceResponse");
	case SOAP_TYPE_PointerTosrm2__srmReserveSpaceRequest:
		return soap_out_PointerTosrm2__srmReserveSpaceRequest(soap, tag, id, (struct srm2__srmReserveSpaceRequest *const*)ptr, "srm2:srmReserveSpaceRequest");
	case SOAP_TYPE_PointerTosrm2__srmReserveSpaceResponse:
		return soap_out_PointerTosrm2__srmReserveSpaceResponse(soap, tag, id, (struct srm2__srmReserveSpaceResponse *const*)ptr, "srm2:srmReserveSpaceResponse");
	case SOAP_TYPE_PointerTosrm2__ArrayOfTSupportedTransferProtocol:
		return soap_out_PointerTosrm2__ArrayOfTSupportedTransferProtocol(soap, tag, id, (struct srm2__ArrayOfTSupportedTransferProtocol *const*)ptr, "srm2:ArrayOfTSupportedTransferProtocol");
	case SOAP_TYPE_PointerTosrm2__ArrayOfTRequestTokenReturn:
		return soap_out_PointerTosrm2__ArrayOfTRequestTokenReturn(soap, tag, id, (struct srm2__ArrayOfTRequestTokenReturn *const*)ptr, "srm2:ArrayOfTRequestTokenReturn");
	case SOAP_TYPE_PointerTosrm2__ArrayOfTRequestSummary:
		return soap_out_PointerTosrm2__ArrayOfTRequestSummary(soap, tag, id, (struct srm2__ArrayOfTRequestSummary *const*)ptr, "srm2:ArrayOfTRequestSummary");
	case SOAP_TYPE_PointerTosrm2__ArrayOfTCopyRequestFileStatus:
		return soap_out_PointerTosrm2__ArrayOfTCopyRequestFileStatus(soap, tag, id, (struct srm2__ArrayOfTCopyRequestFileStatus *const*)ptr, "srm2:ArrayOfTCopyRequestFileStatus");
	case SOAP_TYPE_PointerTosrm2__ArrayOfTCopyFileRequest:
		return soap_out_PointerTosrm2__ArrayOfTCopyFileRequest(soap, tag, id, (struct srm2__ArrayOfTCopyFileRequest *const*)ptr, "srm2:ArrayOfTCopyFileRequest");
	case SOAP_TYPE_PointerTosrm2__ArrayOfTPutRequestFileStatus:
		return soap_out_PointerTosrm2__ArrayOfTPutRequestFileStatus(soap, tag, id, (struct srm2__ArrayOfTPutRequestFileStatus *const*)ptr, "srm2:ArrayOfTPutRequestFileStatus");
	case SOAP_TYPE_PointerTosrm2__TOverwriteMode:
		return soap_out_PointerTosrm2__TOverwriteMode(soap, tag, id, (enum srm2__TOverwriteMode *const*)ptr, "srm2:TOverwriteMode");
	case SOAP_TYPE_PointerTosrm2__ArrayOfTPutFileRequest:
		return soap_out_PointerTosrm2__ArrayOfTPutFileRequest(soap, tag, id, (struct srm2__ArrayOfTPutFileRequest *const*)ptr, "srm2:ArrayOfTPutFileRequest");
	case SOAP_TYPE_PointerTosrm2__ArrayOfTBringOnlineRequestFileStatus:
		return soap_out_PointerTosrm2__ArrayOfTBringOnlineRequestFileStatus(soap, tag, id, (struct srm2__ArrayOfTBringOnlineRequestFileStatus *const*)ptr, "srm2:ArrayOfTBringOnlineRequestFileStatus");
	case SOAP_TYPE_PointerTosrm2__ArrayOfTGetRequestFileStatus:
		return soap_out_PointerTosrm2__ArrayOfTGetRequestFileStatus(soap, tag, id, (struct srm2__ArrayOfTGetRequestFileStatus *const*)ptr, "srm2:ArrayOfTGetRequestFileStatus");
	case SOAP_TYPE_PointerTosrm2__ArrayOfTGetFileRequest:
		return soap_out_PointerTosrm2__ArrayOfTGetFileRequest(soap, tag, id, (struct srm2__ArrayOfTGetFileRequest *const*)ptr, "srm2:ArrayOfTGetFileRequest");
	case SOAP_TYPE_PointerTosrm2__ArrayOfTPermissionReturn:
		return soap_out_PointerTosrm2__ArrayOfTPermissionReturn(soap, tag, id, (struct srm2__ArrayOfTPermissionReturn *const*)ptr, "srm2:ArrayOfTPermissionReturn");
	case SOAP_TYPE_PointerTosrm2__ArrayOfTSURLPermissionReturn:
		return soap_out_PointerTosrm2__ArrayOfTSURLPermissionReturn(soap, tag, id, (struct srm2__ArrayOfTSURLPermissionReturn *const*)ptr, "srm2:ArrayOfTSURLPermissionReturn");
	case SOAP_TYPE_PointerTosrm2__ArrayOfTSURLLifetimeReturnStatus:
		return soap_out_PointerTosrm2__ArrayOfTSURLLifetimeReturnStatus(soap, tag, id, (struct srm2__ArrayOfTSURLLifetimeReturnStatus *const*)ptr, "srm2:ArrayOfTSURLLifetimeReturnStatus");
	case SOAP_TYPE_PointerTosrm2__ArrayOfTSURLReturnStatus:
		return soap_out_PointerTosrm2__ArrayOfTSURLReturnStatus(soap, tag, id, (struct srm2__ArrayOfTSURLReturnStatus *const*)ptr, "srm2:ArrayOfTSURLReturnStatus");
	case SOAP_TYPE_PointerTosrm2__ArrayOfAnyURI:
		return soap_out_PointerTosrm2__ArrayOfAnyURI(soap, tag, id, (struct srm2__ArrayOfAnyURI *const*)ptr, "srm2:ArrayOfAnyURI");
	case SOAP_TYPE_PointerTosrm2__ArrayOfTMetaDataSpace:
		return soap_out_PointerTosrm2__ArrayOfTMetaDataSpace(soap, tag, id, (struct srm2__ArrayOfTMetaDataSpace *const*)ptr, "srm2:ArrayOfTMetaDataSpace");
	case SOAP_TYPE_PointerTosrm2__TTransferParameters:
		return soap_out_PointerTosrm2__TTransferParameters(soap, tag, id, (struct srm2__TTransferParameters *const*)ptr, "srm2:TTransferParameters");
	case SOAP_TYPE_PointerTosrm2__ArrayOfUnsignedLong:
		return soap_out_PointerTosrm2__ArrayOfUnsignedLong(soap, tag, id, (struct srm2__ArrayOfUnsignedLong *const*)ptr, "srm2:ArrayOfUnsignedLong");
	case SOAP_TYPE_PointerToPointerTosrm2__TSupportedTransferProtocol:
		return soap_out_PointerToPointerTosrm2__TSupportedTransferProtocol(soap, tag, id, (struct srm2__TSupportedTransferProtocol **const*)ptr, "srm2:TSupportedTransferProtocol");
	case SOAP_TYPE_PointerTosrm2__TSupportedTransferProtocol:
		return soap_out_PointerTosrm2__TSupportedTransferProtocol(soap, tag, id, (struct srm2__TSupportedTransferProtocol *const*)ptr, "srm2:TSupportedTransferProtocol");
	case SOAP_TYPE_PointerToPointerTosrm2__TRequestTokenReturn:
		return soap_out_PointerToPointerTosrm2__TRequestTokenReturn(soap, tag, id, (struct srm2__TRequestTokenReturn **const*)ptr, "srm2:TRequestTokenReturn");
	case SOAP_TYPE_PointerTosrm2__TRequestTokenReturn:
		return soap_out_PointerTosrm2__TRequestTokenReturn(soap, tag, id, (struct srm2__TRequestTokenReturn *const*)ptr, "srm2:TRequestTokenReturn");
	case SOAP_TYPE_PointerToPointerTosrm2__TPermissionReturn:
		return soap_out_PointerToPointerTosrm2__TPermissionReturn(soap, tag, id, (struct srm2__TPermissionReturn **const*)ptr, "srm2:TPermissionReturn");
	case SOAP_TYPE_PointerTosrm2__TPermissionReturn:
		return soap_out_PointerTosrm2__TPermissionReturn(soap, tag, id, (struct srm2__TPermissionReturn *const*)ptr, "srm2:TPermissionReturn");
	case SOAP_TYPE_PointerTosrm2__ArrayOfTGroupPermission:
		return soap_out_PointerTosrm2__ArrayOfTGroupPermission(soap, tag, id, (struct srm2__ArrayOfTGroupPermission *const*)ptr, "srm2:ArrayOfTGroupPermission");
	case SOAP_TYPE_PointerTosrm2__ArrayOfTUserPermission:
		return soap_out_PointerTosrm2__ArrayOfTUserPermission(soap, tag, id, (struct srm2__ArrayOfTUserPermission *const*)ptr, "srm2:ArrayOfTUserPermission");
	case SOAP_TYPE_PointerToPointerTosrm2__TSURLPermissionReturn:
		return soap_out_PointerToPointerTosrm2__TSURLPermissionReturn(soap, tag, id, (struct srm2__TSURLPermissionReturn **const*)ptr, "srm2:TSURLPermissionReturn");
	case SOAP_TYPE_PointerTosrm2__TSURLPermissionReturn:
		return soap_out_PointerTosrm2__TSURLPermissionReturn(soap, tag, id, (struct srm2__TSURLPermissionReturn *const*)ptr, "srm2:TSURLPermissionReturn");
	case SOAP_TYPE_PointerToPointerTosrm2__TRequestSummary:
		return soap_out_PointerToPointerTosrm2__TRequestSummary(soap, tag, id, (struct srm2__TRequestSummary **const*)ptr, "srm2:TRequestSummary");
	case SOAP_TYPE_PointerTosrm2__TRequestSummary:
		return soap_out_PointerTosrm2__TRequestSummary(soap, tag, id, (struct srm2__TRequestSummary *const*)ptr, "srm2:TRequestSummary");
	case SOAP_TYPE_PointerTosrm2__TRequestType:
		return soap_out_PointerTosrm2__TRequestType(soap, tag, id, (enum srm2__TRequestType *const*)ptr, "srm2:TRequestType");
	case SOAP_TYPE_PointerToPointerTosrm2__TCopyRequestFileStatus:
		return soap_out_PointerToPointerTosrm2__TCopyRequestFileStatus(soap, tag, id, (struct srm2__TCopyRequestFileStatus **const*)ptr, "srm2:TCopyRequestFileStatus");
	case SOAP_TYPE_PointerTosrm2__TCopyRequestFileStatus:
		return soap_out_PointerTosrm2__TCopyRequestFileStatus(soap, tag, id, (struct srm2__TCopyRequestFileStatus *const*)ptr, "srm2:TCopyRequestFileStatus");
	case SOAP_TYPE_PointerToPointerTosrm2__TPutRequestFileStatus:
		return soap_out_PointerToPointerTosrm2__TPutRequestFileStatus(soap, tag, id, (struct srm2__TPutRequestFileStatus **const*)ptr, "srm2:TPutRequestFileStatus");
	case SOAP_TYPE_PointerTosrm2__TPutRequestFileStatus:
		return soap_out_PointerTosrm2__TPutRequestFileStatus(soap, tag, id, (struct srm2__TPutRequestFileStatus *const*)ptr, "srm2:TPutRequestFileStatus");
	case SOAP_TYPE_PointerToPointerTosrm2__TBringOnlineRequestFileStatus:
		return soap_out_PointerToPointerTosrm2__TBringOnlineRequestFileStatus(soap, tag, id, (struct srm2__TBringOnlineRequestFileStatus **const*)ptr, "srm2:TBringOnlineRequestFileStatus");
	case SOAP_TYPE_PointerTosrm2__TBringOnlineRequestFileStatus:
		return soap_out_PointerTosrm2__TBringOnlineRequestFileStatus(soap, tag, id, (struct srm2__TBringOnlineRequestFileStatus *const*)ptr, "srm2:TBringOnlineRequestFileStatus");
	case SOAP_TYPE_PointerToPointerTosrm2__TGetRequestFileStatus:
		return soap_out_PointerToPointerTosrm2__TGetRequestFileStatus(soap, tag, id, (struct srm2__TGetRequestFileStatus **const*)ptr, "srm2:TGetRequestFileStatus");
	case SOAP_TYPE_PointerTosrm2__TGetRequestFileStatus:
		return soap_out_PointerTosrm2__TGetRequestFileStatus(soap, tag, id, (struct srm2__TGetRequestFileStatus *const*)ptr, "srm2:TGetRequestFileStatus");
	case SOAP_TYPE_PointerTosrm2__ArrayOfTExtraInfo:
		return soap_out_PointerTosrm2__ArrayOfTExtraInfo(soap, tag, id, (struct srm2__ArrayOfTExtraInfo *const*)ptr, "srm2:ArrayOfTExtraInfo");
	case SOAP_TYPE_PointerToPointerTosrm2__TCopyFileRequest:
		return soap_out_PointerToPointerTosrm2__TCopyFileRequest(soap, tag, id, (struct srm2__TCopyFileRequest **const*)ptr, "srm2:TCopyFileRequest");
	case SOAP_TYPE_PointerTosrm2__TCopyFileRequest:
		return soap_out_PointerTosrm2__TCopyFileRequest(soap, tag, id, (struct srm2__TCopyFileRequest *const*)ptr, "srm2:TCopyFileRequest");
	case SOAP_TYPE_PointerToPointerTosrm2__TPutFileRequest:
		return soap_out_PointerToPointerTosrm2__TPutFileRequest(soap, tag, id, (struct srm2__TPutFileRequest **const*)ptr, "srm2:TPutFileRequest");
	case SOAP_TYPE_PointerTosrm2__TPutFileRequest:
		return soap_out_PointerTosrm2__TPutFileRequest(soap, tag, id, (struct srm2__TPutFileRequest *const*)ptr, "srm2:TPutFileRequest");
	case SOAP_TYPE_PointerToPointerTosrm2__TGetFileRequest:
		return soap_out_PointerToPointerTosrm2__TGetFileRequest(soap, tag, id, (struct srm2__TGetFileRequest **const*)ptr, "srm2:TGetFileRequest");
	case SOAP_TYPE_PointerTosrm2__TGetFileRequest:
		return soap_out_PointerTosrm2__TGetFileRequest(soap, tag, id, (struct srm2__TGetFileRequest *const*)ptr, "srm2:TGetFileRequest");
	case SOAP_TYPE_PointerTosrm2__TDirOption:
		return soap_out_PointerTosrm2__TDirOption(soap, tag, id, (struct srm2__TDirOption *const*)ptr, "srm2:TDirOption");
	case SOAP_TYPE_PointerTosrm2__TConnectionType:
		return soap_out_PointerTosrm2__TConnectionType(soap, tag, id, (enum srm2__TConnectionType *const*)ptr, "srm2:TConnectionType");
	case SOAP_TYPE_PointerTosrm2__TAccessPattern:
		return soap_out_PointerTosrm2__TAccessPattern(soap, tag, id, (enum srm2__TAccessPattern *const*)ptr, "srm2:TAccessPattern");
	case SOAP_TYPE_PointerToxsd__anyURI:
		return soap_out_PointerToxsd__anyURI(soap, tag, id, (char **const*)ptr, "xsd:anyURI");
	case SOAP_TYPE_PointerToPointerTosrm2__TExtraInfo:
		return soap_out_PointerToPointerTosrm2__TExtraInfo(soap, tag, id, (struct srm2__TExtraInfo **const*)ptr, "srm2:TExtraInfo");
	case SOAP_TYPE_PointerTosrm2__TExtraInfo:
		return soap_out_PointerTosrm2__TExtraInfo(soap, tag, id, (struct srm2__TExtraInfo *const*)ptr, "srm2:TExtraInfo");
	case SOAP_TYPE_PointerToxsd__boolean:
		return soap_out_PointerToxsd__boolean(soap, tag, id, (enum xsd__boolean *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerToPointerTosrm2__TMetaDataSpace:
		return soap_out_PointerToPointerTosrm2__TMetaDataSpace(soap, tag, id, (struct srm2__TMetaDataSpace **const*)ptr, "srm2:TMetaDataSpace");
	case SOAP_TYPE_PointerTosrm2__TMetaDataSpace:
		return soap_out_PointerTosrm2__TMetaDataSpace(soap, tag, id, (struct srm2__TMetaDataSpace *const*)ptr, "srm2:TMetaDataSpace");
	case SOAP_TYPE_PointerToPointerTosrm2__TMetaDataPathDetail:
		return soap_out_PointerToPointerTosrm2__TMetaDataPathDetail(soap, tag, id, (struct srm2__TMetaDataPathDetail **const*)ptr, "srm2:TMetaDataPathDetail");
	case SOAP_TYPE_PointerTosrm2__TMetaDataPathDetail:
		return soap_out_PointerTosrm2__TMetaDataPathDetail(soap, tag, id, (struct srm2__TMetaDataPathDetail *const*)ptr, "srm2:TMetaDataPathDetail");
	case SOAP_TYPE_PointerTosrm2__ArrayOfTMetaDataPathDetail:
		return soap_out_PointerTosrm2__ArrayOfTMetaDataPathDetail(soap, tag, id, (struct srm2__ArrayOfTMetaDataPathDetail *const*)ptr, "srm2:ArrayOfTMetaDataPathDetail");
	case SOAP_TYPE_PointerTosrm2__TPermissionMode:
		return soap_out_PointerTosrm2__TPermissionMode(soap, tag, id, (enum srm2__TPermissionMode *const*)ptr, "srm2:TPermissionMode");
	case SOAP_TYPE_PointerTosrm2__TFileType:
		return soap_out_PointerTosrm2__TFileType(soap, tag, id, (enum srm2__TFileType *const*)ptr, "srm2:TFileType");
	case SOAP_TYPE_PointerTosrm2__ArrayOfString:
		return soap_out_PointerTosrm2__ArrayOfString(soap, tag, id, (struct srm2__ArrayOfString *const*)ptr, "srm2:ArrayOfString");
	case SOAP_TYPE_PointerTosrm2__TFileLocality:
		return soap_out_PointerTosrm2__TFileLocality(soap, tag, id, (enum srm2__TFileLocality *const*)ptr, "srm2:TFileLocality");
	case SOAP_TYPE_PointerTosrm2__TRetentionPolicyInfo:
		return soap_out_PointerTosrm2__TRetentionPolicyInfo(soap, tag, id, (struct srm2__TRetentionPolicyInfo *const*)ptr, "srm2:TRetentionPolicyInfo");
	case SOAP_TYPE_PointerTosrm2__TFileStorageType:
		return soap_out_PointerTosrm2__TFileStorageType(soap, tag, id, (enum srm2__TFileStorageType *const*)ptr, "srm2:TFileStorageType");
	case SOAP_TYPE_PointerToPointerTosrm2__TSURLLifetimeReturnStatus:
		return soap_out_PointerToPointerTosrm2__TSURLLifetimeReturnStatus(soap, tag, id, (struct srm2__TSURLLifetimeReturnStatus **const*)ptr, "srm2:TSURLLifetimeReturnStatus");
	case SOAP_TYPE_PointerTosrm2__TSURLLifetimeReturnStatus:
		return soap_out_PointerTosrm2__TSURLLifetimeReturnStatus(soap, tag, id, (struct srm2__TSURLLifetimeReturnStatus *const*)ptr, "srm2:TSURLLifetimeReturnStatus");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerToPointerTosrm2__TSURLReturnStatus:
		return soap_out_PointerToPointerTosrm2__TSURLReturnStatus(soap, tag, id, (struct srm2__TSURLReturnStatus **const*)ptr, "srm2:TSURLReturnStatus");
	case SOAP_TYPE_PointerTosrm2__TSURLReturnStatus:
		return soap_out_PointerTosrm2__TSURLReturnStatus(soap, tag, id, (struct srm2__TSURLReturnStatus *const*)ptr, "srm2:TSURLReturnStatus");
	case SOAP_TYPE_PointerTosrm2__TReturnStatus:
		return soap_out_PointerTosrm2__TReturnStatus(soap, tag, id, (struct srm2__TReturnStatus *const*)ptr, "srm2:TReturnStatus");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTounsignedLONG64:
		return soap_out_PointerTounsignedLONG64(soap, tag, id, (ULONG64 *const*)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_PointerToPointerTosrm2__TGroupPermission:
		return soap_out_PointerToPointerTosrm2__TGroupPermission(soap, tag, id, (struct srm2__TGroupPermission **const*)ptr, "srm2:TGroupPermission");
	case SOAP_TYPE_PointerTosrm2__TGroupPermission:
		return soap_out_PointerTosrm2__TGroupPermission(soap, tag, id, (struct srm2__TGroupPermission *const*)ptr, "srm2:TGroupPermission");
	case SOAP_TYPE_PointerToPointerTosrm2__TUserPermission:
		return soap_out_PointerToPointerTosrm2__TUserPermission(soap, tag, id, (struct srm2__TUserPermission **const*)ptr, "srm2:TUserPermission");
	case SOAP_TYPE_PointerTosrm2__TUserPermission:
		return soap_out_PointerTosrm2__TUserPermission(soap, tag, id, (struct srm2__TUserPermission *const*)ptr, "srm2:TUserPermission");
	case SOAP_TYPE_PointerTosrm2__TAccessLatency:
		return soap_out_PointerTosrm2__TAccessLatency(soap, tag, id, (enum srm2__TAccessLatency *const*)ptr, "srm2:TAccessLatency");
	case SOAP_TYPE_xsd__anyURI:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:anyURI");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, "QName", id, (char**)&ptr, NULL);
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_SOAP_ENV__Reason:
		soap_serialize_SOAP_ENV__Reason(soap, (const struct SOAP_ENV__Reason *)ptr);
		break;
	case SOAP_TYPE_srm2__srmPing:
		soap_serialize_srm2__srmPing(soap, (const struct srm2__srmPing *)ptr);
		break;
	case SOAP_TYPE_srm2__srmPingResponse_:
		soap_serialize_srm2__srmPingResponse_(soap, (const struct srm2__srmPingResponse_ *)ptr);
		break;
	case SOAP_TYPE_srm2__srmGetTransferProtocols:
		soap_serialize_srm2__srmGetTransferProtocols(soap, (const struct srm2__srmGetTransferProtocols *)ptr);
		break;
	case SOAP_TYPE_srm2__srmGetTransferProtocolsResponse_:
		soap_serialize_srm2__srmGetTransferProtocolsResponse_(soap, (const struct srm2__srmGetTransferProtocolsResponse_ *)ptr);
		break;
	case SOAP_TYPE_srm2__srmGetRequestTokens:
		soap_serialize_srm2__srmGetRequestTokens(soap, (const struct srm2__srmGetRequestTokens *)ptr);
		break;
	case SOAP_TYPE_srm2__srmGetRequestTokensResponse_:
		soap_serialize_srm2__srmGetRequestTokensResponse_(soap, (const struct srm2__srmGetRequestTokensResponse_ *)ptr);
		break;
	case SOAP_TYPE_srm2__srmExtendFileLifeTime:
		soap_serialize_srm2__srmExtendFileLifeTime(soap, (const struct srm2__srmExtendFileLifeTime *)ptr);
		break;
	case SOAP_TYPE_srm2__srmExtendFileLifeTimeResponse_:
		soap_serialize_srm2__srmExtendFileLifeTimeResponse_(soap, (const struct srm2__srmExtendFileLifeTimeResponse_ *)ptr);
		break;
	case SOAP_TYPE_srm2__srmGetRequestSummary:
		soap_serialize_srm2__srmGetRequestSummary(soap, (const struct srm2__srmGetRequestSummary *)ptr);
		break;
	case SOAP_TYPE_srm2__srmGetRequestSummaryResponse_:
		soap_serialize_srm2__srmGetRequestSummaryResponse_(soap, (const struct srm2__srmGetRequestSummaryResponse_ *)ptr);
		break;
	case SOAP_TYPE_srm2__srmResumeRequest:
		soap_serialize_srm2__srmResumeRequest(soap, (const struct srm2__srmResumeRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmResumeRequestResponse_:
		soap_serialize_srm2__srmResumeRequestResponse_(soap, (const struct srm2__srmResumeRequestResponse_ *)ptr);
		break;
	case SOAP_TYPE_srm2__srmSuspendRequest:
		soap_serialize_srm2__srmSuspendRequest(soap, (const struct srm2__srmSuspendRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmSuspendRequestResponse_:
		soap_serialize_srm2__srmSuspendRequestResponse_(soap, (const struct srm2__srmSuspendRequestResponse_ *)ptr);
		break;
	case SOAP_TYPE_srm2__srmAbortFiles:
		soap_serialize_srm2__srmAbortFiles(soap, (const struct srm2__srmAbortFiles *)ptr);
		break;
	case SOAP_TYPE_srm2__srmAbortFilesResponse_:
		soap_serialize_srm2__srmAbortFilesResponse_(soap, (const struct srm2__srmAbortFilesResponse_ *)ptr);
		break;
	case SOAP_TYPE_srm2__srmAbortRequest:
		soap_serialize_srm2__srmAbortRequest(soap, (const struct srm2__srmAbortRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmAbortRequestResponse_:
		soap_serialize_srm2__srmAbortRequestResponse_(soap, (const struct srm2__srmAbortRequestResponse_ *)ptr);
		break;
	case SOAP_TYPE_srm2__srmPutDone:
		soap_serialize_srm2__srmPutDone(soap, (const struct srm2__srmPutDone *)ptr);
		break;
	case SOAP_TYPE_srm2__srmPutDoneResponse_:
		soap_serialize_srm2__srmPutDoneResponse_(soap, (const struct srm2__srmPutDoneResponse_ *)ptr);
		break;
	case SOAP_TYPE_srm2__srmReleaseFiles:
		soap_serialize_srm2__srmReleaseFiles(soap, (const struct srm2__srmReleaseFiles *)ptr);
		break;
	case SOAP_TYPE_srm2__srmReleaseFilesResponse_:
		soap_serialize_srm2__srmReleaseFilesResponse_(soap, (const struct srm2__srmReleaseFilesResponse_ *)ptr);
		break;
	case SOAP_TYPE_srm2__srmStatusOfCopyRequest:
		soap_serialize_srm2__srmStatusOfCopyRequest(soap, (const struct srm2__srmStatusOfCopyRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmStatusOfCopyRequestResponse_:
		soap_serialize_srm2__srmStatusOfCopyRequestResponse_(soap, (const struct srm2__srmStatusOfCopyRequestResponse_ *)ptr);
		break;
	case SOAP_TYPE_srm2__srmCopy:
		soap_serialize_srm2__srmCopy(soap, (const struct srm2__srmCopy *)ptr);
		break;
	case SOAP_TYPE_srm2__srmCopyResponse_:
		soap_serialize_srm2__srmCopyResponse_(soap, (const struct srm2__srmCopyResponse_ *)ptr);
		break;
	case SOAP_TYPE_srm2__srmStatusOfPutRequest:
		soap_serialize_srm2__srmStatusOfPutRequest(soap, (const struct srm2__srmStatusOfPutRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmStatusOfPutRequestResponse_:
		soap_serialize_srm2__srmStatusOfPutRequestResponse_(soap, (const struct srm2__srmStatusOfPutRequestResponse_ *)ptr);
		break;
	case SOAP_TYPE_srm2__srmPrepareToPut:
		soap_serialize_srm2__srmPrepareToPut(soap, (const struct srm2__srmPrepareToPut *)ptr);
		break;
	case SOAP_TYPE_srm2__srmPrepareToPutResponse_:
		soap_serialize_srm2__srmPrepareToPutResponse_(soap, (const struct srm2__srmPrepareToPutResponse_ *)ptr);
		break;
	case SOAP_TYPE_srm2__srmStatusOfBringOnlineRequest:
		soap_serialize_srm2__srmStatusOfBringOnlineRequest(soap, (const struct srm2__srmStatusOfBringOnlineRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmStatusOfBringOnlineRequestResponse_:
		soap_serialize_srm2__srmStatusOfBringOnlineRequestResponse_(soap, (const struct srm2__srmStatusOfBringOnlineRequestResponse_ *)ptr);
		break;
	case SOAP_TYPE_srm2__srmBringOnline:
		soap_serialize_srm2__srmBringOnline(soap, (const struct srm2__srmBringOnline *)ptr);
		break;
	case SOAP_TYPE_srm2__srmBringOnlineResponse_:
		soap_serialize_srm2__srmBringOnlineResponse_(soap, (const struct srm2__srmBringOnlineResponse_ *)ptr);
		break;
	case SOAP_TYPE_srm2__srmStatusOfGetRequest:
		soap_serialize_srm2__srmStatusOfGetRequest(soap, (const struct srm2__srmStatusOfGetRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmStatusOfGetRequestResponse_:
		soap_serialize_srm2__srmStatusOfGetRequestResponse_(soap, (const struct srm2__srmStatusOfGetRequestResponse_ *)ptr);
		break;
	case SOAP_TYPE_srm2__srmPrepareToGet:
		soap_serialize_srm2__srmPrepareToGet(soap, (const struct srm2__srmPrepareToGet *)ptr);
		break;
	case SOAP_TYPE_srm2__srmPrepareToGetResponse_:
		soap_serialize_srm2__srmPrepareToGetResponse_(soap, (const struct srm2__srmPrepareToGetResponse_ *)ptr);
		break;
	case SOAP_TYPE_srm2__srmMv:
		soap_serialize_srm2__srmMv(soap, (const struct srm2__srmMv *)ptr);
		break;
	case SOAP_TYPE_srm2__srmMvResponse_:
		soap_serialize_srm2__srmMvResponse_(soap, (const struct srm2__srmMvResponse_ *)ptr);
		break;
	case SOAP_TYPE_srm2__srmStatusOfLsRequest:
		soap_serialize_srm2__srmStatusOfLsRequest(soap, (const struct srm2__srmStatusOfLsRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmStatusOfLsRequestResponse_:
		soap_serialize_srm2__srmStatusOfLsRequestResponse_(soap, (const struct srm2__srmStatusOfLsRequestResponse_ *)ptr);
		break;
	case SOAP_TYPE_srm2__srmLs:
		soap_serialize_srm2__srmLs(soap, (const struct srm2__srmLs *)ptr);
		break;
	case SOAP_TYPE_srm2__srmLsResponse_:
		soap_serialize_srm2__srmLsResponse_(soap, (const struct srm2__srmLsResponse_ *)ptr);
		break;
	case SOAP_TYPE_srm2__srmRm:
		soap_serialize_srm2__srmRm(soap, (const struct srm2__srmRm *)ptr);
		break;
	case SOAP_TYPE_srm2__srmRmResponse_:
		soap_serialize_srm2__srmRmResponse_(soap, (const struct srm2__srmRmResponse_ *)ptr);
		break;
	case SOAP_TYPE_srm2__srmRmdir:
		soap_serialize_srm2__srmRmdir(soap, (const struct srm2__srmRmdir *)ptr);
		break;
	case SOAP_TYPE_srm2__srmRmdirResponse_:
		soap_serialize_srm2__srmRmdirResponse_(soap, (const struct srm2__srmRmdirResponse_ *)ptr);
		break;
	case SOAP_TYPE_srm2__srmMkdir:
		soap_serialize_srm2__srmMkdir(soap, (const struct srm2__srmMkdir *)ptr);
		break;
	case SOAP_TYPE_srm2__srmMkdirResponse_:
		soap_serialize_srm2__srmMkdirResponse_(soap, (const struct srm2__srmMkdirResponse_ *)ptr);
		break;
	case SOAP_TYPE_srm2__srmGetPermission:
		soap_serialize_srm2__srmGetPermission(soap, (const struct srm2__srmGetPermission *)ptr);
		break;
	case SOAP_TYPE_srm2__srmGetPermissionResponse_:
		soap_serialize_srm2__srmGetPermissionResponse_(soap, (const struct srm2__srmGetPermissionResponse_ *)ptr);
		break;
	case SOAP_TYPE_srm2__srmCheckPermission:
		soap_serialize_srm2__srmCheckPermission(soap, (const struct srm2__srmCheckPermission *)ptr);
		break;
	case SOAP_TYPE_srm2__srmCheckPermissionResponse_:
		soap_serialize_srm2__srmCheckPermissionResponse_(soap, (const struct srm2__srmCheckPermissionResponse_ *)ptr);
		break;
	case SOAP_TYPE_srm2__srmSetPermission:
		soap_serialize_srm2__srmSetPermission(soap, (const struct srm2__srmSetPermission *)ptr);
		break;
	case SOAP_TYPE_srm2__srmSetPermissionResponse_:
		soap_serialize_srm2__srmSetPermissionResponse_(soap, (const struct srm2__srmSetPermissionResponse_ *)ptr);
		break;
	case SOAP_TYPE_srm2__srmGetSpaceTokens:
		soap_serialize_srm2__srmGetSpaceTokens(soap, (const struct srm2__srmGetSpaceTokens *)ptr);
		break;
	case SOAP_TYPE_srm2__srmGetSpaceTokensResponse_:
		soap_serialize_srm2__srmGetSpaceTokensResponse_(soap, (const struct srm2__srmGetSpaceTokensResponse_ *)ptr);
		break;
	case SOAP_TYPE_srm2__srmPurgeFromSpace:
		soap_serialize_srm2__srmPurgeFromSpace(soap, (const struct srm2__srmPurgeFromSpace *)ptr);
		break;
	case SOAP_TYPE_srm2__srmPurgeFromSpaceResponse_:
		soap_serialize_srm2__srmPurgeFromSpaceResponse_(soap, (const struct srm2__srmPurgeFromSpaceResponse_ *)ptr);
		break;
	case SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpace:
		soap_serialize_srm2__srmExtendFileLifeTimeInSpace(soap, (const struct srm2__srmExtendFileLifeTimeInSpace *)ptr);
		break;
	case SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpaceResponse_:
		soap_serialize_srm2__srmExtendFileLifeTimeInSpaceResponse_(soap, (const struct srm2__srmExtendFileLifeTimeInSpaceResponse_ *)ptr);
		break;
	case SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequest:
		soap_serialize_srm2__srmStatusOfChangeSpaceForFilesRequest(soap, (const struct srm2__srmStatusOfChangeSpaceForFilesRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequestResponse_:
		soap_serialize_srm2__srmStatusOfChangeSpaceForFilesRequestResponse_(soap, (const struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse_ *)ptr);
		break;
	case SOAP_TYPE_srm2__srmChangeSpaceForFiles:
		soap_serialize_srm2__srmChangeSpaceForFiles(soap, (const struct srm2__srmChangeSpaceForFiles *)ptr);
		break;
	case SOAP_TYPE_srm2__srmChangeSpaceForFilesResponse_:
		soap_serialize_srm2__srmChangeSpaceForFilesResponse_(soap, (const struct srm2__srmChangeSpaceForFilesResponse_ *)ptr);
		break;
	case SOAP_TYPE_srm2__srmGetSpaceMetaData:
		soap_serialize_srm2__srmGetSpaceMetaData(soap, (const struct srm2__srmGetSpaceMetaData *)ptr);
		break;
	case SOAP_TYPE_srm2__srmGetSpaceMetaDataResponse_:
		soap_serialize_srm2__srmGetSpaceMetaDataResponse_(soap, (const struct srm2__srmGetSpaceMetaDataResponse_ *)ptr);
		break;
	case SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequest:
		soap_serialize_srm2__srmStatusOfUpdateSpaceRequest(soap, (const struct srm2__srmStatusOfUpdateSpaceRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequestResponse_:
		soap_serialize_srm2__srmStatusOfUpdateSpaceRequestResponse_(soap, (const struct srm2__srmStatusOfUpdateSpaceRequestResponse_ *)ptr);
		break;
	case SOAP_TYPE_srm2__srmUpdateSpace:
		soap_serialize_srm2__srmUpdateSpace(soap, (const struct srm2__srmUpdateSpace *)ptr);
		break;
	case SOAP_TYPE_srm2__srmUpdateSpaceResponse_:
		soap_serialize_srm2__srmUpdateSpaceResponse_(soap, (const struct srm2__srmUpdateSpaceResponse_ *)ptr);
		break;
	case SOAP_TYPE_srm2__srmReleaseSpace:
		soap_serialize_srm2__srmReleaseSpace(soap, (const struct srm2__srmReleaseSpace *)ptr);
		break;
	case SOAP_TYPE_srm2__srmReleaseSpaceResponse_:
		soap_serialize_srm2__srmReleaseSpaceResponse_(soap, (const struct srm2__srmReleaseSpaceResponse_ *)ptr);
		break;
	case SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequest:
		soap_serialize_srm2__srmStatusOfReserveSpaceRequest(soap, (const struct srm2__srmStatusOfReserveSpaceRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequestResponse_:
		soap_serialize_srm2__srmStatusOfReserveSpaceRequestResponse_(soap, (const struct srm2__srmStatusOfReserveSpaceRequestResponse_ *)ptr);
		break;
	case SOAP_TYPE_srm2__srmReserveSpace:
		soap_serialize_srm2__srmReserveSpace(soap, (const struct srm2__srmReserveSpace *)ptr);
		break;
	case SOAP_TYPE_srm2__srmReserveSpaceResponse_:
		soap_serialize_srm2__srmReserveSpaceResponse_(soap, (const struct srm2__srmReserveSpaceResponse_ *)ptr);
		break;
	case SOAP_TYPE_srm2__srmPingResponse:
		soap_serialize_srm2__srmPingResponse(soap, (const struct srm2__srmPingResponse *)ptr);
		break;
	case SOAP_TYPE_srm2__srmPingRequest:
		soap_serialize_srm2__srmPingRequest(soap, (const struct srm2__srmPingRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmGetTransferProtocolsResponse:
		soap_serialize_srm2__srmGetTransferProtocolsResponse(soap, (const struct srm2__srmGetTransferProtocolsResponse *)ptr);
		break;
	case SOAP_TYPE_srm2__srmGetTransferProtocolsRequest:
		soap_serialize_srm2__srmGetTransferProtocolsRequest(soap, (const struct srm2__srmGetTransferProtocolsRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmGetRequestTokensResponse:
		soap_serialize_srm2__srmGetRequestTokensResponse(soap, (const struct srm2__srmGetRequestTokensResponse *)ptr);
		break;
	case SOAP_TYPE_srm2__srmGetRequestTokensRequest:
		soap_serialize_srm2__srmGetRequestTokensRequest(soap, (const struct srm2__srmGetRequestTokensRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmExtendFileLifeTimeResponse:
		soap_serialize_srm2__srmExtendFileLifeTimeResponse(soap, (const struct srm2__srmExtendFileLifeTimeResponse *)ptr);
		break;
	case SOAP_TYPE_srm2__srmExtendFileLifeTimeRequest:
		soap_serialize_srm2__srmExtendFileLifeTimeRequest(soap, (const struct srm2__srmExtendFileLifeTimeRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmGetRequestSummaryResponse:
		soap_serialize_srm2__srmGetRequestSummaryResponse(soap, (const struct srm2__srmGetRequestSummaryResponse *)ptr);
		break;
	case SOAP_TYPE_srm2__srmGetRequestSummaryRequest:
		soap_serialize_srm2__srmGetRequestSummaryRequest(soap, (const struct srm2__srmGetRequestSummaryRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmResumeRequestResponse:
		soap_serialize_srm2__srmResumeRequestResponse(soap, (const struct srm2__srmResumeRequestResponse *)ptr);
		break;
	case SOAP_TYPE_srm2__srmResumeRequestRequest:
		soap_serialize_srm2__srmResumeRequestRequest(soap, (const struct srm2__srmResumeRequestRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmSuspendRequestResponse:
		soap_serialize_srm2__srmSuspendRequestResponse(soap, (const struct srm2__srmSuspendRequestResponse *)ptr);
		break;
	case SOAP_TYPE_srm2__srmSuspendRequestRequest:
		soap_serialize_srm2__srmSuspendRequestRequest(soap, (const struct srm2__srmSuspendRequestRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmAbortFilesResponse:
		soap_serialize_srm2__srmAbortFilesResponse(soap, (const struct srm2__srmAbortFilesResponse *)ptr);
		break;
	case SOAP_TYPE_srm2__srmAbortFilesRequest:
		soap_serialize_srm2__srmAbortFilesRequest(soap, (const struct srm2__srmAbortFilesRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmAbortRequestResponse:
		soap_serialize_srm2__srmAbortRequestResponse(soap, (const struct srm2__srmAbortRequestResponse *)ptr);
		break;
	case SOAP_TYPE_srm2__srmAbortRequestRequest:
		soap_serialize_srm2__srmAbortRequestRequest(soap, (const struct srm2__srmAbortRequestRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmPutDoneResponse:
		soap_serialize_srm2__srmPutDoneResponse(soap, (const struct srm2__srmPutDoneResponse *)ptr);
		break;
	case SOAP_TYPE_srm2__srmPutDoneRequest:
		soap_serialize_srm2__srmPutDoneRequest(soap, (const struct srm2__srmPutDoneRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmReleaseFilesResponse:
		soap_serialize_srm2__srmReleaseFilesResponse(soap, (const struct srm2__srmReleaseFilesResponse *)ptr);
		break;
	case SOAP_TYPE_srm2__srmReleaseFilesRequest:
		soap_serialize_srm2__srmReleaseFilesRequest(soap, (const struct srm2__srmReleaseFilesRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmStatusOfCopyRequestResponse:
		soap_serialize_srm2__srmStatusOfCopyRequestResponse(soap, (const struct srm2__srmStatusOfCopyRequestResponse *)ptr);
		break;
	case SOAP_TYPE_srm2__srmStatusOfCopyRequestRequest:
		soap_serialize_srm2__srmStatusOfCopyRequestRequest(soap, (const struct srm2__srmStatusOfCopyRequestRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmCopyResponse:
		soap_serialize_srm2__srmCopyResponse(soap, (const struct srm2__srmCopyResponse *)ptr);
		break;
	case SOAP_TYPE_srm2__srmCopyRequest:
		soap_serialize_srm2__srmCopyRequest(soap, (const struct srm2__srmCopyRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmStatusOfPutRequestResponse:
		soap_serialize_srm2__srmStatusOfPutRequestResponse(soap, (const struct srm2__srmStatusOfPutRequestResponse *)ptr);
		break;
	case SOAP_TYPE_srm2__srmStatusOfPutRequestRequest:
		soap_serialize_srm2__srmStatusOfPutRequestRequest(soap, (const struct srm2__srmStatusOfPutRequestRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmPrepareToPutResponse:
		soap_serialize_srm2__srmPrepareToPutResponse(soap, (const struct srm2__srmPrepareToPutResponse *)ptr);
		break;
	case SOAP_TYPE_srm2__srmPrepareToPutRequest:
		soap_serialize_srm2__srmPrepareToPutRequest(soap, (const struct srm2__srmPrepareToPutRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmStatusOfBringOnlineRequestResponse:
		soap_serialize_srm2__srmStatusOfBringOnlineRequestResponse(soap, (const struct srm2__srmStatusOfBringOnlineRequestResponse *)ptr);
		break;
	case SOAP_TYPE_srm2__srmStatusOfBringOnlineRequestRequest:
		soap_serialize_srm2__srmStatusOfBringOnlineRequestRequest(soap, (const struct srm2__srmStatusOfBringOnlineRequestRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmBringOnlineResponse:
		soap_serialize_srm2__srmBringOnlineResponse(soap, (const struct srm2__srmBringOnlineResponse *)ptr);
		break;
	case SOAP_TYPE_srm2__srmBringOnlineRequest:
		soap_serialize_srm2__srmBringOnlineRequest(soap, (const struct srm2__srmBringOnlineRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmStatusOfGetRequestResponse:
		soap_serialize_srm2__srmStatusOfGetRequestResponse(soap, (const struct srm2__srmStatusOfGetRequestResponse *)ptr);
		break;
	case SOAP_TYPE_srm2__srmStatusOfGetRequestRequest:
		soap_serialize_srm2__srmStatusOfGetRequestRequest(soap, (const struct srm2__srmStatusOfGetRequestRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmPrepareToGetResponse:
		soap_serialize_srm2__srmPrepareToGetResponse(soap, (const struct srm2__srmPrepareToGetResponse *)ptr);
		break;
	case SOAP_TYPE_srm2__srmPrepareToGetRequest:
		soap_serialize_srm2__srmPrepareToGetRequest(soap, (const struct srm2__srmPrepareToGetRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmMvResponse:
		soap_serialize_srm2__srmMvResponse(soap, (const struct srm2__srmMvResponse *)ptr);
		break;
	case SOAP_TYPE_srm2__srmMvRequest:
		soap_serialize_srm2__srmMvRequest(soap, (const struct srm2__srmMvRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmStatusOfLsRequestResponse:
		soap_serialize_srm2__srmStatusOfLsRequestResponse(soap, (const struct srm2__srmStatusOfLsRequestResponse *)ptr);
		break;
	case SOAP_TYPE_srm2__srmStatusOfLsRequestRequest:
		soap_serialize_srm2__srmStatusOfLsRequestRequest(soap, (const struct srm2__srmStatusOfLsRequestRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmLsResponse:
		soap_serialize_srm2__srmLsResponse(soap, (const struct srm2__srmLsResponse *)ptr);
		break;
	case SOAP_TYPE_srm2__srmLsRequest:
		soap_serialize_srm2__srmLsRequest(soap, (const struct srm2__srmLsRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmRmResponse:
		soap_serialize_srm2__srmRmResponse(soap, (const struct srm2__srmRmResponse *)ptr);
		break;
	case SOAP_TYPE_srm2__srmRmRequest:
		soap_serialize_srm2__srmRmRequest(soap, (const struct srm2__srmRmRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmRmdirResponse:
		soap_serialize_srm2__srmRmdirResponse(soap, (const struct srm2__srmRmdirResponse *)ptr);
		break;
	case SOAP_TYPE_srm2__srmRmdirRequest:
		soap_serialize_srm2__srmRmdirRequest(soap, (const struct srm2__srmRmdirRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmMkdirResponse:
		soap_serialize_srm2__srmMkdirResponse(soap, (const struct srm2__srmMkdirResponse *)ptr);
		break;
	case SOAP_TYPE_srm2__srmMkdirRequest:
		soap_serialize_srm2__srmMkdirRequest(soap, (const struct srm2__srmMkdirRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmGetPermissionResponse:
		soap_serialize_srm2__srmGetPermissionResponse(soap, (const struct srm2__srmGetPermissionResponse *)ptr);
		break;
	case SOAP_TYPE_srm2__srmGetPermissionRequest:
		soap_serialize_srm2__srmGetPermissionRequest(soap, (const struct srm2__srmGetPermissionRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmCheckPermissionResponse:
		soap_serialize_srm2__srmCheckPermissionResponse(soap, (const struct srm2__srmCheckPermissionResponse *)ptr);
		break;
	case SOAP_TYPE_srm2__srmCheckPermissionRequest:
		soap_serialize_srm2__srmCheckPermissionRequest(soap, (const struct srm2__srmCheckPermissionRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmSetPermissionResponse:
		soap_serialize_srm2__srmSetPermissionResponse(soap, (const struct srm2__srmSetPermissionResponse *)ptr);
		break;
	case SOAP_TYPE_srm2__srmSetPermissionRequest:
		soap_serialize_srm2__srmSetPermissionRequest(soap, (const struct srm2__srmSetPermissionRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmGetSpaceTokensResponse:
		soap_serialize_srm2__srmGetSpaceTokensResponse(soap, (const struct srm2__srmGetSpaceTokensResponse *)ptr);
		break;
	case SOAP_TYPE_srm2__srmGetSpaceTokensRequest:
		soap_serialize_srm2__srmGetSpaceTokensRequest(soap, (const struct srm2__srmGetSpaceTokensRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmPurgeFromSpaceResponse:
		soap_serialize_srm2__srmPurgeFromSpaceResponse(soap, (const struct srm2__srmPurgeFromSpaceResponse *)ptr);
		break;
	case SOAP_TYPE_srm2__srmPurgeFromSpaceRequest:
		soap_serialize_srm2__srmPurgeFromSpaceRequest(soap, (const struct srm2__srmPurgeFromSpaceRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpaceResponse:
		soap_serialize_srm2__srmExtendFileLifeTimeInSpaceResponse(soap, (const struct srm2__srmExtendFileLifeTimeInSpaceResponse *)ptr);
		break;
	case SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpaceRequest:
		soap_serialize_srm2__srmExtendFileLifeTimeInSpaceRequest(soap, (const struct srm2__srmExtendFileLifeTimeInSpaceRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequestResponse:
		soap_serialize_srm2__srmStatusOfChangeSpaceForFilesRequestResponse(soap, (const struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse *)ptr);
		break;
	case SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequestRequest:
		soap_serialize_srm2__srmStatusOfChangeSpaceForFilesRequestRequest(soap, (const struct srm2__srmStatusOfChangeSpaceForFilesRequestRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmChangeSpaceForFilesResponse:
		soap_serialize_srm2__srmChangeSpaceForFilesResponse(soap, (const struct srm2__srmChangeSpaceForFilesResponse *)ptr);
		break;
	case SOAP_TYPE_srm2__srmChangeSpaceForFilesRequest:
		soap_serialize_srm2__srmChangeSpaceForFilesRequest(soap, (const struct srm2__srmChangeSpaceForFilesRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmGetSpaceMetaDataResponse:
		soap_serialize_srm2__srmGetSpaceMetaDataResponse(soap, (const struct srm2__srmGetSpaceMetaDataResponse *)ptr);
		break;
	case SOAP_TYPE_srm2__srmGetSpaceMetaDataRequest:
		soap_serialize_srm2__srmGetSpaceMetaDataRequest(soap, (const struct srm2__srmGetSpaceMetaDataRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequestResponse:
		soap_serialize_srm2__srmStatusOfUpdateSpaceRequestResponse(soap, (const struct srm2__srmStatusOfUpdateSpaceRequestResponse *)ptr);
		break;
	case SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequestRequest:
		soap_serialize_srm2__srmStatusOfUpdateSpaceRequestRequest(soap, (const struct srm2__srmStatusOfUpdateSpaceRequestRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmUpdateSpaceResponse:
		soap_serialize_srm2__srmUpdateSpaceResponse(soap, (const struct srm2__srmUpdateSpaceResponse *)ptr);
		break;
	case SOAP_TYPE_srm2__srmUpdateSpaceRequest:
		soap_serialize_srm2__srmUpdateSpaceRequest(soap, (const struct srm2__srmUpdateSpaceRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmReleaseSpaceResponse:
		soap_serialize_srm2__srmReleaseSpaceResponse(soap, (const struct srm2__srmReleaseSpaceResponse *)ptr);
		break;
	case SOAP_TYPE_srm2__srmReleaseSpaceRequest:
		soap_serialize_srm2__srmReleaseSpaceRequest(soap, (const struct srm2__srmReleaseSpaceRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequestResponse:
		soap_serialize_srm2__srmStatusOfReserveSpaceRequestResponse(soap, (const struct srm2__srmStatusOfReserveSpaceRequestResponse *)ptr);
		break;
	case SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequestRequest:
		soap_serialize_srm2__srmStatusOfReserveSpaceRequestRequest(soap, (const struct srm2__srmStatusOfReserveSpaceRequestRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__srmReserveSpaceResponse:
		soap_serialize_srm2__srmReserveSpaceResponse(soap, (const struct srm2__srmReserveSpaceResponse *)ptr);
		break;
	case SOAP_TYPE_srm2__srmReserveSpaceRequest:
		soap_serialize_srm2__srmReserveSpaceRequest(soap, (const struct srm2__srmReserveSpaceRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__ArrayOfTSupportedTransferProtocol:
		soap_serialize_srm2__ArrayOfTSupportedTransferProtocol(soap, (const struct srm2__ArrayOfTSupportedTransferProtocol *)ptr);
		break;
	case SOAP_TYPE_srm2__TSupportedTransferProtocol:
		soap_serialize_srm2__TSupportedTransferProtocol(soap, (const struct srm2__TSupportedTransferProtocol *)ptr);
		break;
	case SOAP_TYPE_srm2__ArrayOfTRequestTokenReturn:
		soap_serialize_srm2__ArrayOfTRequestTokenReturn(soap, (const struct srm2__ArrayOfTRequestTokenReturn *)ptr);
		break;
	case SOAP_TYPE_srm2__TRequestTokenReturn:
		soap_serialize_srm2__TRequestTokenReturn(soap, (const struct srm2__TRequestTokenReturn *)ptr);
		break;
	case SOAP_TYPE_srm2__ArrayOfTPermissionReturn:
		soap_serialize_srm2__ArrayOfTPermissionReturn(soap, (const struct srm2__ArrayOfTPermissionReturn *)ptr);
		break;
	case SOAP_TYPE_srm2__TPermissionReturn:
		soap_serialize_srm2__TPermissionReturn(soap, (const struct srm2__TPermissionReturn *)ptr);
		break;
	case SOAP_TYPE_srm2__ArrayOfTSURLPermissionReturn:
		soap_serialize_srm2__ArrayOfTSURLPermissionReturn(soap, (const struct srm2__ArrayOfTSURLPermissionReturn *)ptr);
		break;
	case SOAP_TYPE_srm2__TSURLPermissionReturn:
		soap_serialize_srm2__TSURLPermissionReturn(soap, (const struct srm2__TSURLPermissionReturn *)ptr);
		break;
	case SOAP_TYPE_srm2__ArrayOfTRequestSummary:
		soap_serialize_srm2__ArrayOfTRequestSummary(soap, (const struct srm2__ArrayOfTRequestSummary *)ptr);
		break;
	case SOAP_TYPE_srm2__TRequestSummary:
		soap_serialize_srm2__TRequestSummary(soap, (const struct srm2__TRequestSummary *)ptr);
		break;
	case SOAP_TYPE_srm2__ArrayOfTCopyRequestFileStatus:
		soap_serialize_srm2__ArrayOfTCopyRequestFileStatus(soap, (const struct srm2__ArrayOfTCopyRequestFileStatus *)ptr);
		break;
	case SOAP_TYPE_srm2__TCopyRequestFileStatus:
		soap_serialize_srm2__TCopyRequestFileStatus(soap, (const struct srm2__TCopyRequestFileStatus *)ptr);
		break;
	case SOAP_TYPE_srm2__ArrayOfTPutRequestFileStatus:
		soap_serialize_srm2__ArrayOfTPutRequestFileStatus(soap, (const struct srm2__ArrayOfTPutRequestFileStatus *)ptr);
		break;
	case SOAP_TYPE_srm2__TPutRequestFileStatus:
		soap_serialize_srm2__TPutRequestFileStatus(soap, (const struct srm2__TPutRequestFileStatus *)ptr);
		break;
	case SOAP_TYPE_srm2__ArrayOfTBringOnlineRequestFileStatus:
		soap_serialize_srm2__ArrayOfTBringOnlineRequestFileStatus(soap, (const struct srm2__ArrayOfTBringOnlineRequestFileStatus *)ptr);
		break;
	case SOAP_TYPE_srm2__TBringOnlineRequestFileStatus:
		soap_serialize_srm2__TBringOnlineRequestFileStatus(soap, (const struct srm2__TBringOnlineRequestFileStatus *)ptr);
		break;
	case SOAP_TYPE_srm2__ArrayOfTGetRequestFileStatus:
		soap_serialize_srm2__ArrayOfTGetRequestFileStatus(soap, (const struct srm2__ArrayOfTGetRequestFileStatus *)ptr);
		break;
	case SOAP_TYPE_srm2__TGetRequestFileStatus:
		soap_serialize_srm2__TGetRequestFileStatus(soap, (const struct srm2__TGetRequestFileStatus *)ptr);
		break;
	case SOAP_TYPE_srm2__ArrayOfTCopyFileRequest:
		soap_serialize_srm2__ArrayOfTCopyFileRequest(soap, (const struct srm2__ArrayOfTCopyFileRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__TCopyFileRequest:
		soap_serialize_srm2__TCopyFileRequest(soap, (const struct srm2__TCopyFileRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__ArrayOfTPutFileRequest:
		soap_serialize_srm2__ArrayOfTPutFileRequest(soap, (const struct srm2__ArrayOfTPutFileRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__TPutFileRequest:
		soap_serialize_srm2__TPutFileRequest(soap, (const struct srm2__TPutFileRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__ArrayOfTGetFileRequest:
		soap_serialize_srm2__ArrayOfTGetFileRequest(soap, (const struct srm2__ArrayOfTGetFileRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__TGetFileRequest:
		soap_serialize_srm2__TGetFileRequest(soap, (const struct srm2__TGetFileRequest *)ptr);
		break;
	case SOAP_TYPE_srm2__TTransferParameters:
		soap_serialize_srm2__TTransferParameters(soap, (const struct srm2__TTransferParameters *)ptr);
		break;
	case SOAP_TYPE_srm2__ArrayOfAnyURI:
		soap_serialize_srm2__ArrayOfAnyURI(soap, (const struct srm2__ArrayOfAnyURI *)ptr);
		break;
	case SOAP_TYPE_srm2__ArrayOfTExtraInfo:
		soap_serialize_srm2__ArrayOfTExtraInfo(soap, (const struct srm2__ArrayOfTExtraInfo *)ptr);
		break;
	case SOAP_TYPE_srm2__TExtraInfo:
		soap_serialize_srm2__TExtraInfo(soap, (const struct srm2__TExtraInfo *)ptr);
		break;
	case SOAP_TYPE_srm2__TDirOption:
		soap_serialize_srm2__TDirOption(soap, (const struct srm2__TDirOption *)ptr);
		break;
	case SOAP_TYPE_srm2__ArrayOfTMetaDataSpace:
		soap_serialize_srm2__ArrayOfTMetaDataSpace(soap, (const struct srm2__ArrayOfTMetaDataSpace *)ptr);
		break;
	case SOAP_TYPE_srm2__TMetaDataSpace:
		soap_serialize_srm2__TMetaDataSpace(soap, (const struct srm2__TMetaDataSpace *)ptr);
		break;
	case SOAP_TYPE_srm2__ArrayOfTMetaDataPathDetail:
		soap_serialize_srm2__ArrayOfTMetaDataPathDetail(soap, (const struct srm2__ArrayOfTMetaDataPathDetail *)ptr);
		break;
	case SOAP_TYPE_srm2__TMetaDataPathDetail:
		soap_serialize_srm2__TMetaDataPathDetail(soap, (const struct srm2__TMetaDataPathDetail *)ptr);
		break;
	case SOAP_TYPE_srm2__ArrayOfTSURLLifetimeReturnStatus:
		soap_serialize_srm2__ArrayOfTSURLLifetimeReturnStatus(soap, (const struct srm2__ArrayOfTSURLLifetimeReturnStatus *)ptr);
		break;
	case SOAP_TYPE_srm2__TSURLLifetimeReturnStatus:
		soap_serialize_srm2__TSURLLifetimeReturnStatus(soap, (const struct srm2__TSURLLifetimeReturnStatus *)ptr);
		break;
	case SOAP_TYPE_srm2__ArrayOfTSURLReturnStatus:
		soap_serialize_srm2__ArrayOfTSURLReturnStatus(soap, (const struct srm2__ArrayOfTSURLReturnStatus *)ptr);
		break;
	case SOAP_TYPE_srm2__TSURLReturnStatus:
		soap_serialize_srm2__TSURLReturnStatus(soap, (const struct srm2__TSURLReturnStatus *)ptr);
		break;
	case SOAP_TYPE_srm2__TReturnStatus:
		soap_serialize_srm2__TReturnStatus(soap, (const struct srm2__TReturnStatus *)ptr);
		break;
	case SOAP_TYPE_srm2__ArrayOfString:
		soap_serialize_srm2__ArrayOfString(soap, (const struct srm2__ArrayOfString *)ptr);
		break;
	case SOAP_TYPE_srm2__ArrayOfUnsignedLong:
		soap_serialize_srm2__ArrayOfUnsignedLong(soap, (const struct srm2__ArrayOfUnsignedLong *)ptr);
		break;
	case SOAP_TYPE_srm2__ArrayOfTGroupPermission:
		soap_serialize_srm2__ArrayOfTGroupPermission(soap, (const struct srm2__ArrayOfTGroupPermission *)ptr);
		break;
	case SOAP_TYPE_srm2__TGroupPermission:
		soap_serialize_srm2__TGroupPermission(soap, (const struct srm2__TGroupPermission *)ptr);
		break;
	case SOAP_TYPE_srm2__ArrayOfTUserPermission:
		soap_serialize_srm2__ArrayOfTUserPermission(soap, (const struct srm2__ArrayOfTUserPermission *)ptr);
		break;
	case SOAP_TYPE_srm2__TUserPermission:
		soap_serialize_srm2__TUserPermission(soap, (const struct srm2__TUserPermission *)ptr);
		break;
	case SOAP_TYPE_srm2__TRetentionPolicyInfo:
		soap_serialize_srm2__TRetentionPolicyInfo(soap, (const struct srm2__TRetentionPolicyInfo *)ptr);
		break;
	case SOAP_TYPE_PointerToSOAP_ENV__Reason:
		soap_serialize_PointerToSOAP_ENV__Reason(soap, (struct SOAP_ENV__Reason *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmPingResponse_:
		soap_serialize_PointerTosrm2__srmPingResponse_(soap, (struct srm2__srmPingResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmPingRequest:
		soap_serialize_PointerTosrm2__srmPingRequest(soap, (struct srm2__srmPingRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmPingResponse:
		soap_serialize_PointerTosrm2__srmPingResponse(soap, (struct srm2__srmPingResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmGetTransferProtocolsResponse_:
		soap_serialize_PointerTosrm2__srmGetTransferProtocolsResponse_(soap, (struct srm2__srmGetTransferProtocolsResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmGetTransferProtocolsRequest:
		soap_serialize_PointerTosrm2__srmGetTransferProtocolsRequest(soap, (struct srm2__srmGetTransferProtocolsRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmGetTransferProtocolsResponse:
		soap_serialize_PointerTosrm2__srmGetTransferProtocolsResponse(soap, (struct srm2__srmGetTransferProtocolsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmGetRequestTokensResponse_:
		soap_serialize_PointerTosrm2__srmGetRequestTokensResponse_(soap, (struct srm2__srmGetRequestTokensResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmGetRequestTokensRequest:
		soap_serialize_PointerTosrm2__srmGetRequestTokensRequest(soap, (struct srm2__srmGetRequestTokensRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmGetRequestTokensResponse:
		soap_serialize_PointerTosrm2__srmGetRequestTokensResponse(soap, (struct srm2__srmGetRequestTokensResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmExtendFileLifeTimeResponse_:
		soap_serialize_PointerTosrm2__srmExtendFileLifeTimeResponse_(soap, (struct srm2__srmExtendFileLifeTimeResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmExtendFileLifeTimeRequest:
		soap_serialize_PointerTosrm2__srmExtendFileLifeTimeRequest(soap, (struct srm2__srmExtendFileLifeTimeRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmExtendFileLifeTimeResponse:
		soap_serialize_PointerTosrm2__srmExtendFileLifeTimeResponse(soap, (struct srm2__srmExtendFileLifeTimeResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmGetRequestSummaryResponse_:
		soap_serialize_PointerTosrm2__srmGetRequestSummaryResponse_(soap, (struct srm2__srmGetRequestSummaryResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmGetRequestSummaryRequest:
		soap_serialize_PointerTosrm2__srmGetRequestSummaryRequest(soap, (struct srm2__srmGetRequestSummaryRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmGetRequestSummaryResponse:
		soap_serialize_PointerTosrm2__srmGetRequestSummaryResponse(soap, (struct srm2__srmGetRequestSummaryResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmResumeRequestResponse_:
		soap_serialize_PointerTosrm2__srmResumeRequestResponse_(soap, (struct srm2__srmResumeRequestResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmResumeRequestRequest:
		soap_serialize_PointerTosrm2__srmResumeRequestRequest(soap, (struct srm2__srmResumeRequestRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmResumeRequestResponse:
		soap_serialize_PointerTosrm2__srmResumeRequestResponse(soap, (struct srm2__srmResumeRequestResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmSuspendRequestResponse_:
		soap_serialize_PointerTosrm2__srmSuspendRequestResponse_(soap, (struct srm2__srmSuspendRequestResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmSuspendRequestRequest:
		soap_serialize_PointerTosrm2__srmSuspendRequestRequest(soap, (struct srm2__srmSuspendRequestRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmSuspendRequestResponse:
		soap_serialize_PointerTosrm2__srmSuspendRequestResponse(soap, (struct srm2__srmSuspendRequestResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmAbortFilesResponse_:
		soap_serialize_PointerTosrm2__srmAbortFilesResponse_(soap, (struct srm2__srmAbortFilesResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmAbortFilesRequest:
		soap_serialize_PointerTosrm2__srmAbortFilesRequest(soap, (struct srm2__srmAbortFilesRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmAbortFilesResponse:
		soap_serialize_PointerTosrm2__srmAbortFilesResponse(soap, (struct srm2__srmAbortFilesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmAbortRequestResponse_:
		soap_serialize_PointerTosrm2__srmAbortRequestResponse_(soap, (struct srm2__srmAbortRequestResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmAbortRequestRequest:
		soap_serialize_PointerTosrm2__srmAbortRequestRequest(soap, (struct srm2__srmAbortRequestRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmAbortRequestResponse:
		soap_serialize_PointerTosrm2__srmAbortRequestResponse(soap, (struct srm2__srmAbortRequestResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmPutDoneResponse_:
		soap_serialize_PointerTosrm2__srmPutDoneResponse_(soap, (struct srm2__srmPutDoneResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmPutDoneRequest:
		soap_serialize_PointerTosrm2__srmPutDoneRequest(soap, (struct srm2__srmPutDoneRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmPutDoneResponse:
		soap_serialize_PointerTosrm2__srmPutDoneResponse(soap, (struct srm2__srmPutDoneResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmReleaseFilesResponse_:
		soap_serialize_PointerTosrm2__srmReleaseFilesResponse_(soap, (struct srm2__srmReleaseFilesResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmReleaseFilesRequest:
		soap_serialize_PointerTosrm2__srmReleaseFilesRequest(soap, (struct srm2__srmReleaseFilesRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmReleaseFilesResponse:
		soap_serialize_PointerTosrm2__srmReleaseFilesResponse(soap, (struct srm2__srmReleaseFilesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmStatusOfCopyRequestResponse_:
		soap_serialize_PointerTosrm2__srmStatusOfCopyRequestResponse_(soap, (struct srm2__srmStatusOfCopyRequestResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmStatusOfCopyRequestRequest:
		soap_serialize_PointerTosrm2__srmStatusOfCopyRequestRequest(soap, (struct srm2__srmStatusOfCopyRequestRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmStatusOfCopyRequestResponse:
		soap_serialize_PointerTosrm2__srmStatusOfCopyRequestResponse(soap, (struct srm2__srmStatusOfCopyRequestResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmCopyResponse_:
		soap_serialize_PointerTosrm2__srmCopyResponse_(soap, (struct srm2__srmCopyResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmCopyRequest:
		soap_serialize_PointerTosrm2__srmCopyRequest(soap, (struct srm2__srmCopyRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmCopyResponse:
		soap_serialize_PointerTosrm2__srmCopyResponse(soap, (struct srm2__srmCopyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmStatusOfPutRequestResponse_:
		soap_serialize_PointerTosrm2__srmStatusOfPutRequestResponse_(soap, (struct srm2__srmStatusOfPutRequestResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmStatusOfPutRequestRequest:
		soap_serialize_PointerTosrm2__srmStatusOfPutRequestRequest(soap, (struct srm2__srmStatusOfPutRequestRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmStatusOfPutRequestResponse:
		soap_serialize_PointerTosrm2__srmStatusOfPutRequestResponse(soap, (struct srm2__srmStatusOfPutRequestResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmPrepareToPutResponse_:
		soap_serialize_PointerTosrm2__srmPrepareToPutResponse_(soap, (struct srm2__srmPrepareToPutResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmPrepareToPutRequest:
		soap_serialize_PointerTosrm2__srmPrepareToPutRequest(soap, (struct srm2__srmPrepareToPutRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmPrepareToPutResponse:
		soap_serialize_PointerTosrm2__srmPrepareToPutResponse(soap, (struct srm2__srmPrepareToPutResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmStatusOfBringOnlineRequestResponse_:
		soap_serialize_PointerTosrm2__srmStatusOfBringOnlineRequestResponse_(soap, (struct srm2__srmStatusOfBringOnlineRequestResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmStatusOfBringOnlineRequestRequest:
		soap_serialize_PointerTosrm2__srmStatusOfBringOnlineRequestRequest(soap, (struct srm2__srmStatusOfBringOnlineRequestRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmStatusOfBringOnlineRequestResponse:
		soap_serialize_PointerTosrm2__srmStatusOfBringOnlineRequestResponse(soap, (struct srm2__srmStatusOfBringOnlineRequestResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmBringOnlineResponse_:
		soap_serialize_PointerTosrm2__srmBringOnlineResponse_(soap, (struct srm2__srmBringOnlineResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmBringOnlineRequest:
		soap_serialize_PointerTosrm2__srmBringOnlineRequest(soap, (struct srm2__srmBringOnlineRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmBringOnlineResponse:
		soap_serialize_PointerTosrm2__srmBringOnlineResponse(soap, (struct srm2__srmBringOnlineResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmStatusOfGetRequestResponse_:
		soap_serialize_PointerTosrm2__srmStatusOfGetRequestResponse_(soap, (struct srm2__srmStatusOfGetRequestResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmStatusOfGetRequestRequest:
		soap_serialize_PointerTosrm2__srmStatusOfGetRequestRequest(soap, (struct srm2__srmStatusOfGetRequestRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmStatusOfGetRequestResponse:
		soap_serialize_PointerTosrm2__srmStatusOfGetRequestResponse(soap, (struct srm2__srmStatusOfGetRequestResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmPrepareToGetResponse_:
		soap_serialize_PointerTosrm2__srmPrepareToGetResponse_(soap, (struct srm2__srmPrepareToGetResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmPrepareToGetRequest:
		soap_serialize_PointerTosrm2__srmPrepareToGetRequest(soap, (struct srm2__srmPrepareToGetRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmPrepareToGetResponse:
		soap_serialize_PointerTosrm2__srmPrepareToGetResponse(soap, (struct srm2__srmPrepareToGetResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmMvResponse_:
		soap_serialize_PointerTosrm2__srmMvResponse_(soap, (struct srm2__srmMvResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmMvRequest:
		soap_serialize_PointerTosrm2__srmMvRequest(soap, (struct srm2__srmMvRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmMvResponse:
		soap_serialize_PointerTosrm2__srmMvResponse(soap, (struct srm2__srmMvResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmStatusOfLsRequestResponse_:
		soap_serialize_PointerTosrm2__srmStatusOfLsRequestResponse_(soap, (struct srm2__srmStatusOfLsRequestResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmStatusOfLsRequestRequest:
		soap_serialize_PointerTosrm2__srmStatusOfLsRequestRequest(soap, (struct srm2__srmStatusOfLsRequestRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmStatusOfLsRequestResponse:
		soap_serialize_PointerTosrm2__srmStatusOfLsRequestResponse(soap, (struct srm2__srmStatusOfLsRequestResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmLsResponse_:
		soap_serialize_PointerTosrm2__srmLsResponse_(soap, (struct srm2__srmLsResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmLsRequest:
		soap_serialize_PointerTosrm2__srmLsRequest(soap, (struct srm2__srmLsRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmLsResponse:
		soap_serialize_PointerTosrm2__srmLsResponse(soap, (struct srm2__srmLsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmRmResponse_:
		soap_serialize_PointerTosrm2__srmRmResponse_(soap, (struct srm2__srmRmResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmRmRequest:
		soap_serialize_PointerTosrm2__srmRmRequest(soap, (struct srm2__srmRmRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmRmResponse:
		soap_serialize_PointerTosrm2__srmRmResponse(soap, (struct srm2__srmRmResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmRmdirResponse_:
		soap_serialize_PointerTosrm2__srmRmdirResponse_(soap, (struct srm2__srmRmdirResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmRmdirRequest:
		soap_serialize_PointerTosrm2__srmRmdirRequest(soap, (struct srm2__srmRmdirRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmRmdirResponse:
		soap_serialize_PointerTosrm2__srmRmdirResponse(soap, (struct srm2__srmRmdirResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmMkdirResponse_:
		soap_serialize_PointerTosrm2__srmMkdirResponse_(soap, (struct srm2__srmMkdirResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmMkdirRequest:
		soap_serialize_PointerTosrm2__srmMkdirRequest(soap, (struct srm2__srmMkdirRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmMkdirResponse:
		soap_serialize_PointerTosrm2__srmMkdirResponse(soap, (struct srm2__srmMkdirResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmGetPermissionResponse_:
		soap_serialize_PointerTosrm2__srmGetPermissionResponse_(soap, (struct srm2__srmGetPermissionResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmGetPermissionRequest:
		soap_serialize_PointerTosrm2__srmGetPermissionRequest(soap, (struct srm2__srmGetPermissionRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmGetPermissionResponse:
		soap_serialize_PointerTosrm2__srmGetPermissionResponse(soap, (struct srm2__srmGetPermissionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmCheckPermissionResponse_:
		soap_serialize_PointerTosrm2__srmCheckPermissionResponse_(soap, (struct srm2__srmCheckPermissionResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmCheckPermissionRequest:
		soap_serialize_PointerTosrm2__srmCheckPermissionRequest(soap, (struct srm2__srmCheckPermissionRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmCheckPermissionResponse:
		soap_serialize_PointerTosrm2__srmCheckPermissionResponse(soap, (struct srm2__srmCheckPermissionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmSetPermissionResponse_:
		soap_serialize_PointerTosrm2__srmSetPermissionResponse_(soap, (struct srm2__srmSetPermissionResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmSetPermissionRequest:
		soap_serialize_PointerTosrm2__srmSetPermissionRequest(soap, (struct srm2__srmSetPermissionRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmSetPermissionResponse:
		soap_serialize_PointerTosrm2__srmSetPermissionResponse(soap, (struct srm2__srmSetPermissionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmGetSpaceTokensResponse_:
		soap_serialize_PointerTosrm2__srmGetSpaceTokensResponse_(soap, (struct srm2__srmGetSpaceTokensResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmGetSpaceTokensRequest:
		soap_serialize_PointerTosrm2__srmGetSpaceTokensRequest(soap, (struct srm2__srmGetSpaceTokensRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmGetSpaceTokensResponse:
		soap_serialize_PointerTosrm2__srmGetSpaceTokensResponse(soap, (struct srm2__srmGetSpaceTokensResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmPurgeFromSpaceResponse_:
		soap_serialize_PointerTosrm2__srmPurgeFromSpaceResponse_(soap, (struct srm2__srmPurgeFromSpaceResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmPurgeFromSpaceRequest:
		soap_serialize_PointerTosrm2__srmPurgeFromSpaceRequest(soap, (struct srm2__srmPurgeFromSpaceRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmPurgeFromSpaceResponse:
		soap_serialize_PointerTosrm2__srmPurgeFromSpaceResponse(soap, (struct srm2__srmPurgeFromSpaceResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmExtendFileLifeTimeInSpaceResponse_:
		soap_serialize_PointerTosrm2__srmExtendFileLifeTimeInSpaceResponse_(soap, (struct srm2__srmExtendFileLifeTimeInSpaceResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmExtendFileLifeTimeInSpaceRequest:
		soap_serialize_PointerTosrm2__srmExtendFileLifeTimeInSpaceRequest(soap, (struct srm2__srmExtendFileLifeTimeInSpaceRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmExtendFileLifeTimeInSpaceResponse:
		soap_serialize_PointerTosrm2__srmExtendFileLifeTimeInSpaceResponse(soap, (struct srm2__srmExtendFileLifeTimeInSpaceResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestResponse_:
		soap_serialize_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestResponse_(soap, (struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestRequest:
		soap_serialize_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestRequest(soap, (struct srm2__srmStatusOfChangeSpaceForFilesRequestRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestResponse:
		soap_serialize_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestResponse(soap, (struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmChangeSpaceForFilesResponse_:
		soap_serialize_PointerTosrm2__srmChangeSpaceForFilesResponse_(soap, (struct srm2__srmChangeSpaceForFilesResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmChangeSpaceForFilesRequest:
		soap_serialize_PointerTosrm2__srmChangeSpaceForFilesRequest(soap, (struct srm2__srmChangeSpaceForFilesRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmChangeSpaceForFilesResponse:
		soap_serialize_PointerTosrm2__srmChangeSpaceForFilesResponse(soap, (struct srm2__srmChangeSpaceForFilesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmGetSpaceMetaDataResponse_:
		soap_serialize_PointerTosrm2__srmGetSpaceMetaDataResponse_(soap, (struct srm2__srmGetSpaceMetaDataResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmGetSpaceMetaDataRequest:
		soap_serialize_PointerTosrm2__srmGetSpaceMetaDataRequest(soap, (struct srm2__srmGetSpaceMetaDataRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmGetSpaceMetaDataResponse:
		soap_serialize_PointerTosrm2__srmGetSpaceMetaDataResponse(soap, (struct srm2__srmGetSpaceMetaDataResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmStatusOfUpdateSpaceRequestResponse_:
		soap_serialize_PointerTosrm2__srmStatusOfUpdateSpaceRequestResponse_(soap, (struct srm2__srmStatusOfUpdateSpaceRequestResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmStatusOfUpdateSpaceRequestRequest:
		soap_serialize_PointerTosrm2__srmStatusOfUpdateSpaceRequestRequest(soap, (struct srm2__srmStatusOfUpdateSpaceRequestRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmStatusOfUpdateSpaceRequestResponse:
		soap_serialize_PointerTosrm2__srmStatusOfUpdateSpaceRequestResponse(soap, (struct srm2__srmStatusOfUpdateSpaceRequestResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmUpdateSpaceResponse_:
		soap_serialize_PointerTosrm2__srmUpdateSpaceResponse_(soap, (struct srm2__srmUpdateSpaceResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmUpdateSpaceRequest:
		soap_serialize_PointerTosrm2__srmUpdateSpaceRequest(soap, (struct srm2__srmUpdateSpaceRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmUpdateSpaceResponse:
		soap_serialize_PointerTosrm2__srmUpdateSpaceResponse(soap, (struct srm2__srmUpdateSpaceResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmReleaseSpaceResponse_:
		soap_serialize_PointerTosrm2__srmReleaseSpaceResponse_(soap, (struct srm2__srmReleaseSpaceResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmReleaseSpaceRequest:
		soap_serialize_PointerTosrm2__srmReleaseSpaceRequest(soap, (struct srm2__srmReleaseSpaceRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmReleaseSpaceResponse:
		soap_serialize_PointerTosrm2__srmReleaseSpaceResponse(soap, (struct srm2__srmReleaseSpaceResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmStatusOfReserveSpaceRequestResponse_:
		soap_serialize_PointerTosrm2__srmStatusOfReserveSpaceRequestResponse_(soap, (struct srm2__srmStatusOfReserveSpaceRequestResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmStatusOfReserveSpaceRequestRequest:
		soap_serialize_PointerTosrm2__srmStatusOfReserveSpaceRequestRequest(soap, (struct srm2__srmStatusOfReserveSpaceRequestRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmStatusOfReserveSpaceRequestResponse:
		soap_serialize_PointerTosrm2__srmStatusOfReserveSpaceRequestResponse(soap, (struct srm2__srmStatusOfReserveSpaceRequestResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmReserveSpaceResponse_:
		soap_serialize_PointerTosrm2__srmReserveSpaceResponse_(soap, (struct srm2__srmReserveSpaceResponse_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmReserveSpaceRequest:
		soap_serialize_PointerTosrm2__srmReserveSpaceRequest(soap, (struct srm2__srmReserveSpaceRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__srmReserveSpaceResponse:
		soap_serialize_PointerTosrm2__srmReserveSpaceResponse(soap, (struct srm2__srmReserveSpaceResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__ArrayOfTSupportedTransferProtocol:
		soap_serialize_PointerTosrm2__ArrayOfTSupportedTransferProtocol(soap, (struct srm2__ArrayOfTSupportedTransferProtocol *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__ArrayOfTRequestTokenReturn:
		soap_serialize_PointerTosrm2__ArrayOfTRequestTokenReturn(soap, (struct srm2__ArrayOfTRequestTokenReturn *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__ArrayOfTRequestSummary:
		soap_serialize_PointerTosrm2__ArrayOfTRequestSummary(soap, (struct srm2__ArrayOfTRequestSummary *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__ArrayOfTCopyRequestFileStatus:
		soap_serialize_PointerTosrm2__ArrayOfTCopyRequestFileStatus(soap, (struct srm2__ArrayOfTCopyRequestFileStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__ArrayOfTCopyFileRequest:
		soap_serialize_PointerTosrm2__ArrayOfTCopyFileRequest(soap, (struct srm2__ArrayOfTCopyFileRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__ArrayOfTPutRequestFileStatus:
		soap_serialize_PointerTosrm2__ArrayOfTPutRequestFileStatus(soap, (struct srm2__ArrayOfTPutRequestFileStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__TOverwriteMode:
		soap_serialize_PointerTosrm2__TOverwriteMode(soap, (enum srm2__TOverwriteMode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__ArrayOfTPutFileRequest:
		soap_serialize_PointerTosrm2__ArrayOfTPutFileRequest(soap, (struct srm2__ArrayOfTPutFileRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__ArrayOfTBringOnlineRequestFileStatus:
		soap_serialize_PointerTosrm2__ArrayOfTBringOnlineRequestFileStatus(soap, (struct srm2__ArrayOfTBringOnlineRequestFileStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__ArrayOfTGetRequestFileStatus:
		soap_serialize_PointerTosrm2__ArrayOfTGetRequestFileStatus(soap, (struct srm2__ArrayOfTGetRequestFileStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__ArrayOfTGetFileRequest:
		soap_serialize_PointerTosrm2__ArrayOfTGetFileRequest(soap, (struct srm2__ArrayOfTGetFileRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__ArrayOfTPermissionReturn:
		soap_serialize_PointerTosrm2__ArrayOfTPermissionReturn(soap, (struct srm2__ArrayOfTPermissionReturn *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__ArrayOfTSURLPermissionReturn:
		soap_serialize_PointerTosrm2__ArrayOfTSURLPermissionReturn(soap, (struct srm2__ArrayOfTSURLPermissionReturn *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__ArrayOfTSURLLifetimeReturnStatus:
		soap_serialize_PointerTosrm2__ArrayOfTSURLLifetimeReturnStatus(soap, (struct srm2__ArrayOfTSURLLifetimeReturnStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__ArrayOfTSURLReturnStatus:
		soap_serialize_PointerTosrm2__ArrayOfTSURLReturnStatus(soap, (struct srm2__ArrayOfTSURLReturnStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__ArrayOfAnyURI:
		soap_serialize_PointerTosrm2__ArrayOfAnyURI(soap, (struct srm2__ArrayOfAnyURI *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__ArrayOfTMetaDataSpace:
		soap_serialize_PointerTosrm2__ArrayOfTMetaDataSpace(soap, (struct srm2__ArrayOfTMetaDataSpace *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__TTransferParameters:
		soap_serialize_PointerTosrm2__TTransferParameters(soap, (struct srm2__TTransferParameters *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__ArrayOfUnsignedLong:
		soap_serialize_PointerTosrm2__ArrayOfUnsignedLong(soap, (struct srm2__ArrayOfUnsignedLong *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTosrm2__TSupportedTransferProtocol:
		soap_serialize_PointerToPointerTosrm2__TSupportedTransferProtocol(soap, (struct srm2__TSupportedTransferProtocol **const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__TSupportedTransferProtocol:
		soap_serialize_PointerTosrm2__TSupportedTransferProtocol(soap, (struct srm2__TSupportedTransferProtocol *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTosrm2__TRequestTokenReturn:
		soap_serialize_PointerToPointerTosrm2__TRequestTokenReturn(soap, (struct srm2__TRequestTokenReturn **const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__TRequestTokenReturn:
		soap_serialize_PointerTosrm2__TRequestTokenReturn(soap, (struct srm2__TRequestTokenReturn *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTosrm2__TPermissionReturn:
		soap_serialize_PointerToPointerTosrm2__TPermissionReturn(soap, (struct srm2__TPermissionReturn **const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__TPermissionReturn:
		soap_serialize_PointerTosrm2__TPermissionReturn(soap, (struct srm2__TPermissionReturn *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__ArrayOfTGroupPermission:
		soap_serialize_PointerTosrm2__ArrayOfTGroupPermission(soap, (struct srm2__ArrayOfTGroupPermission *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__ArrayOfTUserPermission:
		soap_serialize_PointerTosrm2__ArrayOfTUserPermission(soap, (struct srm2__ArrayOfTUserPermission *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTosrm2__TSURLPermissionReturn:
		soap_serialize_PointerToPointerTosrm2__TSURLPermissionReturn(soap, (struct srm2__TSURLPermissionReturn **const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__TSURLPermissionReturn:
		soap_serialize_PointerTosrm2__TSURLPermissionReturn(soap, (struct srm2__TSURLPermissionReturn *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTosrm2__TRequestSummary:
		soap_serialize_PointerToPointerTosrm2__TRequestSummary(soap, (struct srm2__TRequestSummary **const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__TRequestSummary:
		soap_serialize_PointerTosrm2__TRequestSummary(soap, (struct srm2__TRequestSummary *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__TRequestType:
		soap_serialize_PointerTosrm2__TRequestType(soap, (enum srm2__TRequestType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTosrm2__TCopyRequestFileStatus:
		soap_serialize_PointerToPointerTosrm2__TCopyRequestFileStatus(soap, (struct srm2__TCopyRequestFileStatus **const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__TCopyRequestFileStatus:
		soap_serialize_PointerTosrm2__TCopyRequestFileStatus(soap, (struct srm2__TCopyRequestFileStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTosrm2__TPutRequestFileStatus:
		soap_serialize_PointerToPointerTosrm2__TPutRequestFileStatus(soap, (struct srm2__TPutRequestFileStatus **const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__TPutRequestFileStatus:
		soap_serialize_PointerTosrm2__TPutRequestFileStatus(soap, (struct srm2__TPutRequestFileStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTosrm2__TBringOnlineRequestFileStatus:
		soap_serialize_PointerToPointerTosrm2__TBringOnlineRequestFileStatus(soap, (struct srm2__TBringOnlineRequestFileStatus **const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__TBringOnlineRequestFileStatus:
		soap_serialize_PointerTosrm2__TBringOnlineRequestFileStatus(soap, (struct srm2__TBringOnlineRequestFileStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTosrm2__TGetRequestFileStatus:
		soap_serialize_PointerToPointerTosrm2__TGetRequestFileStatus(soap, (struct srm2__TGetRequestFileStatus **const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__TGetRequestFileStatus:
		soap_serialize_PointerTosrm2__TGetRequestFileStatus(soap, (struct srm2__TGetRequestFileStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__ArrayOfTExtraInfo:
		soap_serialize_PointerTosrm2__ArrayOfTExtraInfo(soap, (struct srm2__ArrayOfTExtraInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTosrm2__TCopyFileRequest:
		soap_serialize_PointerToPointerTosrm2__TCopyFileRequest(soap, (struct srm2__TCopyFileRequest **const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__TCopyFileRequest:
		soap_serialize_PointerTosrm2__TCopyFileRequest(soap, (struct srm2__TCopyFileRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTosrm2__TPutFileRequest:
		soap_serialize_PointerToPointerTosrm2__TPutFileRequest(soap, (struct srm2__TPutFileRequest **const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__TPutFileRequest:
		soap_serialize_PointerTosrm2__TPutFileRequest(soap, (struct srm2__TPutFileRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTosrm2__TGetFileRequest:
		soap_serialize_PointerToPointerTosrm2__TGetFileRequest(soap, (struct srm2__TGetFileRequest **const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__TGetFileRequest:
		soap_serialize_PointerTosrm2__TGetFileRequest(soap, (struct srm2__TGetFileRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__TDirOption:
		soap_serialize_PointerTosrm2__TDirOption(soap, (struct srm2__TDirOption *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__TConnectionType:
		soap_serialize_PointerTosrm2__TConnectionType(soap, (enum srm2__TConnectionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__TAccessPattern:
		soap_serialize_PointerTosrm2__TAccessPattern(soap, (enum srm2__TAccessPattern *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__anyURI:
		soap_serialize_PointerToxsd__anyURI(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTosrm2__TExtraInfo:
		soap_serialize_PointerToPointerTosrm2__TExtraInfo(soap, (struct srm2__TExtraInfo **const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__TExtraInfo:
		soap_serialize_PointerTosrm2__TExtraInfo(soap, (struct srm2__TExtraInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__boolean:
		soap_serialize_PointerToxsd__boolean(soap, (enum xsd__boolean *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTosrm2__TMetaDataSpace:
		soap_serialize_PointerToPointerTosrm2__TMetaDataSpace(soap, (struct srm2__TMetaDataSpace **const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__TMetaDataSpace:
		soap_serialize_PointerTosrm2__TMetaDataSpace(soap, (struct srm2__TMetaDataSpace *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTosrm2__TMetaDataPathDetail:
		soap_serialize_PointerToPointerTosrm2__TMetaDataPathDetail(soap, (struct srm2__TMetaDataPathDetail **const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__TMetaDataPathDetail:
		soap_serialize_PointerTosrm2__TMetaDataPathDetail(soap, (struct srm2__TMetaDataPathDetail *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__ArrayOfTMetaDataPathDetail:
		soap_serialize_PointerTosrm2__ArrayOfTMetaDataPathDetail(soap, (struct srm2__ArrayOfTMetaDataPathDetail *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__TPermissionMode:
		soap_serialize_PointerTosrm2__TPermissionMode(soap, (enum srm2__TPermissionMode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__TFileType:
		soap_serialize_PointerTosrm2__TFileType(soap, (enum srm2__TFileType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__ArrayOfString:
		soap_serialize_PointerTosrm2__ArrayOfString(soap, (struct srm2__ArrayOfString *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__TFileLocality:
		soap_serialize_PointerTosrm2__TFileLocality(soap, (enum srm2__TFileLocality *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__TRetentionPolicyInfo:
		soap_serialize_PointerTosrm2__TRetentionPolicyInfo(soap, (struct srm2__TRetentionPolicyInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__TFileStorageType:
		soap_serialize_PointerTosrm2__TFileStorageType(soap, (enum srm2__TFileStorageType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTosrm2__TSURLLifetimeReturnStatus:
		soap_serialize_PointerToPointerTosrm2__TSURLLifetimeReturnStatus(soap, (struct srm2__TSURLLifetimeReturnStatus **const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__TSURLLifetimeReturnStatus:
		soap_serialize_PointerTosrm2__TSURLLifetimeReturnStatus(soap, (struct srm2__TSURLLifetimeReturnStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTosrm2__TSURLReturnStatus:
		soap_serialize_PointerToPointerTosrm2__TSURLReturnStatus(soap, (struct srm2__TSURLReturnStatus **const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__TSURLReturnStatus:
		soap_serialize_PointerTosrm2__TSURLReturnStatus(soap, (struct srm2__TSURLReturnStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__TReturnStatus:
		soap_serialize_PointerTosrm2__TReturnStatus(soap, (struct srm2__TReturnStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedLONG64:
		soap_serialize_PointerTounsignedLONG64(soap, (ULONG64 *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTosrm2__TGroupPermission:
		soap_serialize_PointerToPointerTosrm2__TGroupPermission(soap, (struct srm2__TGroupPermission **const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__TGroupPermission:
		soap_serialize_PointerTosrm2__TGroupPermission(soap, (struct srm2__TGroupPermission *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTosrm2__TUserPermission:
		soap_serialize_PointerToPointerTosrm2__TUserPermission(soap, (struct srm2__TUserPermission **const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__TUserPermission:
		soap_serialize_PointerTosrm2__TUserPermission(soap, (struct srm2__TUserPermission *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosrm2__TAccessLatency:
		soap_serialize_PointerTosrm2__TAccessLatency(soap, (enum srm2__TAccessLatency *const*)ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedLONG64(struct soap *soap, ULONG64 *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedLONG64
	*a = SOAP_DEFAULT_unsignedLONG64;
#else
	*a = (ULONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedLONG64(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedLONG64);
	if (soap_out_unsignedLONG64(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedLONG64(struct soap *soap, const char *tag, int id, const ULONG64 *a, const char *type)
{
	return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_unsignedLONG64);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_get_unsignedLONG64(struct soap *soap, ULONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedLONG64(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_in_unsignedLONG64(struct soap *soap, const char *tag, ULONG64 *a, const char *type)
{
	return soap_inULONG64(soap, tag, a, type, SOAP_TYPE_unsignedLONG64);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__TStatusCode(struct soap *soap, enum srm2__TStatusCode *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_srm2__TStatusCode
	*a = SOAP_DEFAULT_srm2__TStatusCode;
#else
	*a = (enum srm2__TStatusCode)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__TStatusCode(struct soap *soap, const enum srm2__TStatusCode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__TStatusCode);
	if (soap_out_srm2__TStatusCode(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_srm2__TStatusCode[] =
{	{ (long)SRM_USCORESUCCESS, "SRM_SUCCESS" },
	{ (long)SRM_USCOREFAILURE, "SRM_FAILURE" },
	{ (long)SRM_USCOREAUTHENTICATION_USCOREFAILURE, "SRM_AUTHENTICATION_FAILURE" },
	{ (long)SRM_USCOREAUTHORIZATION_USCOREFAILURE, "SRM_AUTHORIZATION_FAILURE" },
	{ (long)SRM_USCOREINVALID_USCOREREQUEST, "SRM_INVALID_REQUEST" },
	{ (long)SRM_USCOREINVALID_USCOREPATH, "SRM_INVALID_PATH" },
	{ (long)SRM_USCOREFILE_USCORELIFETIME_USCOREEXPIRED, "SRM_FILE_LIFETIME_EXPIRED" },
	{ (long)SRM_USCORESPACE_USCORELIFETIME_USCOREEXPIRED, "SRM_SPACE_LIFETIME_EXPIRED" },
	{ (long)SRM_USCOREEXCEED_USCOREALLOCATION, "SRM_EXCEED_ALLOCATION" },
	{ (long)SRM_USCORENO_USCOREUSER_USCORESPACE, "SRM_NO_USER_SPACE" },
	{ (long)SRM_USCORENO_USCOREFREE_USCORESPACE, "SRM_NO_FREE_SPACE" },
	{ (long)SRM_USCOREDUPLICATION_USCOREERROR, "SRM_DUPLICATION_ERROR" },
	{ (long)SRM_USCORENON_USCOREEMPTY_USCOREDIRECTORY, "SRM_NON_EMPTY_DIRECTORY" },
	{ (long)SRM_USCORETOO_USCOREMANY_USCORERESULTS, "SRM_TOO_MANY_RESULTS" },
	{ (long)SRM_USCOREINTERNAL_USCOREERROR, "SRM_INTERNAL_ERROR" },
	{ (long)SRM_USCOREFATAL_USCOREINTERNAL_USCOREERROR, "SRM_FATAL_INTERNAL_ERROR" },
	{ (long)SRM_USCORENOT_USCORESUPPORTED, "SRM_NOT_SUPPORTED" },
	{ (long)SRM_USCOREREQUEST_USCOREQUEUED, "SRM_REQUEST_QUEUED" },
	{ (long)SRM_USCOREREQUEST_USCOREINPROGRESS, "SRM_REQUEST_INPROGRESS" },
	{ (long)SRM_USCOREREQUEST_USCORESUSPENDED, "SRM_REQUEST_SUSPENDED" },
	{ (long)SRM_USCOREABORTED, "SRM_ABORTED" },
	{ (long)SRM_USCORERELEASED, "SRM_RELEASED" },
	{ (long)SRM_USCOREFILE_USCOREPINNED, "SRM_FILE_PINNED" },
	{ (long)SRM_USCOREFILE_USCOREIN_USCORECACHE, "SRM_FILE_IN_CACHE" },
	{ (long)SRM_USCORESPACE_USCOREAVAILABLE, "SRM_SPACE_AVAILABLE" },
	{ (long)SRM_USCORELOWER_USCORESPACE_USCOREGRANTED, "SRM_LOWER_SPACE_GRANTED" },
	{ (long)SRM_USCOREDONE, "SRM_DONE" },
	{ (long)SRM_USCOREPARTIAL_USCORESUCCESS, "SRM_PARTIAL_SUCCESS" },
	{ (long)SRM_USCOREREQUEST_USCORETIMED_USCOREOUT, "SRM_REQUEST_TIMED_OUT" },
	{ (long)SRM_USCORELAST_USCORECOPY, "SRM_LAST_COPY" },
	{ (long)SRM_USCOREFILE_USCOREBUSY, "SRM_FILE_BUSY" },
	{ (long)SRM_USCOREFILE_USCORELOST, "SRM_FILE_LOST" },
	{ (long)SRM_USCOREFILE_USCOREUNAVAILABLE, "SRM_FILE_UNAVAILABLE" },
	{ (long)SRM_USCORECUSTOM_USCORESTATUS, "SRM_CUSTOM_STATUS" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_srm2__TStatusCode2s(struct soap *soap, enum srm2__TStatusCode n)
{	const char *s = soap_str_code(soap_codes_srm2__TStatusCode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__TStatusCode(struct soap *soap, const char *tag, int id, const enum srm2__TStatusCode *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__TStatusCode), type);
	soap_send(soap, soap_srm2__TStatusCode2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum srm2__TStatusCode * SOAP_FMAC4 soap_get_srm2__TStatusCode(struct soap *soap, enum srm2__TStatusCode *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__TStatusCode(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2srm2__TStatusCode(struct soap *soap, const char *s, enum srm2__TStatusCode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_srm2__TStatusCode, s);
	if (map)
		*a = (enum srm2__TStatusCode)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n >= 34)))
			return soap->error = SOAP_TYPE;
		*a = (enum srm2__TStatusCode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum srm2__TStatusCode * SOAP_FMAC4 soap_in_srm2__TStatusCode(struct soap *soap, const char *tag, enum srm2__TStatusCode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum srm2__TStatusCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__TStatusCode, sizeof(enum srm2__TStatusCode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2srm2__TStatusCode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum srm2__TStatusCode *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TStatusCode, 0, sizeof(enum srm2__TStatusCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__TConnectionType(struct soap *soap, enum srm2__TConnectionType *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_srm2__TConnectionType
	*a = SOAP_DEFAULT_srm2__TConnectionType;
#else
	*a = (enum srm2__TConnectionType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__TConnectionType(struct soap *soap, const enum srm2__TConnectionType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__TConnectionType);
	if (soap_out_srm2__TConnectionType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_srm2__TConnectionType[] =
{	{ (long)WAN, "WAN" },
	{ (long)LAN, "LAN" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_srm2__TConnectionType2s(struct soap *soap, enum srm2__TConnectionType n)
{	const char *s = soap_str_code(soap_codes_srm2__TConnectionType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__TConnectionType(struct soap *soap, const char *tag, int id, const enum srm2__TConnectionType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__TConnectionType), type);
	soap_send(soap, soap_srm2__TConnectionType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum srm2__TConnectionType * SOAP_FMAC4 soap_get_srm2__TConnectionType(struct soap *soap, enum srm2__TConnectionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__TConnectionType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2srm2__TConnectionType(struct soap *soap, const char *s, enum srm2__TConnectionType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_srm2__TConnectionType, s);
	if (map)
		*a = (enum srm2__TConnectionType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n >= 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum srm2__TConnectionType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum srm2__TConnectionType * SOAP_FMAC4 soap_in_srm2__TConnectionType(struct soap *soap, const char *tag, enum srm2__TConnectionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum srm2__TConnectionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__TConnectionType, sizeof(enum srm2__TConnectionType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2srm2__TConnectionType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum srm2__TConnectionType *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TConnectionType, 0, sizeof(enum srm2__TConnectionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__TAccessPattern(struct soap *soap, enum srm2__TAccessPattern *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_srm2__TAccessPattern
	*a = SOAP_DEFAULT_srm2__TAccessPattern;
#else
	*a = (enum srm2__TAccessPattern)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__TAccessPattern(struct soap *soap, const enum srm2__TAccessPattern *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__TAccessPattern);
	if (soap_out_srm2__TAccessPattern(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_srm2__TAccessPattern[] =
{	{ (long)TRANSFER_USCOREMODE, "TRANSFER_MODE" },
	{ (long)PROCESSING_USCOREMODE, "PROCESSING_MODE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_srm2__TAccessPattern2s(struct soap *soap, enum srm2__TAccessPattern n)
{	const char *s = soap_str_code(soap_codes_srm2__TAccessPattern, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__TAccessPattern(struct soap *soap, const char *tag, int id, const enum srm2__TAccessPattern *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__TAccessPattern), type);
	soap_send(soap, soap_srm2__TAccessPattern2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum srm2__TAccessPattern * SOAP_FMAC4 soap_get_srm2__TAccessPattern(struct soap *soap, enum srm2__TAccessPattern *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__TAccessPattern(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2srm2__TAccessPattern(struct soap *soap, const char *s, enum srm2__TAccessPattern *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_srm2__TAccessPattern, s);
	if (map)
		*a = (enum srm2__TAccessPattern)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n >= 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum srm2__TAccessPattern)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum srm2__TAccessPattern * SOAP_FMAC4 soap_in_srm2__TAccessPattern(struct soap *soap, const char *tag, enum srm2__TAccessPattern *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum srm2__TAccessPattern *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__TAccessPattern, sizeof(enum srm2__TAccessPattern), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2srm2__TAccessPattern(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum srm2__TAccessPattern *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TAccessPattern, 0, sizeof(enum srm2__TAccessPattern), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__TFileLocality(struct soap *soap, enum srm2__TFileLocality *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_srm2__TFileLocality
	*a = SOAP_DEFAULT_srm2__TFileLocality;
#else
	*a = (enum srm2__TFileLocality)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__TFileLocality(struct soap *soap, const enum srm2__TFileLocality *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__TFileLocality);
	if (soap_out_srm2__TFileLocality(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_srm2__TFileLocality[] =
{	{ (long)ONLINE_, "ONLINE" },
	{ (long)NEARLINE_, "NEARLINE" },
	{ (long)ONLINE_USCOREAND_USCORENEARLINE, "ONLINE_AND_NEARLINE" },
	{ (long)LOST, "LOST" },
	{ (long)NONE_, "NONE" },
	{ (long)UNAVAILABLE, "UNAVAILABLE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_srm2__TFileLocality2s(struct soap *soap, enum srm2__TFileLocality n)
{	const char *s = soap_str_code(soap_codes_srm2__TFileLocality, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__TFileLocality(struct soap *soap, const char *tag, int id, const enum srm2__TFileLocality *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__TFileLocality), type);
	soap_send(soap, soap_srm2__TFileLocality2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum srm2__TFileLocality * SOAP_FMAC4 soap_get_srm2__TFileLocality(struct soap *soap, enum srm2__TFileLocality *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__TFileLocality(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2srm2__TFileLocality(struct soap *soap, const char *s, enum srm2__TFileLocality *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_srm2__TFileLocality, s);
	if (map)
		*a = (enum srm2__TFileLocality)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n >= 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum srm2__TFileLocality)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum srm2__TFileLocality * SOAP_FMAC4 soap_in_srm2__TFileLocality(struct soap *soap, const char *tag, enum srm2__TFileLocality *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum srm2__TFileLocality *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__TFileLocality, sizeof(enum srm2__TFileLocality), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2srm2__TFileLocality(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum srm2__TFileLocality *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TFileLocality, 0, sizeof(enum srm2__TFileLocality), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__TOverwriteMode(struct soap *soap, enum srm2__TOverwriteMode *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_srm2__TOverwriteMode
	*a = SOAP_DEFAULT_srm2__TOverwriteMode;
#else
	*a = (enum srm2__TOverwriteMode)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__TOverwriteMode(struct soap *soap, const enum srm2__TOverwriteMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__TOverwriteMode);
	if (soap_out_srm2__TOverwriteMode(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_srm2__TOverwriteMode[] =
{	{ (long)NEVER, "NEVER" },
	{ (long)ALWAYS, "ALWAYS" },
	{ (long)WHEN_USCOREFILES_USCOREARE_USCOREDIFFERENT, "WHEN_FILES_ARE_DIFFERENT" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_srm2__TOverwriteMode2s(struct soap *soap, enum srm2__TOverwriteMode n)
{	const char *s = soap_str_code(soap_codes_srm2__TOverwriteMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__TOverwriteMode(struct soap *soap, const char *tag, int id, const enum srm2__TOverwriteMode *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__TOverwriteMode), type);
	soap_send(soap, soap_srm2__TOverwriteMode2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum srm2__TOverwriteMode * SOAP_FMAC4 soap_get_srm2__TOverwriteMode(struct soap *soap, enum srm2__TOverwriteMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__TOverwriteMode(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2srm2__TOverwriteMode(struct soap *soap, const char *s, enum srm2__TOverwriteMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_srm2__TOverwriteMode, s);
	if (map)
		*a = (enum srm2__TOverwriteMode)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n >= 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum srm2__TOverwriteMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum srm2__TOverwriteMode * SOAP_FMAC4 soap_in_srm2__TOverwriteMode(struct soap *soap, const char *tag, enum srm2__TOverwriteMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum srm2__TOverwriteMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__TOverwriteMode, sizeof(enum srm2__TOverwriteMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2srm2__TOverwriteMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum srm2__TOverwriteMode *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TOverwriteMode, 0, sizeof(enum srm2__TOverwriteMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__TRequestType(struct soap *soap, enum srm2__TRequestType *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_srm2__TRequestType
	*a = SOAP_DEFAULT_srm2__TRequestType;
#else
	*a = (enum srm2__TRequestType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__TRequestType(struct soap *soap, const enum srm2__TRequestType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__TRequestType);
	if (soap_out_srm2__TRequestType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_srm2__TRequestType[] =
{	{ (long)PREPARE_USCORETO_USCOREGET, "PREPARE_TO_GET" },
	{ (long)PREPARE_USCORETO_USCOREPUT, "PREPARE_TO_PUT" },
	{ (long)COPY, "COPY" },
	{ (long)BRING_USCOREONLINE, "BRING_ONLINE" },
	{ (long)RESERVE_USCORESPACE, "RESERVE_SPACE" },
	{ (long)UPDATE_USCORESPACE, "UPDATE_SPACE" },
	{ (long)CHANGE_USCORESPACE_USCOREFOR_USCOREFILES, "CHANGE_SPACE_FOR_FILES" },
	{ (long)LS, "LS" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_srm2__TRequestType2s(struct soap *soap, enum srm2__TRequestType n)
{	const char *s = soap_str_code(soap_codes_srm2__TRequestType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__TRequestType(struct soap *soap, const char *tag, int id, const enum srm2__TRequestType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__TRequestType), type);
	soap_send(soap, soap_srm2__TRequestType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum srm2__TRequestType * SOAP_FMAC4 soap_get_srm2__TRequestType(struct soap *soap, enum srm2__TRequestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__TRequestType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2srm2__TRequestType(struct soap *soap, const char *s, enum srm2__TRequestType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_srm2__TRequestType, s);
	if (map)
		*a = (enum srm2__TRequestType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n >= 8)))
			return soap->error = SOAP_TYPE;
		*a = (enum srm2__TRequestType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum srm2__TRequestType * SOAP_FMAC4 soap_in_srm2__TRequestType(struct soap *soap, const char *tag, enum srm2__TRequestType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum srm2__TRequestType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__TRequestType, sizeof(enum srm2__TRequestType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2srm2__TRequestType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum srm2__TRequestType *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TRequestType, 0, sizeof(enum srm2__TRequestType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__TPermissionType(struct soap *soap, enum srm2__TPermissionType *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_srm2__TPermissionType
	*a = SOAP_DEFAULT_srm2__TPermissionType;
#else
	*a = (enum srm2__TPermissionType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__TPermissionType(struct soap *soap, const enum srm2__TPermissionType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__TPermissionType);
	if (soap_out_srm2__TPermissionType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_srm2__TPermissionType[] =
{	{ (long)ADD, "ADD" },
	{ (long)REMOVE, "REMOVE" },
	{ (long)CHANGE, "CHANGE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_srm2__TPermissionType2s(struct soap *soap, enum srm2__TPermissionType n)
{	const char *s = soap_str_code(soap_codes_srm2__TPermissionType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__TPermissionType(struct soap *soap, const char *tag, int id, const enum srm2__TPermissionType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__TPermissionType), type);
	soap_send(soap, soap_srm2__TPermissionType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum srm2__TPermissionType * SOAP_FMAC4 soap_get_srm2__TPermissionType(struct soap *soap, enum srm2__TPermissionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__TPermissionType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2srm2__TPermissionType(struct soap *soap, const char *s, enum srm2__TPermissionType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_srm2__TPermissionType, s);
	if (map)
		*a = (enum srm2__TPermissionType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n >= 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum srm2__TPermissionType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum srm2__TPermissionType * SOAP_FMAC4 soap_in_srm2__TPermissionType(struct soap *soap, const char *tag, enum srm2__TPermissionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum srm2__TPermissionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__TPermissionType, sizeof(enum srm2__TPermissionType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2srm2__TPermissionType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum srm2__TPermissionType *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TPermissionType, 0, sizeof(enum srm2__TPermissionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__TPermissionMode(struct soap *soap, enum srm2__TPermissionMode *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_srm2__TPermissionMode
	*a = SOAP_DEFAULT_srm2__TPermissionMode;
#else
	*a = (enum srm2__TPermissionMode)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__TPermissionMode(struct soap *soap, const enum srm2__TPermissionMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__TPermissionMode);
	if (soap_out_srm2__TPermissionMode(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_srm2__TPermissionMode[] =
{	{ (long)NONE, "NONE" },
	{ (long)X, "X" },
	{ (long)W, "W" },
	{ (long)WX, "WX" },
	{ (long)R, "R" },
	{ (long)RX, "RX" },
	{ (long)RW, "RW" },
	{ (long)RWX, "RWX" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_srm2__TPermissionMode2s(struct soap *soap, enum srm2__TPermissionMode n)
{	const char *s = soap_str_code(soap_codes_srm2__TPermissionMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__TPermissionMode(struct soap *soap, const char *tag, int id, const enum srm2__TPermissionMode *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__TPermissionMode), type);
	soap_send(soap, soap_srm2__TPermissionMode2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum srm2__TPermissionMode * SOAP_FMAC4 soap_get_srm2__TPermissionMode(struct soap *soap, enum srm2__TPermissionMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__TPermissionMode(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2srm2__TPermissionMode(struct soap *soap, const char *s, enum srm2__TPermissionMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_srm2__TPermissionMode, s);
	if (map)
		*a = (enum srm2__TPermissionMode)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n >= 8)))
			return soap->error = SOAP_TYPE;
		*a = (enum srm2__TPermissionMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum srm2__TPermissionMode * SOAP_FMAC4 soap_in_srm2__TPermissionMode(struct soap *soap, const char *tag, enum srm2__TPermissionMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum srm2__TPermissionMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__TPermissionMode, sizeof(enum srm2__TPermissionMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2srm2__TPermissionMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum srm2__TPermissionMode *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TPermissionMode, 0, sizeof(enum srm2__TPermissionMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__TAccessLatency(struct soap *soap, enum srm2__TAccessLatency *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_srm2__TAccessLatency
	*a = SOAP_DEFAULT_srm2__TAccessLatency;
#else
	*a = (enum srm2__TAccessLatency)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__TAccessLatency(struct soap *soap, const enum srm2__TAccessLatency *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__TAccessLatency);
	if (soap_out_srm2__TAccessLatency(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_srm2__TAccessLatency[] =
{	{ (long)ONLINE, "ONLINE" },
	{ (long)NEARLINE, "NEARLINE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_srm2__TAccessLatency2s(struct soap *soap, enum srm2__TAccessLatency n)
{	const char *s = soap_str_code(soap_codes_srm2__TAccessLatency, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__TAccessLatency(struct soap *soap, const char *tag, int id, const enum srm2__TAccessLatency *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__TAccessLatency), type);
	soap_send(soap, soap_srm2__TAccessLatency2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum srm2__TAccessLatency * SOAP_FMAC4 soap_get_srm2__TAccessLatency(struct soap *soap, enum srm2__TAccessLatency *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__TAccessLatency(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2srm2__TAccessLatency(struct soap *soap, const char *s, enum srm2__TAccessLatency *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_srm2__TAccessLatency, s);
	if (map)
		*a = (enum srm2__TAccessLatency)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n >= 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum srm2__TAccessLatency)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum srm2__TAccessLatency * SOAP_FMAC4 soap_in_srm2__TAccessLatency(struct soap *soap, const char *tag, enum srm2__TAccessLatency *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum srm2__TAccessLatency *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__TAccessLatency, sizeof(enum srm2__TAccessLatency), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2srm2__TAccessLatency(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum srm2__TAccessLatency *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TAccessLatency, 0, sizeof(enum srm2__TAccessLatency), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__TRetentionPolicy(struct soap *soap, enum srm2__TRetentionPolicy *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_srm2__TRetentionPolicy
	*a = SOAP_DEFAULT_srm2__TRetentionPolicy;
#else
	*a = (enum srm2__TRetentionPolicy)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__TRetentionPolicy(struct soap *soap, const enum srm2__TRetentionPolicy *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__TRetentionPolicy);
	if (soap_out_srm2__TRetentionPolicy(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_srm2__TRetentionPolicy[] =
{	{ (long)REPLICA, "REPLICA" },
	{ (long)OUTPUT, "OUTPUT" },
	{ (long)CUSTODIAL, "CUSTODIAL" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_srm2__TRetentionPolicy2s(struct soap *soap, enum srm2__TRetentionPolicy n)
{	const char *s = soap_str_code(soap_codes_srm2__TRetentionPolicy, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__TRetentionPolicy(struct soap *soap, const char *tag, int id, const enum srm2__TRetentionPolicy *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__TRetentionPolicy), type);
	soap_send(soap, soap_srm2__TRetentionPolicy2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum srm2__TRetentionPolicy * SOAP_FMAC4 soap_get_srm2__TRetentionPolicy(struct soap *soap, enum srm2__TRetentionPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__TRetentionPolicy(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2srm2__TRetentionPolicy(struct soap *soap, const char *s, enum srm2__TRetentionPolicy *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_srm2__TRetentionPolicy, s);
	if (map)
		*a = (enum srm2__TRetentionPolicy)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n >= 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum srm2__TRetentionPolicy)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum srm2__TRetentionPolicy * SOAP_FMAC4 soap_in_srm2__TRetentionPolicy(struct soap *soap, const char *tag, enum srm2__TRetentionPolicy *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum srm2__TRetentionPolicy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__TRetentionPolicy, sizeof(enum srm2__TRetentionPolicy), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2srm2__TRetentionPolicy(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum srm2__TRetentionPolicy *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TRetentionPolicy, 0, sizeof(enum srm2__TRetentionPolicy), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__TFileType(struct soap *soap, enum srm2__TFileType *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_srm2__TFileType
	*a = SOAP_DEFAULT_srm2__TFileType;
#else
	*a = (enum srm2__TFileType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__TFileType(struct soap *soap, const enum srm2__TFileType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__TFileType);
	if (soap_out_srm2__TFileType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_srm2__TFileType[] =
{	{ (long)FILE_, "FILE" },
	{ (long)DIRECTORY, "DIRECTORY" },
	{ (long)LINK, "LINK" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_srm2__TFileType2s(struct soap *soap, enum srm2__TFileType n)
{	const char *s = soap_str_code(soap_codes_srm2__TFileType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__TFileType(struct soap *soap, const char *tag, int id, const enum srm2__TFileType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__TFileType), type);
	soap_send(soap, soap_srm2__TFileType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum srm2__TFileType * SOAP_FMAC4 soap_get_srm2__TFileType(struct soap *soap, enum srm2__TFileType *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__TFileType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2srm2__TFileType(struct soap *soap, const char *s, enum srm2__TFileType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_srm2__TFileType, s);
	if (map)
		*a = (enum srm2__TFileType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n >= 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum srm2__TFileType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum srm2__TFileType * SOAP_FMAC4 soap_in_srm2__TFileType(struct soap *soap, const char *tag, enum srm2__TFileType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum srm2__TFileType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__TFileType, sizeof(enum srm2__TFileType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2srm2__TFileType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum srm2__TFileType *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TFileType, 0, sizeof(enum srm2__TFileType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__TFileStorageType(struct soap *soap, enum srm2__TFileStorageType *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_srm2__TFileStorageType
	*a = SOAP_DEFAULT_srm2__TFileStorageType;
#else
	*a = (enum srm2__TFileStorageType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__TFileStorageType(struct soap *soap, const enum srm2__TFileStorageType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__TFileStorageType);
	if (soap_out_srm2__TFileStorageType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_srm2__TFileStorageType[] =
{	{ (long)VOLATILE, "VOLATILE" },
	{ (long)DURABLE, "DURABLE" },
	{ (long)PERMANENT, "PERMANENT" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_srm2__TFileStorageType2s(struct soap *soap, enum srm2__TFileStorageType n)
{	const char *s = soap_str_code(soap_codes_srm2__TFileStorageType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__TFileStorageType(struct soap *soap, const char *tag, int id, const enum srm2__TFileStorageType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__TFileStorageType), type);
	soap_send(soap, soap_srm2__TFileStorageType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum srm2__TFileStorageType * SOAP_FMAC4 soap_get_srm2__TFileStorageType(struct soap *soap, enum srm2__TFileStorageType *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__TFileStorageType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2srm2__TFileStorageType(struct soap *soap, const char *s, enum srm2__TFileStorageType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_srm2__TFileStorageType, s);
	if (map)
		*a = (enum srm2__TFileStorageType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n >= 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum srm2__TFileStorageType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum srm2__TFileStorageType * SOAP_FMAC4 soap_in_srm2__TFileStorageType(struct soap *soap, const char *tag, enum srm2__TFileStorageType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum srm2__TFileStorageType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__TFileStorageType, sizeof(enum srm2__TFileStorageType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2srm2__TFileStorageType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum srm2__TFileStorageType *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TFileStorageType, 0, sizeof(enum srm2__TFileStorageType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__boolean(struct soap *soap, enum xsd__boolean *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xsd__boolean
	*a = SOAP_DEFAULT_xsd__boolean;
#else
	*a = (enum xsd__boolean)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__boolean(struct soap *soap, const enum xsd__boolean *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__boolean);
	if (soap_out_xsd__boolean(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_xsd__boolean[] =
{	{ (long)false_, "false" },
	{ (long)true_, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__boolean2s(struct soap *soap, enum xsd__boolean n)
{	const char *s = soap_str_code(soap_codes_xsd__boolean, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const enum xsd__boolean *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__boolean), type);
	soap_send(soap, soap_xsd__boolean2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, enum xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__boolean(struct soap *soap, const char *s, enum xsd__boolean *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_xsd__boolean, s);
	if (map)
		*a = (enum xsd__boolean)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n >= 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum xsd__boolean)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum xsd__boolean *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2xsd__boolean(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum xsd__boolean *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_xsd__boolean, 0, sizeof(enum xsd__boolean), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type);
	soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, "");
	soap_out_string(soap, "faultstring", -1, &a->faultstring, "");
	soap_out_string(soap, "faultactor", -1, &a->faultactor, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, "");
	soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, "");
	soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, "");
	soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1, soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type);
	soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	short soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type);
	soap_putelement(soap, a->fault, "fault", -1, a->__type);
	soap_outliteral(soap, "-any", &a->__any);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	short soap_flag_fault = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type);
	soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient dummy skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient dummy skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type);
	/* transient dummy skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient dummy skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmPing(struct soap *soap, const struct srm2__srmPing *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmPingRequest(soap, &a->srmPingRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmPing(struct soap *soap, struct srm2__srmPing *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmPingRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmPing(struct soap *soap, const struct srm2__srmPing *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmPing);
	if (soap_out_srm2__srmPing(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmPing(struct soap *soap, const char *tag, int id, const struct srm2__srmPing *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmPing), type);
	soap_out_PointerTosrm2__srmPingRequest(soap, "srmPingRequest", -1, &a->srmPingRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmPing * SOAP_FMAC4 soap_get_srm2__srmPing(struct soap *soap, struct srm2__srmPing *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmPing(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmPing * SOAP_FMAC4 soap_in_srm2__srmPing(struct soap *soap, const char *tag, struct srm2__srmPing *a, const char *type)
{
	short soap_flag_srmPingRequest = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmPing *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmPing, sizeof(struct srm2__srmPing), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmPing(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmPingRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmPingRequest(soap, "srmPingRequest", &a->srmPingRequest, "srm2:srmPingRequest"))
				{	soap_flag_srmPingRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmPing *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmPing, 0, sizeof(struct srm2__srmPing), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmPingResponse_(struct soap *soap, const struct srm2__srmPingResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmPingResponse(soap, &a->srmPingResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmPingResponse_(struct soap *soap, struct srm2__srmPingResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmPingResponse = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmPingResponse_(struct soap *soap, const struct srm2__srmPingResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmPingResponse_);
	if (soap_out_srm2__srmPingResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmPingResponse_(struct soap *soap, const char *tag, int id, const struct srm2__srmPingResponse_ *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmPingResponse_), type);
	if (a->srmPingResponse)
		soap_element_result(soap, "srmPingResponse");
	soap_out_PointerTosrm2__srmPingResponse(soap, "srmPingResponse", -1, &a->srmPingResponse, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmPingResponse_ * SOAP_FMAC4 soap_get_srm2__srmPingResponse_(struct soap *soap, struct srm2__srmPingResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmPingResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmPingResponse_ * SOAP_FMAC4 soap_in_srm2__srmPingResponse_(struct soap *soap, const char *tag, struct srm2__srmPingResponse_ *a, const char *type)
{
	short soap_flag_srmPingResponse = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmPingResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmPingResponse_, sizeof(struct srm2__srmPingResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmPingResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmPingResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmPingResponse(soap, "srmPingResponse", &a->srmPingResponse, "srm2:srmPingResponse"))
				{	soap_flag_srmPingResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmPingResponse_ *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmPingResponse_, 0, sizeof(struct srm2__srmPingResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmGetTransferProtocols(struct soap *soap, const struct srm2__srmGetTransferProtocols *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmGetTransferProtocolsRequest(soap, &a->srmGetTransferProtocolsRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmGetTransferProtocols(struct soap *soap, struct srm2__srmGetTransferProtocols *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmGetTransferProtocolsRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmGetTransferProtocols(struct soap *soap, const struct srm2__srmGetTransferProtocols *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmGetTransferProtocols);
	if (soap_out_srm2__srmGetTransferProtocols(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmGetTransferProtocols(struct soap *soap, const char *tag, int id, const struct srm2__srmGetTransferProtocols *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmGetTransferProtocols), type);
	soap_out_PointerTosrm2__srmGetTransferProtocolsRequest(soap, "srmGetTransferProtocolsRequest", -1, &a->srmGetTransferProtocolsRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmGetTransferProtocols * SOAP_FMAC4 soap_get_srm2__srmGetTransferProtocols(struct soap *soap, struct srm2__srmGetTransferProtocols *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmGetTransferProtocols(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetTransferProtocols * SOAP_FMAC4 soap_in_srm2__srmGetTransferProtocols(struct soap *soap, const char *tag, struct srm2__srmGetTransferProtocols *a, const char *type)
{
	short soap_flag_srmGetTransferProtocolsRequest = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmGetTransferProtocols *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmGetTransferProtocols, sizeof(struct srm2__srmGetTransferProtocols), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmGetTransferProtocols(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmGetTransferProtocolsRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmGetTransferProtocolsRequest(soap, "srmGetTransferProtocolsRequest", &a->srmGetTransferProtocolsRequest, "srm2:srmGetTransferProtocolsRequest"))
				{	soap_flag_srmGetTransferProtocolsRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetTransferProtocols *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetTransferProtocols, 0, sizeof(struct srm2__srmGetTransferProtocols), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmGetTransferProtocolsResponse_(struct soap *soap, const struct srm2__srmGetTransferProtocolsResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmGetTransferProtocolsResponse(soap, &a->srmGetTransferProtocolsResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmGetTransferProtocolsResponse_(struct soap *soap, struct srm2__srmGetTransferProtocolsResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmGetTransferProtocolsResponse = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmGetTransferProtocolsResponse_(struct soap *soap, const struct srm2__srmGetTransferProtocolsResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmGetTransferProtocolsResponse_);
	if (soap_out_srm2__srmGetTransferProtocolsResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmGetTransferProtocolsResponse_(struct soap *soap, const char *tag, int id, const struct srm2__srmGetTransferProtocolsResponse_ *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmGetTransferProtocolsResponse_), type);
	if (a->srmGetTransferProtocolsResponse)
		soap_element_result(soap, "srmGetTransferProtocolsResponse");
	soap_out_PointerTosrm2__srmGetTransferProtocolsResponse(soap, "srmGetTransferProtocolsResponse", -1, &a->srmGetTransferProtocolsResponse, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmGetTransferProtocolsResponse_ * SOAP_FMAC4 soap_get_srm2__srmGetTransferProtocolsResponse_(struct soap *soap, struct srm2__srmGetTransferProtocolsResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmGetTransferProtocolsResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetTransferProtocolsResponse_ * SOAP_FMAC4 soap_in_srm2__srmGetTransferProtocolsResponse_(struct soap *soap, const char *tag, struct srm2__srmGetTransferProtocolsResponse_ *a, const char *type)
{
	short soap_flag_srmGetTransferProtocolsResponse = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmGetTransferProtocolsResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmGetTransferProtocolsResponse_, sizeof(struct srm2__srmGetTransferProtocolsResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmGetTransferProtocolsResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmGetTransferProtocolsResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmGetTransferProtocolsResponse(soap, "srmGetTransferProtocolsResponse", &a->srmGetTransferProtocolsResponse, "srm2:srmGetTransferProtocolsResponse"))
				{	soap_flag_srmGetTransferProtocolsResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetTransferProtocolsResponse_ *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetTransferProtocolsResponse_, 0, sizeof(struct srm2__srmGetTransferProtocolsResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmGetRequestTokens(struct soap *soap, const struct srm2__srmGetRequestTokens *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmGetRequestTokensRequest(soap, &a->srmGetRequestTokensRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmGetRequestTokens(struct soap *soap, struct srm2__srmGetRequestTokens *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmGetRequestTokensRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmGetRequestTokens(struct soap *soap, const struct srm2__srmGetRequestTokens *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmGetRequestTokens);
	if (soap_out_srm2__srmGetRequestTokens(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmGetRequestTokens(struct soap *soap, const char *tag, int id, const struct srm2__srmGetRequestTokens *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmGetRequestTokens), type);
	soap_out_PointerTosrm2__srmGetRequestTokensRequest(soap, "srmGetRequestTokensRequest", -1, &a->srmGetRequestTokensRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmGetRequestTokens * SOAP_FMAC4 soap_get_srm2__srmGetRequestTokens(struct soap *soap, struct srm2__srmGetRequestTokens *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmGetRequestTokens(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetRequestTokens * SOAP_FMAC4 soap_in_srm2__srmGetRequestTokens(struct soap *soap, const char *tag, struct srm2__srmGetRequestTokens *a, const char *type)
{
	short soap_flag_srmGetRequestTokensRequest = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmGetRequestTokens *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmGetRequestTokens, sizeof(struct srm2__srmGetRequestTokens), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmGetRequestTokens(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmGetRequestTokensRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmGetRequestTokensRequest(soap, "srmGetRequestTokensRequest", &a->srmGetRequestTokensRequest, "srm2:srmGetRequestTokensRequest"))
				{	soap_flag_srmGetRequestTokensRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetRequestTokens *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetRequestTokens, 0, sizeof(struct srm2__srmGetRequestTokens), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmGetRequestTokensResponse_(struct soap *soap, const struct srm2__srmGetRequestTokensResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmGetRequestTokensResponse(soap, &a->srmGetRequestTokensResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmGetRequestTokensResponse_(struct soap *soap, struct srm2__srmGetRequestTokensResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmGetRequestTokensResponse = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmGetRequestTokensResponse_(struct soap *soap, const struct srm2__srmGetRequestTokensResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmGetRequestTokensResponse_);
	if (soap_out_srm2__srmGetRequestTokensResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmGetRequestTokensResponse_(struct soap *soap, const char *tag, int id, const struct srm2__srmGetRequestTokensResponse_ *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmGetRequestTokensResponse_), type);
	if (a->srmGetRequestTokensResponse)
		soap_element_result(soap, "srmGetRequestTokensResponse");
	soap_out_PointerTosrm2__srmGetRequestTokensResponse(soap, "srmGetRequestTokensResponse", -1, &a->srmGetRequestTokensResponse, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmGetRequestTokensResponse_ * SOAP_FMAC4 soap_get_srm2__srmGetRequestTokensResponse_(struct soap *soap, struct srm2__srmGetRequestTokensResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmGetRequestTokensResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetRequestTokensResponse_ * SOAP_FMAC4 soap_in_srm2__srmGetRequestTokensResponse_(struct soap *soap, const char *tag, struct srm2__srmGetRequestTokensResponse_ *a, const char *type)
{
	short soap_flag_srmGetRequestTokensResponse = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmGetRequestTokensResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmGetRequestTokensResponse_, sizeof(struct srm2__srmGetRequestTokensResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmGetRequestTokensResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmGetRequestTokensResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmGetRequestTokensResponse(soap, "srmGetRequestTokensResponse", &a->srmGetRequestTokensResponse, "srm2:srmGetRequestTokensResponse"))
				{	soap_flag_srmGetRequestTokensResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetRequestTokensResponse_ *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetRequestTokensResponse_, 0, sizeof(struct srm2__srmGetRequestTokensResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmExtendFileLifeTime(struct soap *soap, const struct srm2__srmExtendFileLifeTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmExtendFileLifeTimeRequest(soap, &a->srmExtendFileLifeTimeRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmExtendFileLifeTime(struct soap *soap, struct srm2__srmExtendFileLifeTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmExtendFileLifeTimeRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmExtendFileLifeTime(struct soap *soap, const struct srm2__srmExtendFileLifeTime *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmExtendFileLifeTime);
	if (soap_out_srm2__srmExtendFileLifeTime(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmExtendFileLifeTime(struct soap *soap, const char *tag, int id, const struct srm2__srmExtendFileLifeTime *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmExtendFileLifeTime), type);
	soap_out_PointerTosrm2__srmExtendFileLifeTimeRequest(soap, "srmExtendFileLifeTimeRequest", -1, &a->srmExtendFileLifeTimeRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmExtendFileLifeTime * SOAP_FMAC4 soap_get_srm2__srmExtendFileLifeTime(struct soap *soap, struct srm2__srmExtendFileLifeTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmExtendFileLifeTime(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmExtendFileLifeTime * SOAP_FMAC4 soap_in_srm2__srmExtendFileLifeTime(struct soap *soap, const char *tag, struct srm2__srmExtendFileLifeTime *a, const char *type)
{
	short soap_flag_srmExtendFileLifeTimeRequest = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmExtendFileLifeTime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmExtendFileLifeTime, sizeof(struct srm2__srmExtendFileLifeTime), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmExtendFileLifeTime(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmExtendFileLifeTimeRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmExtendFileLifeTimeRequest(soap, "srmExtendFileLifeTimeRequest", &a->srmExtendFileLifeTimeRequest, "srm2:srmExtendFileLifeTimeRequest"))
				{	soap_flag_srmExtendFileLifeTimeRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmExtendFileLifeTime *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmExtendFileLifeTime, 0, sizeof(struct srm2__srmExtendFileLifeTime), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmExtendFileLifeTimeResponse_(struct soap *soap, const struct srm2__srmExtendFileLifeTimeResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmExtendFileLifeTimeResponse(soap, &a->srmExtendFileLifeTimeResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmExtendFileLifeTimeResponse_(struct soap *soap, struct srm2__srmExtendFileLifeTimeResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmExtendFileLifeTimeResponse = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmExtendFileLifeTimeResponse_(struct soap *soap, const struct srm2__srmExtendFileLifeTimeResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmExtendFileLifeTimeResponse_);
	if (soap_out_srm2__srmExtendFileLifeTimeResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmExtendFileLifeTimeResponse_(struct soap *soap, const char *tag, int id, const struct srm2__srmExtendFileLifeTimeResponse_ *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmExtendFileLifeTimeResponse_), type);
	if (a->srmExtendFileLifeTimeResponse)
		soap_element_result(soap, "srmExtendFileLifeTimeResponse");
	soap_out_PointerTosrm2__srmExtendFileLifeTimeResponse(soap, "srmExtendFileLifeTimeResponse", -1, &a->srmExtendFileLifeTimeResponse, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmExtendFileLifeTimeResponse_ * SOAP_FMAC4 soap_get_srm2__srmExtendFileLifeTimeResponse_(struct soap *soap, struct srm2__srmExtendFileLifeTimeResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmExtendFileLifeTimeResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmExtendFileLifeTimeResponse_ * SOAP_FMAC4 soap_in_srm2__srmExtendFileLifeTimeResponse_(struct soap *soap, const char *tag, struct srm2__srmExtendFileLifeTimeResponse_ *a, const char *type)
{
	short soap_flag_srmExtendFileLifeTimeResponse = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmExtendFileLifeTimeResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmExtendFileLifeTimeResponse_, sizeof(struct srm2__srmExtendFileLifeTimeResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmExtendFileLifeTimeResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmExtendFileLifeTimeResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmExtendFileLifeTimeResponse(soap, "srmExtendFileLifeTimeResponse", &a->srmExtendFileLifeTimeResponse, "srm2:srmExtendFileLifeTimeResponse"))
				{	soap_flag_srmExtendFileLifeTimeResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmExtendFileLifeTimeResponse_ *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmExtendFileLifeTimeResponse_, 0, sizeof(struct srm2__srmExtendFileLifeTimeResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmGetRequestSummary(struct soap *soap, const struct srm2__srmGetRequestSummary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmGetRequestSummaryRequest(soap, &a->srmGetRequestSummaryRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmGetRequestSummary(struct soap *soap, struct srm2__srmGetRequestSummary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmGetRequestSummaryRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmGetRequestSummary(struct soap *soap, const struct srm2__srmGetRequestSummary *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmGetRequestSummary);
	if (soap_out_srm2__srmGetRequestSummary(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmGetRequestSummary(struct soap *soap, const char *tag, int id, const struct srm2__srmGetRequestSummary *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmGetRequestSummary), type);
	soap_out_PointerTosrm2__srmGetRequestSummaryRequest(soap, "srmGetRequestSummaryRequest", -1, &a->srmGetRequestSummaryRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmGetRequestSummary * SOAP_FMAC4 soap_get_srm2__srmGetRequestSummary(struct soap *soap, struct srm2__srmGetRequestSummary *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmGetRequestSummary(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetRequestSummary * SOAP_FMAC4 soap_in_srm2__srmGetRequestSummary(struct soap *soap, const char *tag, struct srm2__srmGetRequestSummary *a, const char *type)
{
	short soap_flag_srmGetRequestSummaryRequest = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmGetRequestSummary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmGetRequestSummary, sizeof(struct srm2__srmGetRequestSummary), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmGetRequestSummary(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmGetRequestSummaryRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmGetRequestSummaryRequest(soap, "srmGetRequestSummaryRequest", &a->srmGetRequestSummaryRequest, "srm2:srmGetRequestSummaryRequest"))
				{	soap_flag_srmGetRequestSummaryRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetRequestSummary *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetRequestSummary, 0, sizeof(struct srm2__srmGetRequestSummary), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmGetRequestSummaryResponse_(struct soap *soap, const struct srm2__srmGetRequestSummaryResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmGetRequestSummaryResponse(soap, &a->srmGetRequestSummaryResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmGetRequestSummaryResponse_(struct soap *soap, struct srm2__srmGetRequestSummaryResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmGetRequestSummaryResponse = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmGetRequestSummaryResponse_(struct soap *soap, const struct srm2__srmGetRequestSummaryResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmGetRequestSummaryResponse_);
	if (soap_out_srm2__srmGetRequestSummaryResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmGetRequestSummaryResponse_(struct soap *soap, const char *tag, int id, const struct srm2__srmGetRequestSummaryResponse_ *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmGetRequestSummaryResponse_), type);
	if (a->srmGetRequestSummaryResponse)
		soap_element_result(soap, "srmGetRequestSummaryResponse");
	soap_out_PointerTosrm2__srmGetRequestSummaryResponse(soap, "srmGetRequestSummaryResponse", -1, &a->srmGetRequestSummaryResponse, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmGetRequestSummaryResponse_ * SOAP_FMAC4 soap_get_srm2__srmGetRequestSummaryResponse_(struct soap *soap, struct srm2__srmGetRequestSummaryResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmGetRequestSummaryResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetRequestSummaryResponse_ * SOAP_FMAC4 soap_in_srm2__srmGetRequestSummaryResponse_(struct soap *soap, const char *tag, struct srm2__srmGetRequestSummaryResponse_ *a, const char *type)
{
	short soap_flag_srmGetRequestSummaryResponse = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmGetRequestSummaryResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmGetRequestSummaryResponse_, sizeof(struct srm2__srmGetRequestSummaryResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmGetRequestSummaryResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmGetRequestSummaryResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmGetRequestSummaryResponse(soap, "srmGetRequestSummaryResponse", &a->srmGetRequestSummaryResponse, "srm2:srmGetRequestSummaryResponse"))
				{	soap_flag_srmGetRequestSummaryResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetRequestSummaryResponse_ *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetRequestSummaryResponse_, 0, sizeof(struct srm2__srmGetRequestSummaryResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmResumeRequest(struct soap *soap, const struct srm2__srmResumeRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmResumeRequestRequest(soap, &a->srmResumeRequestRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmResumeRequest(struct soap *soap, struct srm2__srmResumeRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmResumeRequestRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmResumeRequest(struct soap *soap, const struct srm2__srmResumeRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmResumeRequest);
	if (soap_out_srm2__srmResumeRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmResumeRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmResumeRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmResumeRequest), type);
	soap_out_PointerTosrm2__srmResumeRequestRequest(soap, "srmResumeRequestRequest", -1, &a->srmResumeRequestRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmResumeRequest * SOAP_FMAC4 soap_get_srm2__srmResumeRequest(struct soap *soap, struct srm2__srmResumeRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmResumeRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmResumeRequest * SOAP_FMAC4 soap_in_srm2__srmResumeRequest(struct soap *soap, const char *tag, struct srm2__srmResumeRequest *a, const char *type)
{
	short soap_flag_srmResumeRequestRequest = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmResumeRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmResumeRequest, sizeof(struct srm2__srmResumeRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmResumeRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmResumeRequestRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmResumeRequestRequest(soap, "srmResumeRequestRequest", &a->srmResumeRequestRequest, "srm2:srmResumeRequestRequest"))
				{	soap_flag_srmResumeRequestRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmResumeRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmResumeRequest, 0, sizeof(struct srm2__srmResumeRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmResumeRequestResponse_(struct soap *soap, const struct srm2__srmResumeRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmResumeRequestResponse(soap, &a->srmResumeRequestResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmResumeRequestResponse_(struct soap *soap, struct srm2__srmResumeRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmResumeRequestResponse = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmResumeRequestResponse_(struct soap *soap, const struct srm2__srmResumeRequestResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmResumeRequestResponse_);
	if (soap_out_srm2__srmResumeRequestResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmResumeRequestResponse_(struct soap *soap, const char *tag, int id, const struct srm2__srmResumeRequestResponse_ *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmResumeRequestResponse_), type);
	if (a->srmResumeRequestResponse)
		soap_element_result(soap, "srmResumeRequestResponse");
	soap_out_PointerTosrm2__srmResumeRequestResponse(soap, "srmResumeRequestResponse", -1, &a->srmResumeRequestResponse, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmResumeRequestResponse_ * SOAP_FMAC4 soap_get_srm2__srmResumeRequestResponse_(struct soap *soap, struct srm2__srmResumeRequestResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmResumeRequestResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmResumeRequestResponse_ * SOAP_FMAC4 soap_in_srm2__srmResumeRequestResponse_(struct soap *soap, const char *tag, struct srm2__srmResumeRequestResponse_ *a, const char *type)
{
	short soap_flag_srmResumeRequestResponse = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmResumeRequestResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmResumeRequestResponse_, sizeof(struct srm2__srmResumeRequestResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmResumeRequestResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmResumeRequestResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmResumeRequestResponse(soap, "srmResumeRequestResponse", &a->srmResumeRequestResponse, "srm2:srmResumeRequestResponse"))
				{	soap_flag_srmResumeRequestResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmResumeRequestResponse_ *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmResumeRequestResponse_, 0, sizeof(struct srm2__srmResumeRequestResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmSuspendRequest(struct soap *soap, const struct srm2__srmSuspendRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmSuspendRequestRequest(soap, &a->srmSuspendRequestRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmSuspendRequest(struct soap *soap, struct srm2__srmSuspendRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmSuspendRequestRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmSuspendRequest(struct soap *soap, const struct srm2__srmSuspendRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmSuspendRequest);
	if (soap_out_srm2__srmSuspendRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmSuspendRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmSuspendRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmSuspendRequest), type);
	soap_out_PointerTosrm2__srmSuspendRequestRequest(soap, "srmSuspendRequestRequest", -1, &a->srmSuspendRequestRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmSuspendRequest * SOAP_FMAC4 soap_get_srm2__srmSuspendRequest(struct soap *soap, struct srm2__srmSuspendRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmSuspendRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmSuspendRequest * SOAP_FMAC4 soap_in_srm2__srmSuspendRequest(struct soap *soap, const char *tag, struct srm2__srmSuspendRequest *a, const char *type)
{
	short soap_flag_srmSuspendRequestRequest = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmSuspendRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmSuspendRequest, sizeof(struct srm2__srmSuspendRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmSuspendRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmSuspendRequestRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmSuspendRequestRequest(soap, "srmSuspendRequestRequest", &a->srmSuspendRequestRequest, "srm2:srmSuspendRequestRequest"))
				{	soap_flag_srmSuspendRequestRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmSuspendRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmSuspendRequest, 0, sizeof(struct srm2__srmSuspendRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmSuspendRequestResponse_(struct soap *soap, const struct srm2__srmSuspendRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmSuspendRequestResponse(soap, &a->srmSuspendRequestResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmSuspendRequestResponse_(struct soap *soap, struct srm2__srmSuspendRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmSuspendRequestResponse = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmSuspendRequestResponse_(struct soap *soap, const struct srm2__srmSuspendRequestResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmSuspendRequestResponse_);
	if (soap_out_srm2__srmSuspendRequestResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmSuspendRequestResponse_(struct soap *soap, const char *tag, int id, const struct srm2__srmSuspendRequestResponse_ *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmSuspendRequestResponse_), type);
	if (a->srmSuspendRequestResponse)
		soap_element_result(soap, "srmSuspendRequestResponse");
	soap_out_PointerTosrm2__srmSuspendRequestResponse(soap, "srmSuspendRequestResponse", -1, &a->srmSuspendRequestResponse, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmSuspendRequestResponse_ * SOAP_FMAC4 soap_get_srm2__srmSuspendRequestResponse_(struct soap *soap, struct srm2__srmSuspendRequestResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmSuspendRequestResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmSuspendRequestResponse_ * SOAP_FMAC4 soap_in_srm2__srmSuspendRequestResponse_(struct soap *soap, const char *tag, struct srm2__srmSuspendRequestResponse_ *a, const char *type)
{
	short soap_flag_srmSuspendRequestResponse = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmSuspendRequestResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmSuspendRequestResponse_, sizeof(struct srm2__srmSuspendRequestResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmSuspendRequestResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmSuspendRequestResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmSuspendRequestResponse(soap, "srmSuspendRequestResponse", &a->srmSuspendRequestResponse, "srm2:srmSuspendRequestResponse"))
				{	soap_flag_srmSuspendRequestResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmSuspendRequestResponse_ *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmSuspendRequestResponse_, 0, sizeof(struct srm2__srmSuspendRequestResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmAbortFiles(struct soap *soap, const struct srm2__srmAbortFiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmAbortFilesRequest(soap, &a->srmAbortFilesRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmAbortFiles(struct soap *soap, struct srm2__srmAbortFiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmAbortFilesRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmAbortFiles(struct soap *soap, const struct srm2__srmAbortFiles *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmAbortFiles);
	if (soap_out_srm2__srmAbortFiles(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmAbortFiles(struct soap *soap, const char *tag, int id, const struct srm2__srmAbortFiles *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmAbortFiles), type);
	soap_out_PointerTosrm2__srmAbortFilesRequest(soap, "srmAbortFilesRequest", -1, &a->srmAbortFilesRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmAbortFiles * SOAP_FMAC4 soap_get_srm2__srmAbortFiles(struct soap *soap, struct srm2__srmAbortFiles *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmAbortFiles(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmAbortFiles * SOAP_FMAC4 soap_in_srm2__srmAbortFiles(struct soap *soap, const char *tag, struct srm2__srmAbortFiles *a, const char *type)
{
	short soap_flag_srmAbortFilesRequest = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmAbortFiles *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmAbortFiles, sizeof(struct srm2__srmAbortFiles), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmAbortFiles(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmAbortFilesRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmAbortFilesRequest(soap, "srmAbortFilesRequest", &a->srmAbortFilesRequest, "srm2:srmAbortFilesRequest"))
				{	soap_flag_srmAbortFilesRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmAbortFiles *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmAbortFiles, 0, sizeof(struct srm2__srmAbortFiles), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmAbortFilesResponse_(struct soap *soap, const struct srm2__srmAbortFilesResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmAbortFilesResponse(soap, &a->srmAbortFilesResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmAbortFilesResponse_(struct soap *soap, struct srm2__srmAbortFilesResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmAbortFilesResponse = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmAbortFilesResponse_(struct soap *soap, const struct srm2__srmAbortFilesResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmAbortFilesResponse_);
	if (soap_out_srm2__srmAbortFilesResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmAbortFilesResponse_(struct soap *soap, const char *tag, int id, const struct srm2__srmAbortFilesResponse_ *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmAbortFilesResponse_), type);
	if (a->srmAbortFilesResponse)
		soap_element_result(soap, "srmAbortFilesResponse");
	soap_out_PointerTosrm2__srmAbortFilesResponse(soap, "srmAbortFilesResponse", -1, &a->srmAbortFilesResponse, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmAbortFilesResponse_ * SOAP_FMAC4 soap_get_srm2__srmAbortFilesResponse_(struct soap *soap, struct srm2__srmAbortFilesResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmAbortFilesResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmAbortFilesResponse_ * SOAP_FMAC4 soap_in_srm2__srmAbortFilesResponse_(struct soap *soap, const char *tag, struct srm2__srmAbortFilesResponse_ *a, const char *type)
{
	short soap_flag_srmAbortFilesResponse = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmAbortFilesResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmAbortFilesResponse_, sizeof(struct srm2__srmAbortFilesResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmAbortFilesResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmAbortFilesResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmAbortFilesResponse(soap, "srmAbortFilesResponse", &a->srmAbortFilesResponse, "srm2:srmAbortFilesResponse"))
				{	soap_flag_srmAbortFilesResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmAbortFilesResponse_ *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmAbortFilesResponse_, 0, sizeof(struct srm2__srmAbortFilesResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmAbortRequest(struct soap *soap, const struct srm2__srmAbortRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmAbortRequestRequest(soap, &a->srmAbortRequestRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmAbortRequest(struct soap *soap, struct srm2__srmAbortRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmAbortRequestRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmAbortRequest(struct soap *soap, const struct srm2__srmAbortRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmAbortRequest);
	if (soap_out_srm2__srmAbortRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmAbortRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmAbortRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmAbortRequest), type);
	soap_out_PointerTosrm2__srmAbortRequestRequest(soap, "srmAbortRequestRequest", -1, &a->srmAbortRequestRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmAbortRequest * SOAP_FMAC4 soap_get_srm2__srmAbortRequest(struct soap *soap, struct srm2__srmAbortRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmAbortRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmAbortRequest * SOAP_FMAC4 soap_in_srm2__srmAbortRequest(struct soap *soap, const char *tag, struct srm2__srmAbortRequest *a, const char *type)
{
	short soap_flag_srmAbortRequestRequest = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmAbortRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmAbortRequest, sizeof(struct srm2__srmAbortRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmAbortRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmAbortRequestRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmAbortRequestRequest(soap, "srmAbortRequestRequest", &a->srmAbortRequestRequest, "srm2:srmAbortRequestRequest"))
				{	soap_flag_srmAbortRequestRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmAbortRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmAbortRequest, 0, sizeof(struct srm2__srmAbortRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmAbortRequestResponse_(struct soap *soap, const struct srm2__srmAbortRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmAbortRequestResponse(soap, &a->srmAbortRequestResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmAbortRequestResponse_(struct soap *soap, struct srm2__srmAbortRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmAbortRequestResponse = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmAbortRequestResponse_(struct soap *soap, const struct srm2__srmAbortRequestResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmAbortRequestResponse_);
	if (soap_out_srm2__srmAbortRequestResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmAbortRequestResponse_(struct soap *soap, const char *tag, int id, const struct srm2__srmAbortRequestResponse_ *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmAbortRequestResponse_), type);
	if (a->srmAbortRequestResponse)
		soap_element_result(soap, "srmAbortRequestResponse");
	soap_out_PointerTosrm2__srmAbortRequestResponse(soap, "srmAbortRequestResponse", -1, &a->srmAbortRequestResponse, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmAbortRequestResponse_ * SOAP_FMAC4 soap_get_srm2__srmAbortRequestResponse_(struct soap *soap, struct srm2__srmAbortRequestResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmAbortRequestResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmAbortRequestResponse_ * SOAP_FMAC4 soap_in_srm2__srmAbortRequestResponse_(struct soap *soap, const char *tag, struct srm2__srmAbortRequestResponse_ *a, const char *type)
{
	short soap_flag_srmAbortRequestResponse = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmAbortRequestResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmAbortRequestResponse_, sizeof(struct srm2__srmAbortRequestResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmAbortRequestResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmAbortRequestResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmAbortRequestResponse(soap, "srmAbortRequestResponse", &a->srmAbortRequestResponse, "srm2:srmAbortRequestResponse"))
				{	soap_flag_srmAbortRequestResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmAbortRequestResponse_ *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmAbortRequestResponse_, 0, sizeof(struct srm2__srmAbortRequestResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmPutDone(struct soap *soap, const struct srm2__srmPutDone *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmPutDoneRequest(soap, &a->srmPutDoneRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmPutDone(struct soap *soap, struct srm2__srmPutDone *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmPutDoneRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmPutDone(struct soap *soap, const struct srm2__srmPutDone *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmPutDone);
	if (soap_out_srm2__srmPutDone(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmPutDone(struct soap *soap, const char *tag, int id, const struct srm2__srmPutDone *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmPutDone), type);
	soap_out_PointerTosrm2__srmPutDoneRequest(soap, "srmPutDoneRequest", -1, &a->srmPutDoneRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmPutDone * SOAP_FMAC4 soap_get_srm2__srmPutDone(struct soap *soap, struct srm2__srmPutDone *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmPutDone(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmPutDone * SOAP_FMAC4 soap_in_srm2__srmPutDone(struct soap *soap, const char *tag, struct srm2__srmPutDone *a, const char *type)
{
	short soap_flag_srmPutDoneRequest = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmPutDone *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmPutDone, sizeof(struct srm2__srmPutDone), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmPutDone(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmPutDoneRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmPutDoneRequest(soap, "srmPutDoneRequest", &a->srmPutDoneRequest, "srm2:srmPutDoneRequest"))
				{	soap_flag_srmPutDoneRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmPutDone *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmPutDone, 0, sizeof(struct srm2__srmPutDone), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmPutDoneResponse_(struct soap *soap, const struct srm2__srmPutDoneResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmPutDoneResponse(soap, &a->srmPutDoneResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmPutDoneResponse_(struct soap *soap, struct srm2__srmPutDoneResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmPutDoneResponse = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmPutDoneResponse_(struct soap *soap, const struct srm2__srmPutDoneResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmPutDoneResponse_);
	if (soap_out_srm2__srmPutDoneResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmPutDoneResponse_(struct soap *soap, const char *tag, int id, const struct srm2__srmPutDoneResponse_ *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmPutDoneResponse_), type);
	if (a->srmPutDoneResponse)
		soap_element_result(soap, "srmPutDoneResponse");
	soap_out_PointerTosrm2__srmPutDoneResponse(soap, "srmPutDoneResponse", -1, &a->srmPutDoneResponse, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmPutDoneResponse_ * SOAP_FMAC4 soap_get_srm2__srmPutDoneResponse_(struct soap *soap, struct srm2__srmPutDoneResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmPutDoneResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmPutDoneResponse_ * SOAP_FMAC4 soap_in_srm2__srmPutDoneResponse_(struct soap *soap, const char *tag, struct srm2__srmPutDoneResponse_ *a, const char *type)
{
	short soap_flag_srmPutDoneResponse = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmPutDoneResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmPutDoneResponse_, sizeof(struct srm2__srmPutDoneResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmPutDoneResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmPutDoneResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmPutDoneResponse(soap, "srmPutDoneResponse", &a->srmPutDoneResponse, "srm2:srmPutDoneResponse"))
				{	soap_flag_srmPutDoneResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmPutDoneResponse_ *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmPutDoneResponse_, 0, sizeof(struct srm2__srmPutDoneResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmReleaseFiles(struct soap *soap, const struct srm2__srmReleaseFiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmReleaseFilesRequest(soap, &a->srmReleaseFilesRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmReleaseFiles(struct soap *soap, struct srm2__srmReleaseFiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmReleaseFilesRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmReleaseFiles(struct soap *soap, const struct srm2__srmReleaseFiles *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmReleaseFiles);
	if (soap_out_srm2__srmReleaseFiles(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmReleaseFiles(struct soap *soap, const char *tag, int id, const struct srm2__srmReleaseFiles *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmReleaseFiles), type);
	soap_out_PointerTosrm2__srmReleaseFilesRequest(soap, "srmReleaseFilesRequest", -1, &a->srmReleaseFilesRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmReleaseFiles * SOAP_FMAC4 soap_get_srm2__srmReleaseFiles(struct soap *soap, struct srm2__srmReleaseFiles *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmReleaseFiles(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmReleaseFiles * SOAP_FMAC4 soap_in_srm2__srmReleaseFiles(struct soap *soap, const char *tag, struct srm2__srmReleaseFiles *a, const char *type)
{
	short soap_flag_srmReleaseFilesRequest = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmReleaseFiles *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmReleaseFiles, sizeof(struct srm2__srmReleaseFiles), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmReleaseFiles(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmReleaseFilesRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmReleaseFilesRequest(soap, "srmReleaseFilesRequest", &a->srmReleaseFilesRequest, "srm2:srmReleaseFilesRequest"))
				{	soap_flag_srmReleaseFilesRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmReleaseFiles *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmReleaseFiles, 0, sizeof(struct srm2__srmReleaseFiles), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmReleaseFilesResponse_(struct soap *soap, const struct srm2__srmReleaseFilesResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmReleaseFilesResponse(soap, &a->srmReleaseFilesResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmReleaseFilesResponse_(struct soap *soap, struct srm2__srmReleaseFilesResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmReleaseFilesResponse = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmReleaseFilesResponse_(struct soap *soap, const struct srm2__srmReleaseFilesResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmReleaseFilesResponse_);
	if (soap_out_srm2__srmReleaseFilesResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmReleaseFilesResponse_(struct soap *soap, const char *tag, int id, const struct srm2__srmReleaseFilesResponse_ *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmReleaseFilesResponse_), type);
	if (a->srmReleaseFilesResponse)
		soap_element_result(soap, "srmReleaseFilesResponse");
	soap_out_PointerTosrm2__srmReleaseFilesResponse(soap, "srmReleaseFilesResponse", -1, &a->srmReleaseFilesResponse, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmReleaseFilesResponse_ * SOAP_FMAC4 soap_get_srm2__srmReleaseFilesResponse_(struct soap *soap, struct srm2__srmReleaseFilesResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmReleaseFilesResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmReleaseFilesResponse_ * SOAP_FMAC4 soap_in_srm2__srmReleaseFilesResponse_(struct soap *soap, const char *tag, struct srm2__srmReleaseFilesResponse_ *a, const char *type)
{
	short soap_flag_srmReleaseFilesResponse = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmReleaseFilesResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmReleaseFilesResponse_, sizeof(struct srm2__srmReleaseFilesResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmReleaseFilesResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmReleaseFilesResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmReleaseFilesResponse(soap, "srmReleaseFilesResponse", &a->srmReleaseFilesResponse, "srm2:srmReleaseFilesResponse"))
				{	soap_flag_srmReleaseFilesResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmReleaseFilesResponse_ *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmReleaseFilesResponse_, 0, sizeof(struct srm2__srmReleaseFilesResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmStatusOfCopyRequest(struct soap *soap, const struct srm2__srmStatusOfCopyRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmStatusOfCopyRequestRequest(soap, &a->srmStatusOfCopyRequestRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmStatusOfCopyRequest(struct soap *soap, struct srm2__srmStatusOfCopyRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmStatusOfCopyRequestRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmStatusOfCopyRequest(struct soap *soap, const struct srm2__srmStatusOfCopyRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmStatusOfCopyRequest);
	if (soap_out_srm2__srmStatusOfCopyRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmStatusOfCopyRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmStatusOfCopyRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmStatusOfCopyRequest), type);
	soap_out_PointerTosrm2__srmStatusOfCopyRequestRequest(soap, "srmStatusOfCopyRequestRequest", -1, &a->srmStatusOfCopyRequestRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmStatusOfCopyRequest * SOAP_FMAC4 soap_get_srm2__srmStatusOfCopyRequest(struct soap *soap, struct srm2__srmStatusOfCopyRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmStatusOfCopyRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfCopyRequest * SOAP_FMAC4 soap_in_srm2__srmStatusOfCopyRequest(struct soap *soap, const char *tag, struct srm2__srmStatusOfCopyRequest *a, const char *type)
{
	short soap_flag_srmStatusOfCopyRequestRequest = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmStatusOfCopyRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmStatusOfCopyRequest, sizeof(struct srm2__srmStatusOfCopyRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmStatusOfCopyRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmStatusOfCopyRequestRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmStatusOfCopyRequestRequest(soap, "srmStatusOfCopyRequestRequest", &a->srmStatusOfCopyRequestRequest, "srm2:srmStatusOfCopyRequestRequest"))
				{	soap_flag_srmStatusOfCopyRequestRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfCopyRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfCopyRequest, 0, sizeof(struct srm2__srmStatusOfCopyRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmStatusOfCopyRequestResponse_(struct soap *soap, const struct srm2__srmStatusOfCopyRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmStatusOfCopyRequestResponse(soap, &a->srmStatusOfCopyRequestResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmStatusOfCopyRequestResponse_(struct soap *soap, struct srm2__srmStatusOfCopyRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmStatusOfCopyRequestResponse = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmStatusOfCopyRequestResponse_(struct soap *soap, const struct srm2__srmStatusOfCopyRequestResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmStatusOfCopyRequestResponse_);
	if (soap_out_srm2__srmStatusOfCopyRequestResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmStatusOfCopyRequestResponse_(struct soap *soap, const char *tag, int id, const struct srm2__srmStatusOfCopyRequestResponse_ *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmStatusOfCopyRequestResponse_), type);
	if (a->srmStatusOfCopyRequestResponse)
		soap_element_result(soap, "srmStatusOfCopyRequestResponse");
	soap_out_PointerTosrm2__srmStatusOfCopyRequestResponse(soap, "srmStatusOfCopyRequestResponse", -1, &a->srmStatusOfCopyRequestResponse, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmStatusOfCopyRequestResponse_ * SOAP_FMAC4 soap_get_srm2__srmStatusOfCopyRequestResponse_(struct soap *soap, struct srm2__srmStatusOfCopyRequestResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmStatusOfCopyRequestResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfCopyRequestResponse_ * SOAP_FMAC4 soap_in_srm2__srmStatusOfCopyRequestResponse_(struct soap *soap, const char *tag, struct srm2__srmStatusOfCopyRequestResponse_ *a, const char *type)
{
	short soap_flag_srmStatusOfCopyRequestResponse = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmStatusOfCopyRequestResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmStatusOfCopyRequestResponse_, sizeof(struct srm2__srmStatusOfCopyRequestResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmStatusOfCopyRequestResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmStatusOfCopyRequestResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmStatusOfCopyRequestResponse(soap, "srmStatusOfCopyRequestResponse", &a->srmStatusOfCopyRequestResponse, "srm2:srmStatusOfCopyRequestResponse"))
				{	soap_flag_srmStatusOfCopyRequestResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfCopyRequestResponse_ *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfCopyRequestResponse_, 0, sizeof(struct srm2__srmStatusOfCopyRequestResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmCopy(struct soap *soap, const struct srm2__srmCopy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmCopyRequest(soap, &a->srmCopyRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmCopy(struct soap *soap, struct srm2__srmCopy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmCopyRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmCopy(struct soap *soap, const struct srm2__srmCopy *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmCopy);
	if (soap_out_srm2__srmCopy(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmCopy(struct soap *soap, const char *tag, int id, const struct srm2__srmCopy *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmCopy), type);
	soap_out_PointerTosrm2__srmCopyRequest(soap, "srmCopyRequest", -1, &a->srmCopyRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmCopy * SOAP_FMAC4 soap_get_srm2__srmCopy(struct soap *soap, struct srm2__srmCopy *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmCopy(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmCopy * SOAP_FMAC4 soap_in_srm2__srmCopy(struct soap *soap, const char *tag, struct srm2__srmCopy *a, const char *type)
{
	short soap_flag_srmCopyRequest = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmCopy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmCopy, sizeof(struct srm2__srmCopy), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmCopy(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmCopyRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmCopyRequest(soap, "srmCopyRequest", &a->srmCopyRequest, "srm2:srmCopyRequest"))
				{	soap_flag_srmCopyRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmCopy *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmCopy, 0, sizeof(struct srm2__srmCopy), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmCopyResponse_(struct soap *soap, const struct srm2__srmCopyResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmCopyResponse(soap, &a->srmCopyResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmCopyResponse_(struct soap *soap, struct srm2__srmCopyResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmCopyResponse = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmCopyResponse_(struct soap *soap, const struct srm2__srmCopyResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmCopyResponse_);
	if (soap_out_srm2__srmCopyResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmCopyResponse_(struct soap *soap, const char *tag, int id, const struct srm2__srmCopyResponse_ *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmCopyResponse_), type);
	if (a->srmCopyResponse)
		soap_element_result(soap, "srmCopyResponse");
	soap_out_PointerTosrm2__srmCopyResponse(soap, "srmCopyResponse", -1, &a->srmCopyResponse, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmCopyResponse_ * SOAP_FMAC4 soap_get_srm2__srmCopyResponse_(struct soap *soap, struct srm2__srmCopyResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmCopyResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmCopyResponse_ * SOAP_FMAC4 soap_in_srm2__srmCopyResponse_(struct soap *soap, const char *tag, struct srm2__srmCopyResponse_ *a, const char *type)
{
	short soap_flag_srmCopyResponse = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmCopyResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmCopyResponse_, sizeof(struct srm2__srmCopyResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmCopyResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmCopyResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmCopyResponse(soap, "srmCopyResponse", &a->srmCopyResponse, "srm2:srmCopyResponse"))
				{	soap_flag_srmCopyResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmCopyResponse_ *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmCopyResponse_, 0, sizeof(struct srm2__srmCopyResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmStatusOfPutRequest(struct soap *soap, const struct srm2__srmStatusOfPutRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmStatusOfPutRequestRequest(soap, &a->srmStatusOfPutRequestRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmStatusOfPutRequest(struct soap *soap, struct srm2__srmStatusOfPutRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmStatusOfPutRequestRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmStatusOfPutRequest(struct soap *soap, const struct srm2__srmStatusOfPutRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmStatusOfPutRequest);
	if (soap_out_srm2__srmStatusOfPutRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmStatusOfPutRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmStatusOfPutRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmStatusOfPutRequest), type);
	soap_out_PointerTosrm2__srmStatusOfPutRequestRequest(soap, "srmStatusOfPutRequestRequest", -1, &a->srmStatusOfPutRequestRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmStatusOfPutRequest * SOAP_FMAC4 soap_get_srm2__srmStatusOfPutRequest(struct soap *soap, struct srm2__srmStatusOfPutRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmStatusOfPutRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfPutRequest * SOAP_FMAC4 soap_in_srm2__srmStatusOfPutRequest(struct soap *soap, const char *tag, struct srm2__srmStatusOfPutRequest *a, const char *type)
{
	short soap_flag_srmStatusOfPutRequestRequest = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmStatusOfPutRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmStatusOfPutRequest, sizeof(struct srm2__srmStatusOfPutRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmStatusOfPutRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmStatusOfPutRequestRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmStatusOfPutRequestRequest(soap, "srmStatusOfPutRequestRequest", &a->srmStatusOfPutRequestRequest, "srm2:srmStatusOfPutRequestRequest"))
				{	soap_flag_srmStatusOfPutRequestRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfPutRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfPutRequest, 0, sizeof(struct srm2__srmStatusOfPutRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmStatusOfPutRequestResponse_(struct soap *soap, const struct srm2__srmStatusOfPutRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmStatusOfPutRequestResponse(soap, &a->srmStatusOfPutRequestResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmStatusOfPutRequestResponse_(struct soap *soap, struct srm2__srmStatusOfPutRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmStatusOfPutRequestResponse = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmStatusOfPutRequestResponse_(struct soap *soap, const struct srm2__srmStatusOfPutRequestResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmStatusOfPutRequestResponse_);
	if (soap_out_srm2__srmStatusOfPutRequestResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmStatusOfPutRequestResponse_(struct soap *soap, const char *tag, int id, const struct srm2__srmStatusOfPutRequestResponse_ *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmStatusOfPutRequestResponse_), type);
	if (a->srmStatusOfPutRequestResponse)
		soap_element_result(soap, "srmStatusOfPutRequestResponse");
	soap_out_PointerTosrm2__srmStatusOfPutRequestResponse(soap, "srmStatusOfPutRequestResponse", -1, &a->srmStatusOfPutRequestResponse, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmStatusOfPutRequestResponse_ * SOAP_FMAC4 soap_get_srm2__srmStatusOfPutRequestResponse_(struct soap *soap, struct srm2__srmStatusOfPutRequestResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmStatusOfPutRequestResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfPutRequestResponse_ * SOAP_FMAC4 soap_in_srm2__srmStatusOfPutRequestResponse_(struct soap *soap, const char *tag, struct srm2__srmStatusOfPutRequestResponse_ *a, const char *type)
{
	short soap_flag_srmStatusOfPutRequestResponse = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmStatusOfPutRequestResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmStatusOfPutRequestResponse_, sizeof(struct srm2__srmStatusOfPutRequestResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmStatusOfPutRequestResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmStatusOfPutRequestResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmStatusOfPutRequestResponse(soap, "srmStatusOfPutRequestResponse", &a->srmStatusOfPutRequestResponse, "srm2:srmStatusOfPutRequestResponse"))
				{	soap_flag_srmStatusOfPutRequestResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfPutRequestResponse_ *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfPutRequestResponse_, 0, sizeof(struct srm2__srmStatusOfPutRequestResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmPrepareToPut(struct soap *soap, const struct srm2__srmPrepareToPut *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmPrepareToPutRequest(soap, &a->srmPrepareToPutRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmPrepareToPut(struct soap *soap, struct srm2__srmPrepareToPut *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmPrepareToPutRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmPrepareToPut(struct soap *soap, const struct srm2__srmPrepareToPut *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmPrepareToPut);
	if (soap_out_srm2__srmPrepareToPut(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmPrepareToPut(struct soap *soap, const char *tag, int id, const struct srm2__srmPrepareToPut *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmPrepareToPut), type);
	soap_out_PointerTosrm2__srmPrepareToPutRequest(soap, "srmPrepareToPutRequest", -1, &a->srmPrepareToPutRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmPrepareToPut * SOAP_FMAC4 soap_get_srm2__srmPrepareToPut(struct soap *soap, struct srm2__srmPrepareToPut *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmPrepareToPut(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmPrepareToPut * SOAP_FMAC4 soap_in_srm2__srmPrepareToPut(struct soap *soap, const char *tag, struct srm2__srmPrepareToPut *a, const char *type)
{
	short soap_flag_srmPrepareToPutRequest = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmPrepareToPut *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmPrepareToPut, sizeof(struct srm2__srmPrepareToPut), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmPrepareToPut(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmPrepareToPutRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmPrepareToPutRequest(soap, "srmPrepareToPutRequest", &a->srmPrepareToPutRequest, "srm2:srmPrepareToPutRequest"))
				{	soap_flag_srmPrepareToPutRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmPrepareToPut *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmPrepareToPut, 0, sizeof(struct srm2__srmPrepareToPut), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmPrepareToPutResponse_(struct soap *soap, const struct srm2__srmPrepareToPutResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmPrepareToPutResponse(soap, &a->srmPrepareToPutResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmPrepareToPutResponse_(struct soap *soap, struct srm2__srmPrepareToPutResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmPrepareToPutResponse = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmPrepareToPutResponse_(struct soap *soap, const struct srm2__srmPrepareToPutResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmPrepareToPutResponse_);
	if (soap_out_srm2__srmPrepareToPutResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmPrepareToPutResponse_(struct soap *soap, const char *tag, int id, const struct srm2__srmPrepareToPutResponse_ *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmPrepareToPutResponse_), type);
	if (a->srmPrepareToPutResponse)
		soap_element_result(soap, "srmPrepareToPutResponse");
	soap_out_PointerTosrm2__srmPrepareToPutResponse(soap, "srmPrepareToPutResponse", -1, &a->srmPrepareToPutResponse, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmPrepareToPutResponse_ * SOAP_FMAC4 soap_get_srm2__srmPrepareToPutResponse_(struct soap *soap, struct srm2__srmPrepareToPutResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmPrepareToPutResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmPrepareToPutResponse_ * SOAP_FMAC4 soap_in_srm2__srmPrepareToPutResponse_(struct soap *soap, const char *tag, struct srm2__srmPrepareToPutResponse_ *a, const char *type)
{
	short soap_flag_srmPrepareToPutResponse = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmPrepareToPutResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmPrepareToPutResponse_, sizeof(struct srm2__srmPrepareToPutResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmPrepareToPutResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmPrepareToPutResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmPrepareToPutResponse(soap, "srmPrepareToPutResponse", &a->srmPrepareToPutResponse, "srm2:srmPrepareToPutResponse"))
				{	soap_flag_srmPrepareToPutResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmPrepareToPutResponse_ *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmPrepareToPutResponse_, 0, sizeof(struct srm2__srmPrepareToPutResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmStatusOfBringOnlineRequest(struct soap *soap, const struct srm2__srmStatusOfBringOnlineRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmStatusOfBringOnlineRequestRequest(soap, &a->srmStatusOfBringOnlineRequestRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmStatusOfBringOnlineRequest(struct soap *soap, struct srm2__srmStatusOfBringOnlineRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmStatusOfBringOnlineRequestRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmStatusOfBringOnlineRequest(struct soap *soap, const struct srm2__srmStatusOfBringOnlineRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmStatusOfBringOnlineRequest);
	if (soap_out_srm2__srmStatusOfBringOnlineRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmStatusOfBringOnlineRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmStatusOfBringOnlineRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmStatusOfBringOnlineRequest), type);
	soap_out_PointerTosrm2__srmStatusOfBringOnlineRequestRequest(soap, "srmStatusOfBringOnlineRequestRequest", -1, &a->srmStatusOfBringOnlineRequestRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmStatusOfBringOnlineRequest * SOAP_FMAC4 soap_get_srm2__srmStatusOfBringOnlineRequest(struct soap *soap, struct srm2__srmStatusOfBringOnlineRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmStatusOfBringOnlineRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfBringOnlineRequest * SOAP_FMAC4 soap_in_srm2__srmStatusOfBringOnlineRequest(struct soap *soap, const char *tag, struct srm2__srmStatusOfBringOnlineRequest *a, const char *type)
{
	short soap_flag_srmStatusOfBringOnlineRequestRequest = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmStatusOfBringOnlineRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmStatusOfBringOnlineRequest, sizeof(struct srm2__srmStatusOfBringOnlineRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmStatusOfBringOnlineRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmStatusOfBringOnlineRequestRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmStatusOfBringOnlineRequestRequest(soap, "srmStatusOfBringOnlineRequestRequest", &a->srmStatusOfBringOnlineRequestRequest, "srm2:srmStatusOfBringOnlineRequestRequest"))
				{	soap_flag_srmStatusOfBringOnlineRequestRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfBringOnlineRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfBringOnlineRequest, 0, sizeof(struct srm2__srmStatusOfBringOnlineRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmStatusOfBringOnlineRequestResponse_(struct soap *soap, const struct srm2__srmStatusOfBringOnlineRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmStatusOfBringOnlineRequestResponse(soap, &a->srmStatusOfBringOnlineRequestResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmStatusOfBringOnlineRequestResponse_(struct soap *soap, struct srm2__srmStatusOfBringOnlineRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmStatusOfBringOnlineRequestResponse = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmStatusOfBringOnlineRequestResponse_(struct soap *soap, const struct srm2__srmStatusOfBringOnlineRequestResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmStatusOfBringOnlineRequestResponse_);
	if (soap_out_srm2__srmStatusOfBringOnlineRequestResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmStatusOfBringOnlineRequestResponse_(struct soap *soap, const char *tag, int id, const struct srm2__srmStatusOfBringOnlineRequestResponse_ *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmStatusOfBringOnlineRequestResponse_), type);
	if (a->srmStatusOfBringOnlineRequestResponse)
		soap_element_result(soap, "srmStatusOfBringOnlineRequestResponse");
	soap_out_PointerTosrm2__srmStatusOfBringOnlineRequestResponse(soap, "srmStatusOfBringOnlineRequestResponse", -1, &a->srmStatusOfBringOnlineRequestResponse, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmStatusOfBringOnlineRequestResponse_ * SOAP_FMAC4 soap_get_srm2__srmStatusOfBringOnlineRequestResponse_(struct soap *soap, struct srm2__srmStatusOfBringOnlineRequestResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmStatusOfBringOnlineRequestResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfBringOnlineRequestResponse_ * SOAP_FMAC4 soap_in_srm2__srmStatusOfBringOnlineRequestResponse_(struct soap *soap, const char *tag, struct srm2__srmStatusOfBringOnlineRequestResponse_ *a, const char *type)
{
	short soap_flag_srmStatusOfBringOnlineRequestResponse = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmStatusOfBringOnlineRequestResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmStatusOfBringOnlineRequestResponse_, sizeof(struct srm2__srmStatusOfBringOnlineRequestResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmStatusOfBringOnlineRequestResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmStatusOfBringOnlineRequestResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmStatusOfBringOnlineRequestResponse(soap, "srmStatusOfBringOnlineRequestResponse", &a->srmStatusOfBringOnlineRequestResponse, "srm2:srmStatusOfBringOnlineRequestResponse"))
				{	soap_flag_srmStatusOfBringOnlineRequestResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfBringOnlineRequestResponse_ *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfBringOnlineRequestResponse_, 0, sizeof(struct srm2__srmStatusOfBringOnlineRequestResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmBringOnline(struct soap *soap, const struct srm2__srmBringOnline *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmBringOnlineRequest(soap, &a->srmBringOnlineRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmBringOnline(struct soap *soap, struct srm2__srmBringOnline *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmBringOnlineRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmBringOnline(struct soap *soap, const struct srm2__srmBringOnline *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmBringOnline);
	if (soap_out_srm2__srmBringOnline(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmBringOnline(struct soap *soap, const char *tag, int id, const struct srm2__srmBringOnline *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmBringOnline), type);
	soap_out_PointerTosrm2__srmBringOnlineRequest(soap, "srmBringOnlineRequest", -1, &a->srmBringOnlineRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmBringOnline * SOAP_FMAC4 soap_get_srm2__srmBringOnline(struct soap *soap, struct srm2__srmBringOnline *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmBringOnline(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmBringOnline * SOAP_FMAC4 soap_in_srm2__srmBringOnline(struct soap *soap, const char *tag, struct srm2__srmBringOnline *a, const char *type)
{
	short soap_flag_srmBringOnlineRequest = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmBringOnline *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmBringOnline, sizeof(struct srm2__srmBringOnline), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmBringOnline(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmBringOnlineRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmBringOnlineRequest(soap, "srmBringOnlineRequest", &a->srmBringOnlineRequest, "srm2:srmBringOnlineRequest"))
				{	soap_flag_srmBringOnlineRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmBringOnline *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmBringOnline, 0, sizeof(struct srm2__srmBringOnline), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmBringOnlineResponse_(struct soap *soap, const struct srm2__srmBringOnlineResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmBringOnlineResponse(soap, &a->srmBringOnlineResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmBringOnlineResponse_(struct soap *soap, struct srm2__srmBringOnlineResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmBringOnlineResponse = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmBringOnlineResponse_(struct soap *soap, const struct srm2__srmBringOnlineResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmBringOnlineResponse_);
	if (soap_out_srm2__srmBringOnlineResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmBringOnlineResponse_(struct soap *soap, const char *tag, int id, const struct srm2__srmBringOnlineResponse_ *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmBringOnlineResponse_), type);
	if (a->srmBringOnlineResponse)
		soap_element_result(soap, "srmBringOnlineResponse");
	soap_out_PointerTosrm2__srmBringOnlineResponse(soap, "srmBringOnlineResponse", -1, &a->srmBringOnlineResponse, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmBringOnlineResponse_ * SOAP_FMAC4 soap_get_srm2__srmBringOnlineResponse_(struct soap *soap, struct srm2__srmBringOnlineResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmBringOnlineResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmBringOnlineResponse_ * SOAP_FMAC4 soap_in_srm2__srmBringOnlineResponse_(struct soap *soap, const char *tag, struct srm2__srmBringOnlineResponse_ *a, const char *type)
{
	short soap_flag_srmBringOnlineResponse = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmBringOnlineResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmBringOnlineResponse_, sizeof(struct srm2__srmBringOnlineResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmBringOnlineResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmBringOnlineResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmBringOnlineResponse(soap, "srmBringOnlineResponse", &a->srmBringOnlineResponse, "srm2:srmBringOnlineResponse"))
				{	soap_flag_srmBringOnlineResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmBringOnlineResponse_ *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmBringOnlineResponse_, 0, sizeof(struct srm2__srmBringOnlineResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmStatusOfGetRequest(struct soap *soap, const struct srm2__srmStatusOfGetRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmStatusOfGetRequestRequest(soap, &a->srmStatusOfGetRequestRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmStatusOfGetRequest(struct soap *soap, struct srm2__srmStatusOfGetRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmStatusOfGetRequestRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmStatusOfGetRequest(struct soap *soap, const struct srm2__srmStatusOfGetRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmStatusOfGetRequest);
	if (soap_out_srm2__srmStatusOfGetRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmStatusOfGetRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmStatusOfGetRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmStatusOfGetRequest), type);
	soap_out_PointerTosrm2__srmStatusOfGetRequestRequest(soap, "srmStatusOfGetRequestRequest", -1, &a->srmStatusOfGetRequestRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmStatusOfGetRequest * SOAP_FMAC4 soap_get_srm2__srmStatusOfGetRequest(struct soap *soap, struct srm2__srmStatusOfGetRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmStatusOfGetRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfGetRequest * SOAP_FMAC4 soap_in_srm2__srmStatusOfGetRequest(struct soap *soap, const char *tag, struct srm2__srmStatusOfGetRequest *a, const char *type)
{
	short soap_flag_srmStatusOfGetRequestRequest = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmStatusOfGetRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmStatusOfGetRequest, sizeof(struct srm2__srmStatusOfGetRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmStatusOfGetRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmStatusOfGetRequestRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmStatusOfGetRequestRequest(soap, "srmStatusOfGetRequestRequest", &a->srmStatusOfGetRequestRequest, "srm2:srmStatusOfGetRequestRequest"))
				{	soap_flag_srmStatusOfGetRequestRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfGetRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfGetRequest, 0, sizeof(struct srm2__srmStatusOfGetRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmStatusOfGetRequestResponse_(struct soap *soap, const struct srm2__srmStatusOfGetRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmStatusOfGetRequestResponse(soap, &a->srmStatusOfGetRequestResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmStatusOfGetRequestResponse_(struct soap *soap, struct srm2__srmStatusOfGetRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmStatusOfGetRequestResponse = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmStatusOfGetRequestResponse_(struct soap *soap, const struct srm2__srmStatusOfGetRequestResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmStatusOfGetRequestResponse_);
	if (soap_out_srm2__srmStatusOfGetRequestResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmStatusOfGetRequestResponse_(struct soap *soap, const char *tag, int id, const struct srm2__srmStatusOfGetRequestResponse_ *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmStatusOfGetRequestResponse_), type);
	if (a->srmStatusOfGetRequestResponse)
		soap_element_result(soap, "srmStatusOfGetRequestResponse");
	soap_out_PointerTosrm2__srmStatusOfGetRequestResponse(soap, "srmStatusOfGetRequestResponse", -1, &a->srmStatusOfGetRequestResponse, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmStatusOfGetRequestResponse_ * SOAP_FMAC4 soap_get_srm2__srmStatusOfGetRequestResponse_(struct soap *soap, struct srm2__srmStatusOfGetRequestResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmStatusOfGetRequestResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfGetRequestResponse_ * SOAP_FMAC4 soap_in_srm2__srmStatusOfGetRequestResponse_(struct soap *soap, const char *tag, struct srm2__srmStatusOfGetRequestResponse_ *a, const char *type)
{
	short soap_flag_srmStatusOfGetRequestResponse = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmStatusOfGetRequestResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmStatusOfGetRequestResponse_, sizeof(struct srm2__srmStatusOfGetRequestResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmStatusOfGetRequestResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmStatusOfGetRequestResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmStatusOfGetRequestResponse(soap, "srmStatusOfGetRequestResponse", &a->srmStatusOfGetRequestResponse, "srm2:srmStatusOfGetRequestResponse"))
				{	soap_flag_srmStatusOfGetRequestResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfGetRequestResponse_ *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfGetRequestResponse_, 0, sizeof(struct srm2__srmStatusOfGetRequestResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmPrepareToGet(struct soap *soap, const struct srm2__srmPrepareToGet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmPrepareToGetRequest(soap, &a->srmPrepareToGetRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmPrepareToGet(struct soap *soap, struct srm2__srmPrepareToGet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmPrepareToGetRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmPrepareToGet(struct soap *soap, const struct srm2__srmPrepareToGet *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmPrepareToGet);
	if (soap_out_srm2__srmPrepareToGet(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmPrepareToGet(struct soap *soap, const char *tag, int id, const struct srm2__srmPrepareToGet *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmPrepareToGet), type);
	soap_out_PointerTosrm2__srmPrepareToGetRequest(soap, "srmPrepareToGetRequest", -1, &a->srmPrepareToGetRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmPrepareToGet * SOAP_FMAC4 soap_get_srm2__srmPrepareToGet(struct soap *soap, struct srm2__srmPrepareToGet *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmPrepareToGet(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmPrepareToGet * SOAP_FMAC4 soap_in_srm2__srmPrepareToGet(struct soap *soap, const char *tag, struct srm2__srmPrepareToGet *a, const char *type)
{
	short soap_flag_srmPrepareToGetRequest = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmPrepareToGet *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmPrepareToGet, sizeof(struct srm2__srmPrepareToGet), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmPrepareToGet(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmPrepareToGetRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmPrepareToGetRequest(soap, "srmPrepareToGetRequest", &a->srmPrepareToGetRequest, "srm2:srmPrepareToGetRequest"))
				{	soap_flag_srmPrepareToGetRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmPrepareToGet *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmPrepareToGet, 0, sizeof(struct srm2__srmPrepareToGet), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmPrepareToGetResponse_(struct soap *soap, const struct srm2__srmPrepareToGetResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmPrepareToGetResponse(soap, &a->srmPrepareToGetResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmPrepareToGetResponse_(struct soap *soap, struct srm2__srmPrepareToGetResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmPrepareToGetResponse = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmPrepareToGetResponse_(struct soap *soap, const struct srm2__srmPrepareToGetResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmPrepareToGetResponse_);
	if (soap_out_srm2__srmPrepareToGetResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmPrepareToGetResponse_(struct soap *soap, const char *tag, int id, const struct srm2__srmPrepareToGetResponse_ *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmPrepareToGetResponse_), type);
	if (a->srmPrepareToGetResponse)
		soap_element_result(soap, "srmPrepareToGetResponse");
	soap_out_PointerTosrm2__srmPrepareToGetResponse(soap, "srmPrepareToGetResponse", -1, &a->srmPrepareToGetResponse, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmPrepareToGetResponse_ * SOAP_FMAC4 soap_get_srm2__srmPrepareToGetResponse_(struct soap *soap, struct srm2__srmPrepareToGetResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmPrepareToGetResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmPrepareToGetResponse_ * SOAP_FMAC4 soap_in_srm2__srmPrepareToGetResponse_(struct soap *soap, const char *tag, struct srm2__srmPrepareToGetResponse_ *a, const char *type)
{
	short soap_flag_srmPrepareToGetResponse = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmPrepareToGetResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmPrepareToGetResponse_, sizeof(struct srm2__srmPrepareToGetResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmPrepareToGetResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmPrepareToGetResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmPrepareToGetResponse(soap, "srmPrepareToGetResponse", &a->srmPrepareToGetResponse, "srm2:srmPrepareToGetResponse"))
				{	soap_flag_srmPrepareToGetResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmPrepareToGetResponse_ *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmPrepareToGetResponse_, 0, sizeof(struct srm2__srmPrepareToGetResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmMv(struct soap *soap, const struct srm2__srmMv *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmMvRequest(soap, &a->srmMvRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmMv(struct soap *soap, struct srm2__srmMv *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmMvRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmMv(struct soap *soap, const struct srm2__srmMv *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmMv);
	if (soap_out_srm2__srmMv(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmMv(struct soap *soap, const char *tag, int id, const struct srm2__srmMv *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmMv), type);
	soap_out_PointerTosrm2__srmMvRequest(soap, "srmMvRequest", -1, &a->srmMvRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmMv * SOAP_FMAC4 soap_get_srm2__srmMv(struct soap *soap, struct srm2__srmMv *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmMv(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmMv * SOAP_FMAC4 soap_in_srm2__srmMv(struct soap *soap, const char *tag, struct srm2__srmMv *a, const char *type)
{
	short soap_flag_srmMvRequest = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmMv *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmMv, sizeof(struct srm2__srmMv), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmMv(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmMvRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmMvRequest(soap, "srmMvRequest", &a->srmMvRequest, "srm2:srmMvRequest"))
				{	soap_flag_srmMvRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmMv *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmMv, 0, sizeof(struct srm2__srmMv), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmMvResponse_(struct soap *soap, const struct srm2__srmMvResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmMvResponse(soap, &a->srmMvResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmMvResponse_(struct soap *soap, struct srm2__srmMvResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmMvResponse = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmMvResponse_(struct soap *soap, const struct srm2__srmMvResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmMvResponse_);
	if (soap_out_srm2__srmMvResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmMvResponse_(struct soap *soap, const char *tag, int id, const struct srm2__srmMvResponse_ *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmMvResponse_), type);
	if (a->srmMvResponse)
		soap_element_result(soap, "srmMvResponse");
	soap_out_PointerTosrm2__srmMvResponse(soap, "srmMvResponse", -1, &a->srmMvResponse, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmMvResponse_ * SOAP_FMAC4 soap_get_srm2__srmMvResponse_(struct soap *soap, struct srm2__srmMvResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmMvResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmMvResponse_ * SOAP_FMAC4 soap_in_srm2__srmMvResponse_(struct soap *soap, const char *tag, struct srm2__srmMvResponse_ *a, const char *type)
{
	short soap_flag_srmMvResponse = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmMvResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmMvResponse_, sizeof(struct srm2__srmMvResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmMvResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmMvResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmMvResponse(soap, "srmMvResponse", &a->srmMvResponse, "srm2:srmMvResponse"))
				{	soap_flag_srmMvResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmMvResponse_ *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmMvResponse_, 0, sizeof(struct srm2__srmMvResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmStatusOfLsRequest(struct soap *soap, const struct srm2__srmStatusOfLsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmStatusOfLsRequestRequest(soap, &a->srmStatusOfLsRequestRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmStatusOfLsRequest(struct soap *soap, struct srm2__srmStatusOfLsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmStatusOfLsRequestRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmStatusOfLsRequest(struct soap *soap, const struct srm2__srmStatusOfLsRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmStatusOfLsRequest);
	if (soap_out_srm2__srmStatusOfLsRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmStatusOfLsRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmStatusOfLsRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmStatusOfLsRequest), type);
	soap_out_PointerTosrm2__srmStatusOfLsRequestRequest(soap, "srmStatusOfLsRequestRequest", -1, &a->srmStatusOfLsRequestRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmStatusOfLsRequest * SOAP_FMAC4 soap_get_srm2__srmStatusOfLsRequest(struct soap *soap, struct srm2__srmStatusOfLsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmStatusOfLsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfLsRequest * SOAP_FMAC4 soap_in_srm2__srmStatusOfLsRequest(struct soap *soap, const char *tag, struct srm2__srmStatusOfLsRequest *a, const char *type)
{
	short soap_flag_srmStatusOfLsRequestRequest = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmStatusOfLsRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmStatusOfLsRequest, sizeof(struct srm2__srmStatusOfLsRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmStatusOfLsRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmStatusOfLsRequestRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmStatusOfLsRequestRequest(soap, "srmStatusOfLsRequestRequest", &a->srmStatusOfLsRequestRequest, "srm2:srmStatusOfLsRequestRequest"))
				{	soap_flag_srmStatusOfLsRequestRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfLsRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfLsRequest, 0, sizeof(struct srm2__srmStatusOfLsRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmStatusOfLsRequestResponse_(struct soap *soap, const struct srm2__srmStatusOfLsRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmStatusOfLsRequestResponse(soap, &a->srmStatusOfLsRequestResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmStatusOfLsRequestResponse_(struct soap *soap, struct srm2__srmStatusOfLsRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmStatusOfLsRequestResponse = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmStatusOfLsRequestResponse_(struct soap *soap, const struct srm2__srmStatusOfLsRequestResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmStatusOfLsRequestResponse_);
	if (soap_out_srm2__srmStatusOfLsRequestResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmStatusOfLsRequestResponse_(struct soap *soap, const char *tag, int id, const struct srm2__srmStatusOfLsRequestResponse_ *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmStatusOfLsRequestResponse_), type);
	if (a->srmStatusOfLsRequestResponse)
		soap_element_result(soap, "srmStatusOfLsRequestResponse");
	soap_out_PointerTosrm2__srmStatusOfLsRequestResponse(soap, "srmStatusOfLsRequestResponse", -1, &a->srmStatusOfLsRequestResponse, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmStatusOfLsRequestResponse_ * SOAP_FMAC4 soap_get_srm2__srmStatusOfLsRequestResponse_(struct soap *soap, struct srm2__srmStatusOfLsRequestResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmStatusOfLsRequestResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfLsRequestResponse_ * SOAP_FMAC4 soap_in_srm2__srmStatusOfLsRequestResponse_(struct soap *soap, const char *tag, struct srm2__srmStatusOfLsRequestResponse_ *a, const char *type)
{
	short soap_flag_srmStatusOfLsRequestResponse = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmStatusOfLsRequestResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmStatusOfLsRequestResponse_, sizeof(struct srm2__srmStatusOfLsRequestResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmStatusOfLsRequestResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmStatusOfLsRequestResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmStatusOfLsRequestResponse(soap, "srmStatusOfLsRequestResponse", &a->srmStatusOfLsRequestResponse, "srm2:srmStatusOfLsRequestResponse"))
				{	soap_flag_srmStatusOfLsRequestResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfLsRequestResponse_ *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfLsRequestResponse_, 0, sizeof(struct srm2__srmStatusOfLsRequestResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmLs(struct soap *soap, const struct srm2__srmLs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmLsRequest(soap, &a->srmLsRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmLs(struct soap *soap, struct srm2__srmLs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmLsRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmLs(struct soap *soap, const struct srm2__srmLs *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmLs);
	if (soap_out_srm2__srmLs(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmLs(struct soap *soap, const char *tag, int id, const struct srm2__srmLs *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmLs), type);
	soap_out_PointerTosrm2__srmLsRequest(soap, "srmLsRequest", -1, &a->srmLsRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmLs * SOAP_FMAC4 soap_get_srm2__srmLs(struct soap *soap, struct srm2__srmLs *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmLs(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmLs * SOAP_FMAC4 soap_in_srm2__srmLs(struct soap *soap, const char *tag, struct srm2__srmLs *a, const char *type)
{
	short soap_flag_srmLsRequest = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmLs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmLs, sizeof(struct srm2__srmLs), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmLs(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmLsRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmLsRequest(soap, "srmLsRequest", &a->srmLsRequest, "srm2:srmLsRequest"))
				{	soap_flag_srmLsRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmLs *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmLs, 0, sizeof(struct srm2__srmLs), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmLsResponse_(struct soap *soap, const struct srm2__srmLsResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmLsResponse(soap, &a->srmLsResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmLsResponse_(struct soap *soap, struct srm2__srmLsResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmLsResponse = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmLsResponse_(struct soap *soap, const struct srm2__srmLsResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmLsResponse_);
	if (soap_out_srm2__srmLsResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmLsResponse_(struct soap *soap, const char *tag, int id, const struct srm2__srmLsResponse_ *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmLsResponse_), type);
	if (a->srmLsResponse)
		soap_element_result(soap, "srmLsResponse");
	soap_out_PointerTosrm2__srmLsResponse(soap, "srmLsResponse", -1, &a->srmLsResponse, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmLsResponse_ * SOAP_FMAC4 soap_get_srm2__srmLsResponse_(struct soap *soap, struct srm2__srmLsResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmLsResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmLsResponse_ * SOAP_FMAC4 soap_in_srm2__srmLsResponse_(struct soap *soap, const char *tag, struct srm2__srmLsResponse_ *a, const char *type)
{
	short soap_flag_srmLsResponse = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmLsResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmLsResponse_, sizeof(struct srm2__srmLsResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmLsResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmLsResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmLsResponse(soap, "srmLsResponse", &a->srmLsResponse, "srm2:srmLsResponse"))
				{	soap_flag_srmLsResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmLsResponse_ *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmLsResponse_, 0, sizeof(struct srm2__srmLsResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmRm(struct soap *soap, const struct srm2__srmRm *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmRmRequest(soap, &a->srmRmRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmRm(struct soap *soap, struct srm2__srmRm *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmRmRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmRm(struct soap *soap, const struct srm2__srmRm *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmRm);
	if (soap_out_srm2__srmRm(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmRm(struct soap *soap, const char *tag, int id, const struct srm2__srmRm *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmRm), type);
	soap_out_PointerTosrm2__srmRmRequest(soap, "srmRmRequest", -1, &a->srmRmRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmRm * SOAP_FMAC4 soap_get_srm2__srmRm(struct soap *soap, struct srm2__srmRm *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmRm(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmRm * SOAP_FMAC4 soap_in_srm2__srmRm(struct soap *soap, const char *tag, struct srm2__srmRm *a, const char *type)
{
	short soap_flag_srmRmRequest = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmRm *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmRm, sizeof(struct srm2__srmRm), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmRm(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmRmRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmRmRequest(soap, "srmRmRequest", &a->srmRmRequest, "srm2:srmRmRequest"))
				{	soap_flag_srmRmRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmRm *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmRm, 0, sizeof(struct srm2__srmRm), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmRmResponse_(struct soap *soap, const struct srm2__srmRmResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmRmResponse(soap, &a->srmRmResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmRmResponse_(struct soap *soap, struct srm2__srmRmResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmRmResponse = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmRmResponse_(struct soap *soap, const struct srm2__srmRmResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmRmResponse_);
	if (soap_out_srm2__srmRmResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmRmResponse_(struct soap *soap, const char *tag, int id, const struct srm2__srmRmResponse_ *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmRmResponse_), type);
	if (a->srmRmResponse)
		soap_element_result(soap, "srmRmResponse");
	soap_out_PointerTosrm2__srmRmResponse(soap, "srmRmResponse", -1, &a->srmRmResponse, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmRmResponse_ * SOAP_FMAC4 soap_get_srm2__srmRmResponse_(struct soap *soap, struct srm2__srmRmResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmRmResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmRmResponse_ * SOAP_FMAC4 soap_in_srm2__srmRmResponse_(struct soap *soap, const char *tag, struct srm2__srmRmResponse_ *a, const char *type)
{
	short soap_flag_srmRmResponse = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmRmResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmRmResponse_, sizeof(struct srm2__srmRmResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmRmResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmRmResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmRmResponse(soap, "srmRmResponse", &a->srmRmResponse, "srm2:srmRmResponse"))
				{	soap_flag_srmRmResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmRmResponse_ *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmRmResponse_, 0, sizeof(struct srm2__srmRmResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmRmdir(struct soap *soap, const struct srm2__srmRmdir *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmRmdirRequest(soap, &a->srmRmdirRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmRmdir(struct soap *soap, struct srm2__srmRmdir *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmRmdirRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmRmdir(struct soap *soap, const struct srm2__srmRmdir *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmRmdir);
	if (soap_out_srm2__srmRmdir(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmRmdir(struct soap *soap, const char *tag, int id, const struct srm2__srmRmdir *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmRmdir), type);
	soap_out_PointerTosrm2__srmRmdirRequest(soap, "srmRmdirRequest", -1, &a->srmRmdirRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmRmdir * SOAP_FMAC4 soap_get_srm2__srmRmdir(struct soap *soap, struct srm2__srmRmdir *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmRmdir(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmRmdir * SOAP_FMAC4 soap_in_srm2__srmRmdir(struct soap *soap, const char *tag, struct srm2__srmRmdir *a, const char *type)
{
	short soap_flag_srmRmdirRequest = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmRmdir *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmRmdir, sizeof(struct srm2__srmRmdir), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmRmdir(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmRmdirRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmRmdirRequest(soap, "srmRmdirRequest", &a->srmRmdirRequest, "srm2:srmRmdirRequest"))
				{	soap_flag_srmRmdirRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmRmdir *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmRmdir, 0, sizeof(struct srm2__srmRmdir), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmRmdirResponse_(struct soap *soap, const struct srm2__srmRmdirResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmRmdirResponse(soap, &a->srmRmdirResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmRmdirResponse_(struct soap *soap, struct srm2__srmRmdirResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmRmdirResponse = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmRmdirResponse_(struct soap *soap, const struct srm2__srmRmdirResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmRmdirResponse_);
	if (soap_out_srm2__srmRmdirResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmRmdirResponse_(struct soap *soap, const char *tag, int id, const struct srm2__srmRmdirResponse_ *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmRmdirResponse_), type);
	if (a->srmRmdirResponse)
		soap_element_result(soap, "srmRmdirResponse");
	soap_out_PointerTosrm2__srmRmdirResponse(soap, "srmRmdirResponse", -1, &a->srmRmdirResponse, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmRmdirResponse_ * SOAP_FMAC4 soap_get_srm2__srmRmdirResponse_(struct soap *soap, struct srm2__srmRmdirResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmRmdirResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmRmdirResponse_ * SOAP_FMAC4 soap_in_srm2__srmRmdirResponse_(struct soap *soap, const char *tag, struct srm2__srmRmdirResponse_ *a, const char *type)
{
	short soap_flag_srmRmdirResponse = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmRmdirResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmRmdirResponse_, sizeof(struct srm2__srmRmdirResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmRmdirResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmRmdirResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmRmdirResponse(soap, "srmRmdirResponse", &a->srmRmdirResponse, "srm2:srmRmdirResponse"))
				{	soap_flag_srmRmdirResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmRmdirResponse_ *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmRmdirResponse_, 0, sizeof(struct srm2__srmRmdirResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmMkdir(struct soap *soap, const struct srm2__srmMkdir *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmMkdirRequest(soap, &a->srmMkdirRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmMkdir(struct soap *soap, struct srm2__srmMkdir *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmMkdirRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmMkdir(struct soap *soap, const struct srm2__srmMkdir *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmMkdir);
	if (soap_out_srm2__srmMkdir(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmMkdir(struct soap *soap, const char *tag, int id, const struct srm2__srmMkdir *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmMkdir), type);
	soap_out_PointerTosrm2__srmMkdirRequest(soap, "srmMkdirRequest", -1, &a->srmMkdirRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmMkdir * SOAP_FMAC4 soap_get_srm2__srmMkdir(struct soap *soap, struct srm2__srmMkdir *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmMkdir(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmMkdir * SOAP_FMAC4 soap_in_srm2__srmMkdir(struct soap *soap, const char *tag, struct srm2__srmMkdir *a, const char *type)
{
	short soap_flag_srmMkdirRequest = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmMkdir *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmMkdir, sizeof(struct srm2__srmMkdir), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmMkdir(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmMkdirRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmMkdirRequest(soap, "srmMkdirRequest", &a->srmMkdirRequest, "srm2:srmMkdirRequest"))
				{	soap_flag_srmMkdirRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmMkdir *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmMkdir, 0, sizeof(struct srm2__srmMkdir), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmMkdirResponse_(struct soap *soap, const struct srm2__srmMkdirResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmMkdirResponse(soap, &a->srmMkdirResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmMkdirResponse_(struct soap *soap, struct srm2__srmMkdirResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmMkdirResponse = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmMkdirResponse_(struct soap *soap, const struct srm2__srmMkdirResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmMkdirResponse_);
	if (soap_out_srm2__srmMkdirResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmMkdirResponse_(struct soap *soap, const char *tag, int id, const struct srm2__srmMkdirResponse_ *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmMkdirResponse_), type);
	if (a->srmMkdirResponse)
		soap_element_result(soap, "srmMkdirResponse");
	soap_out_PointerTosrm2__srmMkdirResponse(soap, "srmMkdirResponse", -1, &a->srmMkdirResponse, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmMkdirResponse_ * SOAP_FMAC4 soap_get_srm2__srmMkdirResponse_(struct soap *soap, struct srm2__srmMkdirResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmMkdirResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmMkdirResponse_ * SOAP_FMAC4 soap_in_srm2__srmMkdirResponse_(struct soap *soap, const char *tag, struct srm2__srmMkdirResponse_ *a, const char *type)
{
	short soap_flag_srmMkdirResponse = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmMkdirResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmMkdirResponse_, sizeof(struct srm2__srmMkdirResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmMkdirResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmMkdirResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmMkdirResponse(soap, "srmMkdirResponse", &a->srmMkdirResponse, "srm2:srmMkdirResponse"))
				{	soap_flag_srmMkdirResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmMkdirResponse_ *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmMkdirResponse_, 0, sizeof(struct srm2__srmMkdirResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmGetPermission(struct soap *soap, const struct srm2__srmGetPermission *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmGetPermissionRequest(soap, &a->srmGetPermissionRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmGetPermission(struct soap *soap, struct srm2__srmGetPermission *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmGetPermissionRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmGetPermission(struct soap *soap, const struct srm2__srmGetPermission *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmGetPermission);
	if (soap_out_srm2__srmGetPermission(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmGetPermission(struct soap *soap, const char *tag, int id, const struct srm2__srmGetPermission *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmGetPermission), type);
	soap_out_PointerTosrm2__srmGetPermissionRequest(soap, "srmGetPermissionRequest", -1, &a->srmGetPermissionRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmGetPermission * SOAP_FMAC4 soap_get_srm2__srmGetPermission(struct soap *soap, struct srm2__srmGetPermission *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmGetPermission(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetPermission * SOAP_FMAC4 soap_in_srm2__srmGetPermission(struct soap *soap, const char *tag, struct srm2__srmGetPermission *a, const char *type)
{
	short soap_flag_srmGetPermissionRequest = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmGetPermission *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmGetPermission, sizeof(struct srm2__srmGetPermission), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmGetPermission(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmGetPermissionRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmGetPermissionRequest(soap, "srmGetPermissionRequest", &a->srmGetPermissionRequest, "srm2:srmGetPermissionRequest"))
				{	soap_flag_srmGetPermissionRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetPermission *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetPermission, 0, sizeof(struct srm2__srmGetPermission), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmGetPermissionResponse_(struct soap *soap, const struct srm2__srmGetPermissionResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmGetPermissionResponse(soap, &a->srmGetPermissionResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmGetPermissionResponse_(struct soap *soap, struct srm2__srmGetPermissionResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmGetPermissionResponse = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmGetPermissionResponse_(struct soap *soap, const struct srm2__srmGetPermissionResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmGetPermissionResponse_);
	if (soap_out_srm2__srmGetPermissionResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmGetPermissionResponse_(struct soap *soap, const char *tag, int id, const struct srm2__srmGetPermissionResponse_ *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmGetPermissionResponse_), type);
	if (a->srmGetPermissionResponse)
		soap_element_result(soap, "srmGetPermissionResponse");
	soap_out_PointerTosrm2__srmGetPermissionResponse(soap, "srmGetPermissionResponse", -1, &a->srmGetPermissionResponse, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmGetPermissionResponse_ * SOAP_FMAC4 soap_get_srm2__srmGetPermissionResponse_(struct soap *soap, struct srm2__srmGetPermissionResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmGetPermissionResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetPermissionResponse_ * SOAP_FMAC4 soap_in_srm2__srmGetPermissionResponse_(struct soap *soap, const char *tag, struct srm2__srmGetPermissionResponse_ *a, const char *type)
{
	short soap_flag_srmGetPermissionResponse = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmGetPermissionResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmGetPermissionResponse_, sizeof(struct srm2__srmGetPermissionResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmGetPermissionResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmGetPermissionResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmGetPermissionResponse(soap, "srmGetPermissionResponse", &a->srmGetPermissionResponse, "srm2:srmGetPermissionResponse"))
				{	soap_flag_srmGetPermissionResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetPermissionResponse_ *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetPermissionResponse_, 0, sizeof(struct srm2__srmGetPermissionResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmCheckPermission(struct soap *soap, const struct srm2__srmCheckPermission *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmCheckPermissionRequest(soap, &a->srmCheckPermissionRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmCheckPermission(struct soap *soap, struct srm2__srmCheckPermission *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmCheckPermissionRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmCheckPermission(struct soap *soap, const struct srm2__srmCheckPermission *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmCheckPermission);
	if (soap_out_srm2__srmCheckPermission(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmCheckPermission(struct soap *soap, const char *tag, int id, const struct srm2__srmCheckPermission *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmCheckPermission), type);
	soap_out_PointerTosrm2__srmCheckPermissionRequest(soap, "srmCheckPermissionRequest", -1, &a->srmCheckPermissionRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmCheckPermission * SOAP_FMAC4 soap_get_srm2__srmCheckPermission(struct soap *soap, struct srm2__srmCheckPermission *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmCheckPermission(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmCheckPermission * SOAP_FMAC4 soap_in_srm2__srmCheckPermission(struct soap *soap, const char *tag, struct srm2__srmCheckPermission *a, const char *type)
{
	short soap_flag_srmCheckPermissionRequest = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmCheckPermission *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmCheckPermission, sizeof(struct srm2__srmCheckPermission), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmCheckPermission(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmCheckPermissionRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmCheckPermissionRequest(soap, "srmCheckPermissionRequest", &a->srmCheckPermissionRequest, "srm2:srmCheckPermissionRequest"))
				{	soap_flag_srmCheckPermissionRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmCheckPermission *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmCheckPermission, 0, sizeof(struct srm2__srmCheckPermission), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmCheckPermissionResponse_(struct soap *soap, const struct srm2__srmCheckPermissionResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmCheckPermissionResponse(soap, &a->srmCheckPermissionResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmCheckPermissionResponse_(struct soap *soap, struct srm2__srmCheckPermissionResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmCheckPermissionResponse = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmCheckPermissionResponse_(struct soap *soap, const struct srm2__srmCheckPermissionResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmCheckPermissionResponse_);
	if (soap_out_srm2__srmCheckPermissionResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmCheckPermissionResponse_(struct soap *soap, const char *tag, int id, const struct srm2__srmCheckPermissionResponse_ *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmCheckPermissionResponse_), type);
	if (a->srmCheckPermissionResponse)
		soap_element_result(soap, "srmCheckPermissionResponse");
	soap_out_PointerTosrm2__srmCheckPermissionResponse(soap, "srmCheckPermissionResponse", -1, &a->srmCheckPermissionResponse, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmCheckPermissionResponse_ * SOAP_FMAC4 soap_get_srm2__srmCheckPermissionResponse_(struct soap *soap, struct srm2__srmCheckPermissionResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmCheckPermissionResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmCheckPermissionResponse_ * SOAP_FMAC4 soap_in_srm2__srmCheckPermissionResponse_(struct soap *soap, const char *tag, struct srm2__srmCheckPermissionResponse_ *a, const char *type)
{
	short soap_flag_srmCheckPermissionResponse = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmCheckPermissionResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmCheckPermissionResponse_, sizeof(struct srm2__srmCheckPermissionResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmCheckPermissionResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmCheckPermissionResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmCheckPermissionResponse(soap, "srmCheckPermissionResponse", &a->srmCheckPermissionResponse, "srm2:srmCheckPermissionResponse"))
				{	soap_flag_srmCheckPermissionResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmCheckPermissionResponse_ *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmCheckPermissionResponse_, 0, sizeof(struct srm2__srmCheckPermissionResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmSetPermission(struct soap *soap, const struct srm2__srmSetPermission *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmSetPermissionRequest(soap, &a->srmSetPermissionRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmSetPermission(struct soap *soap, struct srm2__srmSetPermission *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmSetPermissionRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmSetPermission(struct soap *soap, const struct srm2__srmSetPermission *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmSetPermission);
	if (soap_out_srm2__srmSetPermission(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmSetPermission(struct soap *soap, const char *tag, int id, const struct srm2__srmSetPermission *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmSetPermission), type);
	soap_out_PointerTosrm2__srmSetPermissionRequest(soap, "srmSetPermissionRequest", -1, &a->srmSetPermissionRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmSetPermission * SOAP_FMAC4 soap_get_srm2__srmSetPermission(struct soap *soap, struct srm2__srmSetPermission *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmSetPermission(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmSetPermission * SOAP_FMAC4 soap_in_srm2__srmSetPermission(struct soap *soap, const char *tag, struct srm2__srmSetPermission *a, const char *type)
{
	short soap_flag_srmSetPermissionRequest = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmSetPermission *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmSetPermission, sizeof(struct srm2__srmSetPermission), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmSetPermission(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmSetPermissionRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmSetPermissionRequest(soap, "srmSetPermissionRequest", &a->srmSetPermissionRequest, "srm2:srmSetPermissionRequest"))
				{	soap_flag_srmSetPermissionRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmSetPermission *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmSetPermission, 0, sizeof(struct srm2__srmSetPermission), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmSetPermissionResponse_(struct soap *soap, const struct srm2__srmSetPermissionResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmSetPermissionResponse(soap, &a->srmSetPermissionResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmSetPermissionResponse_(struct soap *soap, struct srm2__srmSetPermissionResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmSetPermissionResponse = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmSetPermissionResponse_(struct soap *soap, const struct srm2__srmSetPermissionResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmSetPermissionResponse_);
	if (soap_out_srm2__srmSetPermissionResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmSetPermissionResponse_(struct soap *soap, const char *tag, int id, const struct srm2__srmSetPermissionResponse_ *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmSetPermissionResponse_), type);
	if (a->srmSetPermissionResponse)
		soap_element_result(soap, "srmSetPermissionResponse");
	soap_out_PointerTosrm2__srmSetPermissionResponse(soap, "srmSetPermissionResponse", -1, &a->srmSetPermissionResponse, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmSetPermissionResponse_ * SOAP_FMAC4 soap_get_srm2__srmSetPermissionResponse_(struct soap *soap, struct srm2__srmSetPermissionResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmSetPermissionResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmSetPermissionResponse_ * SOAP_FMAC4 soap_in_srm2__srmSetPermissionResponse_(struct soap *soap, const char *tag, struct srm2__srmSetPermissionResponse_ *a, const char *type)
{
	short soap_flag_srmSetPermissionResponse = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmSetPermissionResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmSetPermissionResponse_, sizeof(struct srm2__srmSetPermissionResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmSetPermissionResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmSetPermissionResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmSetPermissionResponse(soap, "srmSetPermissionResponse", &a->srmSetPermissionResponse, "srm2:srmSetPermissionResponse"))
				{	soap_flag_srmSetPermissionResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmSetPermissionResponse_ *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmSetPermissionResponse_, 0, sizeof(struct srm2__srmSetPermissionResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmGetSpaceTokens(struct soap *soap, const struct srm2__srmGetSpaceTokens *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmGetSpaceTokensRequest(soap, &a->srmGetSpaceTokensRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmGetSpaceTokens(struct soap *soap, struct srm2__srmGetSpaceTokens *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmGetSpaceTokensRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmGetSpaceTokens(struct soap *soap, const struct srm2__srmGetSpaceTokens *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmGetSpaceTokens);
	if (soap_out_srm2__srmGetSpaceTokens(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmGetSpaceTokens(struct soap *soap, const char *tag, int id, const struct srm2__srmGetSpaceTokens *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmGetSpaceTokens), type);
	soap_out_PointerTosrm2__srmGetSpaceTokensRequest(soap, "srmGetSpaceTokensRequest", -1, &a->srmGetSpaceTokensRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmGetSpaceTokens * SOAP_FMAC4 soap_get_srm2__srmGetSpaceTokens(struct soap *soap, struct srm2__srmGetSpaceTokens *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmGetSpaceTokens(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetSpaceTokens * SOAP_FMAC4 soap_in_srm2__srmGetSpaceTokens(struct soap *soap, const char *tag, struct srm2__srmGetSpaceTokens *a, const char *type)
{
	short soap_flag_srmGetSpaceTokensRequest = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmGetSpaceTokens *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmGetSpaceTokens, sizeof(struct srm2__srmGetSpaceTokens), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmGetSpaceTokens(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmGetSpaceTokensRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmGetSpaceTokensRequest(soap, "srmGetSpaceTokensRequest", &a->srmGetSpaceTokensRequest, "srm2:srmGetSpaceTokensRequest"))
				{	soap_flag_srmGetSpaceTokensRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetSpaceTokens *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetSpaceTokens, 0, sizeof(struct srm2__srmGetSpaceTokens), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmGetSpaceTokensResponse_(struct soap *soap, const struct srm2__srmGetSpaceTokensResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmGetSpaceTokensResponse(soap, &a->srmGetSpaceTokensResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmGetSpaceTokensResponse_(struct soap *soap, struct srm2__srmGetSpaceTokensResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmGetSpaceTokensResponse = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmGetSpaceTokensResponse_(struct soap *soap, const struct srm2__srmGetSpaceTokensResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmGetSpaceTokensResponse_);
	if (soap_out_srm2__srmGetSpaceTokensResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmGetSpaceTokensResponse_(struct soap *soap, const char *tag, int id, const struct srm2__srmGetSpaceTokensResponse_ *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmGetSpaceTokensResponse_), type);
	if (a->srmGetSpaceTokensResponse)
		soap_element_result(soap, "srmGetSpaceTokensResponse");
	soap_out_PointerTosrm2__srmGetSpaceTokensResponse(soap, "srmGetSpaceTokensResponse", -1, &a->srmGetSpaceTokensResponse, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmGetSpaceTokensResponse_ * SOAP_FMAC4 soap_get_srm2__srmGetSpaceTokensResponse_(struct soap *soap, struct srm2__srmGetSpaceTokensResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmGetSpaceTokensResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetSpaceTokensResponse_ * SOAP_FMAC4 soap_in_srm2__srmGetSpaceTokensResponse_(struct soap *soap, const char *tag, struct srm2__srmGetSpaceTokensResponse_ *a, const char *type)
{
	short soap_flag_srmGetSpaceTokensResponse = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmGetSpaceTokensResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmGetSpaceTokensResponse_, sizeof(struct srm2__srmGetSpaceTokensResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmGetSpaceTokensResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmGetSpaceTokensResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmGetSpaceTokensResponse(soap, "srmGetSpaceTokensResponse", &a->srmGetSpaceTokensResponse, "srm2:srmGetSpaceTokensResponse"))
				{	soap_flag_srmGetSpaceTokensResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetSpaceTokensResponse_ *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetSpaceTokensResponse_, 0, sizeof(struct srm2__srmGetSpaceTokensResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmPurgeFromSpace(struct soap *soap, const struct srm2__srmPurgeFromSpace *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmPurgeFromSpaceRequest(soap, &a->srmPurgeFromSpaceRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmPurgeFromSpace(struct soap *soap, struct srm2__srmPurgeFromSpace *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmPurgeFromSpaceRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmPurgeFromSpace(struct soap *soap, const struct srm2__srmPurgeFromSpace *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmPurgeFromSpace);
	if (soap_out_srm2__srmPurgeFromSpace(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmPurgeFromSpace(struct soap *soap, const char *tag, int id, const struct srm2__srmPurgeFromSpace *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmPurgeFromSpace), type);
	soap_out_PointerTosrm2__srmPurgeFromSpaceRequest(soap, "srmPurgeFromSpaceRequest", -1, &a->srmPurgeFromSpaceRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmPurgeFromSpace * SOAP_FMAC4 soap_get_srm2__srmPurgeFromSpace(struct soap *soap, struct srm2__srmPurgeFromSpace *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmPurgeFromSpace(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmPurgeFromSpace * SOAP_FMAC4 soap_in_srm2__srmPurgeFromSpace(struct soap *soap, const char *tag, struct srm2__srmPurgeFromSpace *a, const char *type)
{
	short soap_flag_srmPurgeFromSpaceRequest = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmPurgeFromSpace *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmPurgeFromSpace, sizeof(struct srm2__srmPurgeFromSpace), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmPurgeFromSpace(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmPurgeFromSpaceRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmPurgeFromSpaceRequest(soap, "srmPurgeFromSpaceRequest", &a->srmPurgeFromSpaceRequest, "srm2:srmPurgeFromSpaceRequest"))
				{	soap_flag_srmPurgeFromSpaceRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmPurgeFromSpace *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmPurgeFromSpace, 0, sizeof(struct srm2__srmPurgeFromSpace), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmPurgeFromSpaceResponse_(struct soap *soap, const struct srm2__srmPurgeFromSpaceResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmPurgeFromSpaceResponse(soap, &a->srmPurgeFromSpaceResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmPurgeFromSpaceResponse_(struct soap *soap, struct srm2__srmPurgeFromSpaceResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmPurgeFromSpaceResponse = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmPurgeFromSpaceResponse_(struct soap *soap, const struct srm2__srmPurgeFromSpaceResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmPurgeFromSpaceResponse_);
	if (soap_out_srm2__srmPurgeFromSpaceResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmPurgeFromSpaceResponse_(struct soap *soap, const char *tag, int id, const struct srm2__srmPurgeFromSpaceResponse_ *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmPurgeFromSpaceResponse_), type);
	if (a->srmPurgeFromSpaceResponse)
		soap_element_result(soap, "srmPurgeFromSpaceResponse");
	soap_out_PointerTosrm2__srmPurgeFromSpaceResponse(soap, "srmPurgeFromSpaceResponse", -1, &a->srmPurgeFromSpaceResponse, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmPurgeFromSpaceResponse_ * SOAP_FMAC4 soap_get_srm2__srmPurgeFromSpaceResponse_(struct soap *soap, struct srm2__srmPurgeFromSpaceResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmPurgeFromSpaceResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmPurgeFromSpaceResponse_ * SOAP_FMAC4 soap_in_srm2__srmPurgeFromSpaceResponse_(struct soap *soap, const char *tag, struct srm2__srmPurgeFromSpaceResponse_ *a, const char *type)
{
	short soap_flag_srmPurgeFromSpaceResponse = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmPurgeFromSpaceResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmPurgeFromSpaceResponse_, sizeof(struct srm2__srmPurgeFromSpaceResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmPurgeFromSpaceResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmPurgeFromSpaceResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmPurgeFromSpaceResponse(soap, "srmPurgeFromSpaceResponse", &a->srmPurgeFromSpaceResponse, "srm2:srmPurgeFromSpaceResponse"))
				{	soap_flag_srmPurgeFromSpaceResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmPurgeFromSpaceResponse_ *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmPurgeFromSpaceResponse_, 0, sizeof(struct srm2__srmPurgeFromSpaceResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmExtendFileLifeTimeInSpace(struct soap *soap, const struct srm2__srmExtendFileLifeTimeInSpace *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmExtendFileLifeTimeInSpaceRequest(soap, &a->srmExtendFileLifeTimeInSpaceRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmExtendFileLifeTimeInSpace(struct soap *soap, struct srm2__srmExtendFileLifeTimeInSpace *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmExtendFileLifeTimeInSpaceRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmExtendFileLifeTimeInSpace(struct soap *soap, const struct srm2__srmExtendFileLifeTimeInSpace *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpace);
	if (soap_out_srm2__srmExtendFileLifeTimeInSpace(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmExtendFileLifeTimeInSpace(struct soap *soap, const char *tag, int id, const struct srm2__srmExtendFileLifeTimeInSpace *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpace), type);
	soap_out_PointerTosrm2__srmExtendFileLifeTimeInSpaceRequest(soap, "srmExtendFileLifeTimeInSpaceRequest", -1, &a->srmExtendFileLifeTimeInSpaceRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmExtendFileLifeTimeInSpace * SOAP_FMAC4 soap_get_srm2__srmExtendFileLifeTimeInSpace(struct soap *soap, struct srm2__srmExtendFileLifeTimeInSpace *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmExtendFileLifeTimeInSpace(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmExtendFileLifeTimeInSpace * SOAP_FMAC4 soap_in_srm2__srmExtendFileLifeTimeInSpace(struct soap *soap, const char *tag, struct srm2__srmExtendFileLifeTimeInSpace *a, const char *type)
{
	short soap_flag_srmExtendFileLifeTimeInSpaceRequest = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmExtendFileLifeTimeInSpace *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpace, sizeof(struct srm2__srmExtendFileLifeTimeInSpace), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmExtendFileLifeTimeInSpace(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmExtendFileLifeTimeInSpaceRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmExtendFileLifeTimeInSpaceRequest(soap, "srmExtendFileLifeTimeInSpaceRequest", &a->srmExtendFileLifeTimeInSpaceRequest, "srm2:srmExtendFileLifeTimeInSpaceRequest"))
				{	soap_flag_srmExtendFileLifeTimeInSpaceRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmExtendFileLifeTimeInSpace *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpace, 0, sizeof(struct srm2__srmExtendFileLifeTimeInSpace), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmExtendFileLifeTimeInSpaceResponse_(struct soap *soap, const struct srm2__srmExtendFileLifeTimeInSpaceResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmExtendFileLifeTimeInSpaceResponse(soap, &a->srmExtendFileLifeTimeInSpaceResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmExtendFileLifeTimeInSpaceResponse_(struct soap *soap, struct srm2__srmExtendFileLifeTimeInSpaceResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmExtendFileLifeTimeInSpaceResponse = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmExtendFileLifeTimeInSpaceResponse_(struct soap *soap, const struct srm2__srmExtendFileLifeTimeInSpaceResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpaceResponse_);
	if (soap_out_srm2__srmExtendFileLifeTimeInSpaceResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmExtendFileLifeTimeInSpaceResponse_(struct soap *soap, const char *tag, int id, const struct srm2__srmExtendFileLifeTimeInSpaceResponse_ *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpaceResponse_), type);
	if (a->srmExtendFileLifeTimeInSpaceResponse)
		soap_element_result(soap, "srmExtendFileLifeTimeInSpaceResponse");
	soap_out_PointerTosrm2__srmExtendFileLifeTimeInSpaceResponse(soap, "srmExtendFileLifeTimeInSpaceResponse", -1, &a->srmExtendFileLifeTimeInSpaceResponse, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmExtendFileLifeTimeInSpaceResponse_ * SOAP_FMAC4 soap_get_srm2__srmExtendFileLifeTimeInSpaceResponse_(struct soap *soap, struct srm2__srmExtendFileLifeTimeInSpaceResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmExtendFileLifeTimeInSpaceResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmExtendFileLifeTimeInSpaceResponse_ * SOAP_FMAC4 soap_in_srm2__srmExtendFileLifeTimeInSpaceResponse_(struct soap *soap, const char *tag, struct srm2__srmExtendFileLifeTimeInSpaceResponse_ *a, const char *type)
{
	short soap_flag_srmExtendFileLifeTimeInSpaceResponse = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmExtendFileLifeTimeInSpaceResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpaceResponse_, sizeof(struct srm2__srmExtendFileLifeTimeInSpaceResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmExtendFileLifeTimeInSpaceResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmExtendFileLifeTimeInSpaceResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmExtendFileLifeTimeInSpaceResponse(soap, "srmExtendFileLifeTimeInSpaceResponse", &a->srmExtendFileLifeTimeInSpaceResponse, "srm2:srmExtendFileLifeTimeInSpaceResponse"))
				{	soap_flag_srmExtendFileLifeTimeInSpaceResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmExtendFileLifeTimeInSpaceResponse_ *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpaceResponse_, 0, sizeof(struct srm2__srmExtendFileLifeTimeInSpaceResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmStatusOfChangeSpaceForFilesRequest(struct soap *soap, const struct srm2__srmStatusOfChangeSpaceForFilesRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestRequest(soap, &a->srmStatusOfChangeSpaceForFilesRequestRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmStatusOfChangeSpaceForFilesRequest(struct soap *soap, struct srm2__srmStatusOfChangeSpaceForFilesRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmStatusOfChangeSpaceForFilesRequestRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmStatusOfChangeSpaceForFilesRequest(struct soap *soap, const struct srm2__srmStatusOfChangeSpaceForFilesRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequest);
	if (soap_out_srm2__srmStatusOfChangeSpaceForFilesRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmStatusOfChangeSpaceForFilesRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmStatusOfChangeSpaceForFilesRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequest), type);
	soap_out_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestRequest(soap, "srmStatusOfChangeSpaceForFilesRequestRequest", -1, &a->srmStatusOfChangeSpaceForFilesRequestRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmStatusOfChangeSpaceForFilesRequest * SOAP_FMAC4 soap_get_srm2__srmStatusOfChangeSpaceForFilesRequest(struct soap *soap, struct srm2__srmStatusOfChangeSpaceForFilesRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmStatusOfChangeSpaceForFilesRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfChangeSpaceForFilesRequest * SOAP_FMAC4 soap_in_srm2__srmStatusOfChangeSpaceForFilesRequest(struct soap *soap, const char *tag, struct srm2__srmStatusOfChangeSpaceForFilesRequest *a, const char *type)
{
	short soap_flag_srmStatusOfChangeSpaceForFilesRequestRequest = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmStatusOfChangeSpaceForFilesRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequest, sizeof(struct srm2__srmStatusOfChangeSpaceForFilesRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmStatusOfChangeSpaceForFilesRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmStatusOfChangeSpaceForFilesRequestRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestRequest(soap, "srmStatusOfChangeSpaceForFilesRequestRequest", &a->srmStatusOfChangeSpaceForFilesRequestRequest, "srm2:srmStatusOfChangeSpaceForFilesRequestRequest"))
				{	soap_flag_srmStatusOfChangeSpaceForFilesRequestRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfChangeSpaceForFilesRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequest, 0, sizeof(struct srm2__srmStatusOfChangeSpaceForFilesRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmStatusOfChangeSpaceForFilesRequestResponse_(struct soap *soap, const struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestResponse(soap, &a->srmStatusOfChangeSpaceForFilesRequestResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmStatusOfChangeSpaceForFilesRequestResponse_(struct soap *soap, struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmStatusOfChangeSpaceForFilesRequestResponse = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmStatusOfChangeSpaceForFilesRequestResponse_(struct soap *soap, const struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequestResponse_);
	if (soap_out_srm2__srmStatusOfChangeSpaceForFilesRequestResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmStatusOfChangeSpaceForFilesRequestResponse_(struct soap *soap, const char *tag, int id, const struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse_ *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequestResponse_), type);
	if (a->srmStatusOfChangeSpaceForFilesRequestResponse)
		soap_element_result(soap, "srmStatusOfChangeSpaceForFilesRequestResponse");
	soap_out_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestResponse(soap, "srmStatusOfChangeSpaceForFilesRequestResponse", -1, &a->srmStatusOfChangeSpaceForFilesRequestResponse, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse_ * SOAP_FMAC4 soap_get_srm2__srmStatusOfChangeSpaceForFilesRequestResponse_(struct soap *soap, struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmStatusOfChangeSpaceForFilesRequestResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse_ * SOAP_FMAC4 soap_in_srm2__srmStatusOfChangeSpaceForFilesRequestResponse_(struct soap *soap, const char *tag, struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse_ *a, const char *type)
{
	short soap_flag_srmStatusOfChangeSpaceForFilesRequestResponse = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequestResponse_, sizeof(struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmStatusOfChangeSpaceForFilesRequestResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmStatusOfChangeSpaceForFilesRequestResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestResponse(soap, "srmStatusOfChangeSpaceForFilesRequestResponse", &a->srmStatusOfChangeSpaceForFilesRequestResponse, "srm2:srmStatusOfChangeSpaceForFilesRequestResponse"))
				{	soap_flag_srmStatusOfChangeSpaceForFilesRequestResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse_ *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequestResponse_, 0, sizeof(struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmChangeSpaceForFiles(struct soap *soap, const struct srm2__srmChangeSpaceForFiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmChangeSpaceForFilesRequest(soap, &a->srmChangeSpaceForFilesRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmChangeSpaceForFiles(struct soap *soap, struct srm2__srmChangeSpaceForFiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmChangeSpaceForFilesRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmChangeSpaceForFiles(struct soap *soap, const struct srm2__srmChangeSpaceForFiles *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmChangeSpaceForFiles);
	if (soap_out_srm2__srmChangeSpaceForFiles(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmChangeSpaceForFiles(struct soap *soap, const char *tag, int id, const struct srm2__srmChangeSpaceForFiles *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmChangeSpaceForFiles), type);
	soap_out_PointerTosrm2__srmChangeSpaceForFilesRequest(soap, "srmChangeSpaceForFilesRequest", -1, &a->srmChangeSpaceForFilesRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmChangeSpaceForFiles * SOAP_FMAC4 soap_get_srm2__srmChangeSpaceForFiles(struct soap *soap, struct srm2__srmChangeSpaceForFiles *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmChangeSpaceForFiles(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmChangeSpaceForFiles * SOAP_FMAC4 soap_in_srm2__srmChangeSpaceForFiles(struct soap *soap, const char *tag, struct srm2__srmChangeSpaceForFiles *a, const char *type)
{
	short soap_flag_srmChangeSpaceForFilesRequest = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmChangeSpaceForFiles *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmChangeSpaceForFiles, sizeof(struct srm2__srmChangeSpaceForFiles), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmChangeSpaceForFiles(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmChangeSpaceForFilesRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmChangeSpaceForFilesRequest(soap, "srmChangeSpaceForFilesRequest", &a->srmChangeSpaceForFilesRequest, "srm2:srmChangeSpaceForFilesRequest"))
				{	soap_flag_srmChangeSpaceForFilesRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmChangeSpaceForFiles *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmChangeSpaceForFiles, 0, sizeof(struct srm2__srmChangeSpaceForFiles), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmChangeSpaceForFilesResponse_(struct soap *soap, const struct srm2__srmChangeSpaceForFilesResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmChangeSpaceForFilesResponse(soap, &a->srmChangeSpaceForFilesResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmChangeSpaceForFilesResponse_(struct soap *soap, struct srm2__srmChangeSpaceForFilesResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmChangeSpaceForFilesResponse = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmChangeSpaceForFilesResponse_(struct soap *soap, const struct srm2__srmChangeSpaceForFilesResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmChangeSpaceForFilesResponse_);
	if (soap_out_srm2__srmChangeSpaceForFilesResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmChangeSpaceForFilesResponse_(struct soap *soap, const char *tag, int id, const struct srm2__srmChangeSpaceForFilesResponse_ *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmChangeSpaceForFilesResponse_), type);
	if (a->srmChangeSpaceForFilesResponse)
		soap_element_result(soap, "srmChangeSpaceForFilesResponse");
	soap_out_PointerTosrm2__srmChangeSpaceForFilesResponse(soap, "srmChangeSpaceForFilesResponse", -1, &a->srmChangeSpaceForFilesResponse, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmChangeSpaceForFilesResponse_ * SOAP_FMAC4 soap_get_srm2__srmChangeSpaceForFilesResponse_(struct soap *soap, struct srm2__srmChangeSpaceForFilesResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmChangeSpaceForFilesResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmChangeSpaceForFilesResponse_ * SOAP_FMAC4 soap_in_srm2__srmChangeSpaceForFilesResponse_(struct soap *soap, const char *tag, struct srm2__srmChangeSpaceForFilesResponse_ *a, const char *type)
{
	short soap_flag_srmChangeSpaceForFilesResponse = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmChangeSpaceForFilesResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmChangeSpaceForFilesResponse_, sizeof(struct srm2__srmChangeSpaceForFilesResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmChangeSpaceForFilesResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmChangeSpaceForFilesResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmChangeSpaceForFilesResponse(soap, "srmChangeSpaceForFilesResponse", &a->srmChangeSpaceForFilesResponse, "srm2:srmChangeSpaceForFilesResponse"))
				{	soap_flag_srmChangeSpaceForFilesResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmChangeSpaceForFilesResponse_ *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmChangeSpaceForFilesResponse_, 0, sizeof(struct srm2__srmChangeSpaceForFilesResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmGetSpaceMetaData(struct soap *soap, const struct srm2__srmGetSpaceMetaData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmGetSpaceMetaDataRequest(soap, &a->srmGetSpaceMetaDataRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmGetSpaceMetaData(struct soap *soap, struct srm2__srmGetSpaceMetaData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmGetSpaceMetaDataRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmGetSpaceMetaData(struct soap *soap, const struct srm2__srmGetSpaceMetaData *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmGetSpaceMetaData);
	if (soap_out_srm2__srmGetSpaceMetaData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmGetSpaceMetaData(struct soap *soap, const char *tag, int id, const struct srm2__srmGetSpaceMetaData *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmGetSpaceMetaData), type);
	soap_out_PointerTosrm2__srmGetSpaceMetaDataRequest(soap, "srmGetSpaceMetaDataRequest", -1, &a->srmGetSpaceMetaDataRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmGetSpaceMetaData * SOAP_FMAC4 soap_get_srm2__srmGetSpaceMetaData(struct soap *soap, struct srm2__srmGetSpaceMetaData *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmGetSpaceMetaData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetSpaceMetaData * SOAP_FMAC4 soap_in_srm2__srmGetSpaceMetaData(struct soap *soap, const char *tag, struct srm2__srmGetSpaceMetaData *a, const char *type)
{
	short soap_flag_srmGetSpaceMetaDataRequest = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmGetSpaceMetaData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmGetSpaceMetaData, sizeof(struct srm2__srmGetSpaceMetaData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmGetSpaceMetaData(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmGetSpaceMetaDataRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmGetSpaceMetaDataRequest(soap, "srmGetSpaceMetaDataRequest", &a->srmGetSpaceMetaDataRequest, "srm2:srmGetSpaceMetaDataRequest"))
				{	soap_flag_srmGetSpaceMetaDataRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetSpaceMetaData *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetSpaceMetaData, 0, sizeof(struct srm2__srmGetSpaceMetaData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmGetSpaceMetaDataResponse_(struct soap *soap, const struct srm2__srmGetSpaceMetaDataResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmGetSpaceMetaDataResponse(soap, &a->srmGetSpaceMetaDataResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmGetSpaceMetaDataResponse_(struct soap *soap, struct srm2__srmGetSpaceMetaDataResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmGetSpaceMetaDataResponse = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmGetSpaceMetaDataResponse_(struct soap *soap, const struct srm2__srmGetSpaceMetaDataResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmGetSpaceMetaDataResponse_);
	if (soap_out_srm2__srmGetSpaceMetaDataResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmGetSpaceMetaDataResponse_(struct soap *soap, const char *tag, int id, const struct srm2__srmGetSpaceMetaDataResponse_ *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmGetSpaceMetaDataResponse_), type);
	if (a->srmGetSpaceMetaDataResponse)
		soap_element_result(soap, "srmGetSpaceMetaDataResponse");
	soap_out_PointerTosrm2__srmGetSpaceMetaDataResponse(soap, "srmGetSpaceMetaDataResponse", -1, &a->srmGetSpaceMetaDataResponse, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmGetSpaceMetaDataResponse_ * SOAP_FMAC4 soap_get_srm2__srmGetSpaceMetaDataResponse_(struct soap *soap, struct srm2__srmGetSpaceMetaDataResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmGetSpaceMetaDataResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetSpaceMetaDataResponse_ * SOAP_FMAC4 soap_in_srm2__srmGetSpaceMetaDataResponse_(struct soap *soap, const char *tag, struct srm2__srmGetSpaceMetaDataResponse_ *a, const char *type)
{
	short soap_flag_srmGetSpaceMetaDataResponse = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmGetSpaceMetaDataResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmGetSpaceMetaDataResponse_, sizeof(struct srm2__srmGetSpaceMetaDataResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmGetSpaceMetaDataResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmGetSpaceMetaDataResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmGetSpaceMetaDataResponse(soap, "srmGetSpaceMetaDataResponse", &a->srmGetSpaceMetaDataResponse, "srm2:srmGetSpaceMetaDataResponse"))
				{	soap_flag_srmGetSpaceMetaDataResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetSpaceMetaDataResponse_ *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetSpaceMetaDataResponse_, 0, sizeof(struct srm2__srmGetSpaceMetaDataResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmStatusOfUpdateSpaceRequest(struct soap *soap, const struct srm2__srmStatusOfUpdateSpaceRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmStatusOfUpdateSpaceRequestRequest(soap, &a->srmStatusOfUpdateSpaceRequestRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmStatusOfUpdateSpaceRequest(struct soap *soap, struct srm2__srmStatusOfUpdateSpaceRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmStatusOfUpdateSpaceRequestRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmStatusOfUpdateSpaceRequest(struct soap *soap, const struct srm2__srmStatusOfUpdateSpaceRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequest);
	if (soap_out_srm2__srmStatusOfUpdateSpaceRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmStatusOfUpdateSpaceRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmStatusOfUpdateSpaceRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequest), type);
	soap_out_PointerTosrm2__srmStatusOfUpdateSpaceRequestRequest(soap, "srmStatusOfUpdateSpaceRequestRequest", -1, &a->srmStatusOfUpdateSpaceRequestRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmStatusOfUpdateSpaceRequest * SOAP_FMAC4 soap_get_srm2__srmStatusOfUpdateSpaceRequest(struct soap *soap, struct srm2__srmStatusOfUpdateSpaceRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmStatusOfUpdateSpaceRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfUpdateSpaceRequest * SOAP_FMAC4 soap_in_srm2__srmStatusOfUpdateSpaceRequest(struct soap *soap, const char *tag, struct srm2__srmStatusOfUpdateSpaceRequest *a, const char *type)
{
	short soap_flag_srmStatusOfUpdateSpaceRequestRequest = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmStatusOfUpdateSpaceRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequest, sizeof(struct srm2__srmStatusOfUpdateSpaceRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmStatusOfUpdateSpaceRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmStatusOfUpdateSpaceRequestRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmStatusOfUpdateSpaceRequestRequest(soap, "srmStatusOfUpdateSpaceRequestRequest", &a->srmStatusOfUpdateSpaceRequestRequest, "srm2:srmStatusOfUpdateSpaceRequestRequest"))
				{	soap_flag_srmStatusOfUpdateSpaceRequestRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfUpdateSpaceRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequest, 0, sizeof(struct srm2__srmStatusOfUpdateSpaceRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmStatusOfUpdateSpaceRequestResponse_(struct soap *soap, const struct srm2__srmStatusOfUpdateSpaceRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmStatusOfUpdateSpaceRequestResponse(soap, &a->srmStatusOfUpdateSpaceRequestResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmStatusOfUpdateSpaceRequestResponse_(struct soap *soap, struct srm2__srmStatusOfUpdateSpaceRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmStatusOfUpdateSpaceRequestResponse = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmStatusOfUpdateSpaceRequestResponse_(struct soap *soap, const struct srm2__srmStatusOfUpdateSpaceRequestResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequestResponse_);
	if (soap_out_srm2__srmStatusOfUpdateSpaceRequestResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmStatusOfUpdateSpaceRequestResponse_(struct soap *soap, const char *tag, int id, const struct srm2__srmStatusOfUpdateSpaceRequestResponse_ *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequestResponse_), type);
	if (a->srmStatusOfUpdateSpaceRequestResponse)
		soap_element_result(soap, "srmStatusOfUpdateSpaceRequestResponse");
	soap_out_PointerTosrm2__srmStatusOfUpdateSpaceRequestResponse(soap, "srmStatusOfUpdateSpaceRequestResponse", -1, &a->srmStatusOfUpdateSpaceRequestResponse, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmStatusOfUpdateSpaceRequestResponse_ * SOAP_FMAC4 soap_get_srm2__srmStatusOfUpdateSpaceRequestResponse_(struct soap *soap, struct srm2__srmStatusOfUpdateSpaceRequestResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmStatusOfUpdateSpaceRequestResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfUpdateSpaceRequestResponse_ * SOAP_FMAC4 soap_in_srm2__srmStatusOfUpdateSpaceRequestResponse_(struct soap *soap, const char *tag, struct srm2__srmStatusOfUpdateSpaceRequestResponse_ *a, const char *type)
{
	short soap_flag_srmStatusOfUpdateSpaceRequestResponse = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmStatusOfUpdateSpaceRequestResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequestResponse_, sizeof(struct srm2__srmStatusOfUpdateSpaceRequestResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmStatusOfUpdateSpaceRequestResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmStatusOfUpdateSpaceRequestResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmStatusOfUpdateSpaceRequestResponse(soap, "srmStatusOfUpdateSpaceRequestResponse", &a->srmStatusOfUpdateSpaceRequestResponse, "srm2:srmStatusOfUpdateSpaceRequestResponse"))
				{	soap_flag_srmStatusOfUpdateSpaceRequestResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfUpdateSpaceRequestResponse_ *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequestResponse_, 0, sizeof(struct srm2__srmStatusOfUpdateSpaceRequestResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmUpdateSpace(struct soap *soap, const struct srm2__srmUpdateSpace *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmUpdateSpaceRequest(soap, &a->srmUpdateSpaceRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmUpdateSpace(struct soap *soap, struct srm2__srmUpdateSpace *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmUpdateSpaceRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmUpdateSpace(struct soap *soap, const struct srm2__srmUpdateSpace *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmUpdateSpace);
	if (soap_out_srm2__srmUpdateSpace(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmUpdateSpace(struct soap *soap, const char *tag, int id, const struct srm2__srmUpdateSpace *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmUpdateSpace), type);
	soap_out_PointerTosrm2__srmUpdateSpaceRequest(soap, "srmUpdateSpaceRequest", -1, &a->srmUpdateSpaceRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmUpdateSpace * SOAP_FMAC4 soap_get_srm2__srmUpdateSpace(struct soap *soap, struct srm2__srmUpdateSpace *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmUpdateSpace(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmUpdateSpace * SOAP_FMAC4 soap_in_srm2__srmUpdateSpace(struct soap *soap, const char *tag, struct srm2__srmUpdateSpace *a, const char *type)
{
	short soap_flag_srmUpdateSpaceRequest = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmUpdateSpace *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmUpdateSpace, sizeof(struct srm2__srmUpdateSpace), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmUpdateSpace(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmUpdateSpaceRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmUpdateSpaceRequest(soap, "srmUpdateSpaceRequest", &a->srmUpdateSpaceRequest, "srm2:srmUpdateSpaceRequest"))
				{	soap_flag_srmUpdateSpaceRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmUpdateSpace *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmUpdateSpace, 0, sizeof(struct srm2__srmUpdateSpace), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmUpdateSpaceResponse_(struct soap *soap, const struct srm2__srmUpdateSpaceResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmUpdateSpaceResponse(soap, &a->srmUpdateSpaceResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmUpdateSpaceResponse_(struct soap *soap, struct srm2__srmUpdateSpaceResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmUpdateSpaceResponse = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmUpdateSpaceResponse_(struct soap *soap, const struct srm2__srmUpdateSpaceResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmUpdateSpaceResponse_);
	if (soap_out_srm2__srmUpdateSpaceResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmUpdateSpaceResponse_(struct soap *soap, const char *tag, int id, const struct srm2__srmUpdateSpaceResponse_ *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmUpdateSpaceResponse_), type);
	if (a->srmUpdateSpaceResponse)
		soap_element_result(soap, "srmUpdateSpaceResponse");
	soap_out_PointerTosrm2__srmUpdateSpaceResponse(soap, "srmUpdateSpaceResponse", -1, &a->srmUpdateSpaceResponse, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmUpdateSpaceResponse_ * SOAP_FMAC4 soap_get_srm2__srmUpdateSpaceResponse_(struct soap *soap, struct srm2__srmUpdateSpaceResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmUpdateSpaceResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmUpdateSpaceResponse_ * SOAP_FMAC4 soap_in_srm2__srmUpdateSpaceResponse_(struct soap *soap, const char *tag, struct srm2__srmUpdateSpaceResponse_ *a, const char *type)
{
	short soap_flag_srmUpdateSpaceResponse = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmUpdateSpaceResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmUpdateSpaceResponse_, sizeof(struct srm2__srmUpdateSpaceResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmUpdateSpaceResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmUpdateSpaceResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmUpdateSpaceResponse(soap, "srmUpdateSpaceResponse", &a->srmUpdateSpaceResponse, "srm2:srmUpdateSpaceResponse"))
				{	soap_flag_srmUpdateSpaceResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmUpdateSpaceResponse_ *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmUpdateSpaceResponse_, 0, sizeof(struct srm2__srmUpdateSpaceResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmReleaseSpace(struct soap *soap, const struct srm2__srmReleaseSpace *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmReleaseSpaceRequest(soap, &a->srmReleaseSpaceRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmReleaseSpace(struct soap *soap, struct srm2__srmReleaseSpace *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmReleaseSpaceRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmReleaseSpace(struct soap *soap, const struct srm2__srmReleaseSpace *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmReleaseSpace);
	if (soap_out_srm2__srmReleaseSpace(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmReleaseSpace(struct soap *soap, const char *tag, int id, const struct srm2__srmReleaseSpace *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmReleaseSpace), type);
	soap_out_PointerTosrm2__srmReleaseSpaceRequest(soap, "srmReleaseSpaceRequest", -1, &a->srmReleaseSpaceRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmReleaseSpace * SOAP_FMAC4 soap_get_srm2__srmReleaseSpace(struct soap *soap, struct srm2__srmReleaseSpace *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmReleaseSpace(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmReleaseSpace * SOAP_FMAC4 soap_in_srm2__srmReleaseSpace(struct soap *soap, const char *tag, struct srm2__srmReleaseSpace *a, const char *type)
{
	short soap_flag_srmReleaseSpaceRequest = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmReleaseSpace *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmReleaseSpace, sizeof(struct srm2__srmReleaseSpace), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmReleaseSpace(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmReleaseSpaceRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmReleaseSpaceRequest(soap, "srmReleaseSpaceRequest", &a->srmReleaseSpaceRequest, "srm2:srmReleaseSpaceRequest"))
				{	soap_flag_srmReleaseSpaceRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmReleaseSpace *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmReleaseSpace, 0, sizeof(struct srm2__srmReleaseSpace), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmReleaseSpaceResponse_(struct soap *soap, const struct srm2__srmReleaseSpaceResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmReleaseSpaceResponse(soap, &a->srmReleaseSpaceResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmReleaseSpaceResponse_(struct soap *soap, struct srm2__srmReleaseSpaceResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmReleaseSpaceResponse = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmReleaseSpaceResponse_(struct soap *soap, const struct srm2__srmReleaseSpaceResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmReleaseSpaceResponse_);
	if (soap_out_srm2__srmReleaseSpaceResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmReleaseSpaceResponse_(struct soap *soap, const char *tag, int id, const struct srm2__srmReleaseSpaceResponse_ *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmReleaseSpaceResponse_), type);
	if (a->srmReleaseSpaceResponse)
		soap_element_result(soap, "srmReleaseSpaceResponse");
	soap_out_PointerTosrm2__srmReleaseSpaceResponse(soap, "srmReleaseSpaceResponse", -1, &a->srmReleaseSpaceResponse, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmReleaseSpaceResponse_ * SOAP_FMAC4 soap_get_srm2__srmReleaseSpaceResponse_(struct soap *soap, struct srm2__srmReleaseSpaceResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmReleaseSpaceResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmReleaseSpaceResponse_ * SOAP_FMAC4 soap_in_srm2__srmReleaseSpaceResponse_(struct soap *soap, const char *tag, struct srm2__srmReleaseSpaceResponse_ *a, const char *type)
{
	short soap_flag_srmReleaseSpaceResponse = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmReleaseSpaceResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmReleaseSpaceResponse_, sizeof(struct srm2__srmReleaseSpaceResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmReleaseSpaceResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmReleaseSpaceResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmReleaseSpaceResponse(soap, "srmReleaseSpaceResponse", &a->srmReleaseSpaceResponse, "srm2:srmReleaseSpaceResponse"))
				{	soap_flag_srmReleaseSpaceResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmReleaseSpaceResponse_ *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmReleaseSpaceResponse_, 0, sizeof(struct srm2__srmReleaseSpaceResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmStatusOfReserveSpaceRequest(struct soap *soap, const struct srm2__srmStatusOfReserveSpaceRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmStatusOfReserveSpaceRequestRequest(soap, &a->srmStatusOfReserveSpaceRequestRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmStatusOfReserveSpaceRequest(struct soap *soap, struct srm2__srmStatusOfReserveSpaceRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmStatusOfReserveSpaceRequestRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmStatusOfReserveSpaceRequest(struct soap *soap, const struct srm2__srmStatusOfReserveSpaceRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequest);
	if (soap_out_srm2__srmStatusOfReserveSpaceRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmStatusOfReserveSpaceRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmStatusOfReserveSpaceRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequest), type);
	soap_out_PointerTosrm2__srmStatusOfReserveSpaceRequestRequest(soap, "srmStatusOfReserveSpaceRequestRequest", -1, &a->srmStatusOfReserveSpaceRequestRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmStatusOfReserveSpaceRequest * SOAP_FMAC4 soap_get_srm2__srmStatusOfReserveSpaceRequest(struct soap *soap, struct srm2__srmStatusOfReserveSpaceRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmStatusOfReserveSpaceRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfReserveSpaceRequest * SOAP_FMAC4 soap_in_srm2__srmStatusOfReserveSpaceRequest(struct soap *soap, const char *tag, struct srm2__srmStatusOfReserveSpaceRequest *a, const char *type)
{
	short soap_flag_srmStatusOfReserveSpaceRequestRequest = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmStatusOfReserveSpaceRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequest, sizeof(struct srm2__srmStatusOfReserveSpaceRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmStatusOfReserveSpaceRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmStatusOfReserveSpaceRequestRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmStatusOfReserveSpaceRequestRequest(soap, "srmStatusOfReserveSpaceRequestRequest", &a->srmStatusOfReserveSpaceRequestRequest, "srm2:srmStatusOfReserveSpaceRequestRequest"))
				{	soap_flag_srmStatusOfReserveSpaceRequestRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfReserveSpaceRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequest, 0, sizeof(struct srm2__srmStatusOfReserveSpaceRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmStatusOfReserveSpaceRequestResponse_(struct soap *soap, const struct srm2__srmStatusOfReserveSpaceRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmStatusOfReserveSpaceRequestResponse(soap, &a->srmStatusOfReserveSpaceRequestResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmStatusOfReserveSpaceRequestResponse_(struct soap *soap, struct srm2__srmStatusOfReserveSpaceRequestResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmStatusOfReserveSpaceRequestResponse = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmStatusOfReserveSpaceRequestResponse_(struct soap *soap, const struct srm2__srmStatusOfReserveSpaceRequestResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequestResponse_);
	if (soap_out_srm2__srmStatusOfReserveSpaceRequestResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmStatusOfReserveSpaceRequestResponse_(struct soap *soap, const char *tag, int id, const struct srm2__srmStatusOfReserveSpaceRequestResponse_ *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequestResponse_), type);
	if (a->srmStatusOfReserveSpaceRequestResponse)
		soap_element_result(soap, "srmStatusOfReserveSpaceRequestResponse");
	soap_out_PointerTosrm2__srmStatusOfReserveSpaceRequestResponse(soap, "srmStatusOfReserveSpaceRequestResponse", -1, &a->srmStatusOfReserveSpaceRequestResponse, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmStatusOfReserveSpaceRequestResponse_ * SOAP_FMAC4 soap_get_srm2__srmStatusOfReserveSpaceRequestResponse_(struct soap *soap, struct srm2__srmStatusOfReserveSpaceRequestResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmStatusOfReserveSpaceRequestResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfReserveSpaceRequestResponse_ * SOAP_FMAC4 soap_in_srm2__srmStatusOfReserveSpaceRequestResponse_(struct soap *soap, const char *tag, struct srm2__srmStatusOfReserveSpaceRequestResponse_ *a, const char *type)
{
	short soap_flag_srmStatusOfReserveSpaceRequestResponse = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmStatusOfReserveSpaceRequestResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequestResponse_, sizeof(struct srm2__srmStatusOfReserveSpaceRequestResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmStatusOfReserveSpaceRequestResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmStatusOfReserveSpaceRequestResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmStatusOfReserveSpaceRequestResponse(soap, "srmStatusOfReserveSpaceRequestResponse", &a->srmStatusOfReserveSpaceRequestResponse, "srm2:srmStatusOfReserveSpaceRequestResponse"))
				{	soap_flag_srmStatusOfReserveSpaceRequestResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfReserveSpaceRequestResponse_ *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequestResponse_, 0, sizeof(struct srm2__srmStatusOfReserveSpaceRequestResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmReserveSpace(struct soap *soap, const struct srm2__srmReserveSpace *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmReserveSpaceRequest(soap, &a->srmReserveSpaceRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmReserveSpace(struct soap *soap, struct srm2__srmReserveSpace *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmReserveSpaceRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmReserveSpace(struct soap *soap, const struct srm2__srmReserveSpace *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmReserveSpace);
	if (soap_out_srm2__srmReserveSpace(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmReserveSpace(struct soap *soap, const char *tag, int id, const struct srm2__srmReserveSpace *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmReserveSpace), type);
	soap_out_PointerTosrm2__srmReserveSpaceRequest(soap, "srmReserveSpaceRequest", -1, &a->srmReserveSpaceRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmReserveSpace * SOAP_FMAC4 soap_get_srm2__srmReserveSpace(struct soap *soap, struct srm2__srmReserveSpace *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmReserveSpace(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmReserveSpace * SOAP_FMAC4 soap_in_srm2__srmReserveSpace(struct soap *soap, const char *tag, struct srm2__srmReserveSpace *a, const char *type)
{
	short soap_flag_srmReserveSpaceRequest = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmReserveSpace *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmReserveSpace, sizeof(struct srm2__srmReserveSpace), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmReserveSpace(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmReserveSpaceRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmReserveSpaceRequest(soap, "srmReserveSpaceRequest", &a->srmReserveSpaceRequest, "srm2:srmReserveSpaceRequest"))
				{	soap_flag_srmReserveSpaceRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmReserveSpace *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmReserveSpace, 0, sizeof(struct srm2__srmReserveSpace), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmReserveSpaceResponse_(struct soap *soap, const struct srm2__srmReserveSpaceResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__srmReserveSpaceResponse(soap, &a->srmReserveSpaceResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmReserveSpaceResponse_(struct soap *soap, struct srm2__srmReserveSpaceResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srmReserveSpaceResponse = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmReserveSpaceResponse_(struct soap *soap, const struct srm2__srmReserveSpaceResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmReserveSpaceResponse_);
	if (soap_out_srm2__srmReserveSpaceResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmReserveSpaceResponse_(struct soap *soap, const char *tag, int id, const struct srm2__srmReserveSpaceResponse_ *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmReserveSpaceResponse_), type);
	if (a->srmReserveSpaceResponse)
		soap_element_result(soap, "srmReserveSpaceResponse");
	soap_out_PointerTosrm2__srmReserveSpaceResponse(soap, "srmReserveSpaceResponse", -1, &a->srmReserveSpaceResponse, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmReserveSpaceResponse_ * SOAP_FMAC4 soap_get_srm2__srmReserveSpaceResponse_(struct soap *soap, struct srm2__srmReserveSpaceResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmReserveSpaceResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmReserveSpaceResponse_ * SOAP_FMAC4 soap_in_srm2__srmReserveSpaceResponse_(struct soap *soap, const char *tag, struct srm2__srmReserveSpaceResponse_ *a, const char *type)
{
	short soap_flag_srmReserveSpaceResponse = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmReserveSpaceResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmReserveSpaceResponse_, sizeof(struct srm2__srmReserveSpaceResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmReserveSpaceResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srmReserveSpaceResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__srmReserveSpaceResponse(soap, "srmReserveSpaceResponse", &a->srmReserveSpaceResponse, "srm2:srmReserveSpaceResponse"))
				{	soap_flag_srmReserveSpaceResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmReserveSpaceResponse_ *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmReserveSpaceResponse_, 0, sizeof(struct srm2__srmReserveSpaceResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmPingResponse(struct soap *soap, const struct srm2__srmPingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->versionInfo);
	soap_serialize_PointerTosrm2__ArrayOfTExtraInfo(soap, &a->otherInfo);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmPingResponse(struct soap *soap, struct srm2__srmPingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->versionInfo);
	a->otherInfo = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmPingResponse(struct soap *soap, const struct srm2__srmPingResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmPingResponse);
	if (soap_out_srm2__srmPingResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmPingResponse(struct soap *soap, const char *tag, int id, const struct srm2__srmPingResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmPingResponse), type);
	soap_out_string(soap, "versionInfo", -1, &a->versionInfo, "");
	soap_out_PointerTosrm2__ArrayOfTExtraInfo(soap, "otherInfo", -1, &a->otherInfo, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmPingResponse * SOAP_FMAC4 soap_get_srm2__srmPingResponse(struct soap *soap, struct srm2__srmPingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmPingResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmPingResponse * SOAP_FMAC4 soap_in_srm2__srmPingResponse(struct soap *soap, const char *tag, struct srm2__srmPingResponse *a, const char *type)
{
	short soap_flag_versionInfo = 1, soap_flag_otherInfo = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmPingResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmPingResponse, sizeof(struct srm2__srmPingResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmPingResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_versionInfo && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "versionInfo", &a->versionInfo, "xsd:string"))
				{	soap_flag_versionInfo--;
					continue;
				}
			if (soap_flag_otherInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTExtraInfo(soap, "otherInfo", &a->otherInfo, "srm2:ArrayOfTExtraInfo"))
				{	soap_flag_otherInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_versionInfo > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmPingResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmPingResponse, 0, sizeof(struct srm2__srmPingResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmPingRequest(struct soap *soap, const struct srm2__srmPingRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmPingRequest(struct soap *soap, struct srm2__srmPingRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmPingRequest(struct soap *soap, const struct srm2__srmPingRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmPingRequest);
	if (soap_out_srm2__srmPingRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmPingRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmPingRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmPingRequest), type);
	soap_out_string(soap, "authorizationID", -1, &a->authorizationID, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmPingRequest * SOAP_FMAC4 soap_get_srm2__srmPingRequest(struct soap *soap, struct srm2__srmPingRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmPingRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmPingRequest * SOAP_FMAC4 soap_in_srm2__srmPingRequest(struct soap *soap, const char *tag, struct srm2__srmPingRequest *a, const char *type)
{
	short soap_flag_authorizationID = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmPingRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmPingRequest, sizeof(struct srm2__srmPingRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmPingRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmPingRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmPingRequest, 0, sizeof(struct srm2__srmPingRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmGetTransferProtocolsResponse(struct soap *soap, const struct srm2__srmGetTransferProtocolsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerTosrm2__ArrayOfTSupportedTransferProtocol(soap, &a->protocolInfo);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmGetTransferProtocolsResponse(struct soap *soap, struct srm2__srmGetTransferProtocolsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->protocolInfo = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmGetTransferProtocolsResponse(struct soap *soap, const struct srm2__srmGetTransferProtocolsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmGetTransferProtocolsResponse);
	if (soap_out_srm2__srmGetTransferProtocolsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmGetTransferProtocolsResponse(struct soap *soap, const char *tag, int id, const struct srm2__srmGetTransferProtocolsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmGetTransferProtocolsResponse), type);
	soap_out_PointerTosrm2__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, "");
	soap_out_PointerTosrm2__ArrayOfTSupportedTransferProtocol(soap, "protocolInfo", -1, &a->protocolInfo, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmGetTransferProtocolsResponse * SOAP_FMAC4 soap_get_srm2__srmGetTransferProtocolsResponse(struct soap *soap, struct srm2__srmGetTransferProtocolsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmGetTransferProtocolsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetTransferProtocolsResponse * SOAP_FMAC4 soap_in_srm2__srmGetTransferProtocolsResponse(struct soap *soap, const char *tag, struct srm2__srmGetTransferProtocolsResponse *a, const char *type)
{
	short soap_flag_returnStatus = 1, soap_flag_protocolInfo = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmGetTransferProtocolsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmGetTransferProtocolsResponse, sizeof(struct srm2__srmGetTransferProtocolsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmGetTransferProtocolsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "returnStatus", &a->returnStatus, "srm2:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_protocolInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTSupportedTransferProtocol(soap, "protocolInfo", &a->protocolInfo, "srm2:ArrayOfTSupportedTransferProtocol"))
				{	soap_flag_protocolInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetTransferProtocolsResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetTransferProtocolsResponse, 0, sizeof(struct srm2__srmGetTransferProtocolsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmGetTransferProtocolsRequest(struct soap *soap, const struct srm2__srmGetTransferProtocolsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmGetTransferProtocolsRequest(struct soap *soap, struct srm2__srmGetTransferProtocolsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmGetTransferProtocolsRequest(struct soap *soap, const struct srm2__srmGetTransferProtocolsRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmGetTransferProtocolsRequest);
	if (soap_out_srm2__srmGetTransferProtocolsRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmGetTransferProtocolsRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmGetTransferProtocolsRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmGetTransferProtocolsRequest), type);
	soap_out_string(soap, "authorizationID", -1, &a->authorizationID, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmGetTransferProtocolsRequest * SOAP_FMAC4 soap_get_srm2__srmGetTransferProtocolsRequest(struct soap *soap, struct srm2__srmGetTransferProtocolsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmGetTransferProtocolsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetTransferProtocolsRequest * SOAP_FMAC4 soap_in_srm2__srmGetTransferProtocolsRequest(struct soap *soap, const char *tag, struct srm2__srmGetTransferProtocolsRequest *a, const char *type)
{
	short soap_flag_authorizationID = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmGetTransferProtocolsRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmGetTransferProtocolsRequest, sizeof(struct srm2__srmGetTransferProtocolsRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmGetTransferProtocolsRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetTransferProtocolsRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetTransferProtocolsRequest, 0, sizeof(struct srm2__srmGetTransferProtocolsRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmGetRequestTokensResponse(struct soap *soap, const struct srm2__srmGetRequestTokensResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerTosrm2__ArrayOfTRequestTokenReturn(soap, &a->arrayOfRequestTokens);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmGetRequestTokensResponse(struct soap *soap, struct srm2__srmGetRequestTokensResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->arrayOfRequestTokens = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmGetRequestTokensResponse(struct soap *soap, const struct srm2__srmGetRequestTokensResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmGetRequestTokensResponse);
	if (soap_out_srm2__srmGetRequestTokensResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmGetRequestTokensResponse(struct soap *soap, const char *tag, int id, const struct srm2__srmGetRequestTokensResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmGetRequestTokensResponse), type);
	soap_out_PointerTosrm2__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, "");
	soap_out_PointerTosrm2__ArrayOfTRequestTokenReturn(soap, "arrayOfRequestTokens", -1, &a->arrayOfRequestTokens, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmGetRequestTokensResponse * SOAP_FMAC4 soap_get_srm2__srmGetRequestTokensResponse(struct soap *soap, struct srm2__srmGetRequestTokensResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmGetRequestTokensResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetRequestTokensResponse * SOAP_FMAC4 soap_in_srm2__srmGetRequestTokensResponse(struct soap *soap, const char *tag, struct srm2__srmGetRequestTokensResponse *a, const char *type)
{
	short soap_flag_returnStatus = 1, soap_flag_arrayOfRequestTokens = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmGetRequestTokensResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmGetRequestTokensResponse, sizeof(struct srm2__srmGetRequestTokensResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmGetRequestTokensResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "returnStatus", &a->returnStatus, "srm2:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_arrayOfRequestTokens && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTRequestTokenReturn(soap, "arrayOfRequestTokens", &a->arrayOfRequestTokens, "srm2:ArrayOfTRequestTokenReturn"))
				{	soap_flag_arrayOfRequestTokens--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetRequestTokensResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetRequestTokensResponse, 0, sizeof(struct srm2__srmGetRequestTokensResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmGetRequestTokensRequest(struct soap *soap, const struct srm2__srmGetRequestTokensRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->userRequestDescription);
	soap_serialize_string(soap, &a->authorizationID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmGetRequestTokensRequest(struct soap *soap, struct srm2__srmGetRequestTokensRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->userRequestDescription);
	soap_default_string(soap, &a->authorizationID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmGetRequestTokensRequest(struct soap *soap, const struct srm2__srmGetRequestTokensRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmGetRequestTokensRequest);
	if (soap_out_srm2__srmGetRequestTokensRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmGetRequestTokensRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmGetRequestTokensRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmGetRequestTokensRequest), type);
	soap_out_string(soap, "userRequestDescription", -1, &a->userRequestDescription, "");
	soap_out_string(soap, "authorizationID", -1, &a->authorizationID, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmGetRequestTokensRequest * SOAP_FMAC4 soap_get_srm2__srmGetRequestTokensRequest(struct soap *soap, struct srm2__srmGetRequestTokensRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmGetRequestTokensRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetRequestTokensRequest * SOAP_FMAC4 soap_in_srm2__srmGetRequestTokensRequest(struct soap *soap, const char *tag, struct srm2__srmGetRequestTokensRequest *a, const char *type)
{
	short soap_flag_userRequestDescription = 1, soap_flag_authorizationID = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmGetRequestTokensRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmGetRequestTokensRequest, sizeof(struct srm2__srmGetRequestTokensRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmGetRequestTokensRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userRequestDescription && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRequestDescription", &a->userRequestDescription, "xsd:string"))
				{	soap_flag_userRequestDescription--;
					continue;
				}
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetRequestTokensRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetRequestTokensRequest, 0, sizeof(struct srm2__srmGetRequestTokensRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmExtendFileLifeTimeResponse(struct soap *soap, const struct srm2__srmExtendFileLifeTimeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerTosrm2__ArrayOfTSURLLifetimeReturnStatus(soap, &a->arrayOfFileStatuses);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmExtendFileLifeTimeResponse(struct soap *soap, struct srm2__srmExtendFileLifeTimeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->arrayOfFileStatuses = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmExtendFileLifeTimeResponse(struct soap *soap, const struct srm2__srmExtendFileLifeTimeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmExtendFileLifeTimeResponse);
	if (soap_out_srm2__srmExtendFileLifeTimeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmExtendFileLifeTimeResponse(struct soap *soap, const char *tag, int id, const struct srm2__srmExtendFileLifeTimeResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmExtendFileLifeTimeResponse), type);
	soap_out_PointerTosrm2__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, "");
	soap_out_PointerTosrm2__ArrayOfTSURLLifetimeReturnStatus(soap, "arrayOfFileStatuses", -1, &a->arrayOfFileStatuses, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmExtendFileLifeTimeResponse * SOAP_FMAC4 soap_get_srm2__srmExtendFileLifeTimeResponse(struct soap *soap, struct srm2__srmExtendFileLifeTimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmExtendFileLifeTimeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmExtendFileLifeTimeResponse * SOAP_FMAC4 soap_in_srm2__srmExtendFileLifeTimeResponse(struct soap *soap, const char *tag, struct srm2__srmExtendFileLifeTimeResponse *a, const char *type)
{
	short soap_flag_returnStatus = 1, soap_flag_arrayOfFileStatuses = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmExtendFileLifeTimeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmExtendFileLifeTimeResponse, sizeof(struct srm2__srmExtendFileLifeTimeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmExtendFileLifeTimeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "returnStatus", &a->returnStatus, "srm2:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_arrayOfFileStatuses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTSURLLifetimeReturnStatus(soap, "arrayOfFileStatuses", &a->arrayOfFileStatuses, "srm2:ArrayOfTSURLLifetimeReturnStatus"))
				{	soap_flag_arrayOfFileStatuses--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmExtendFileLifeTimeResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmExtendFileLifeTimeResponse, 0, sizeof(struct srm2__srmExtendFileLifeTimeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmExtendFileLifeTimeRequest(struct soap *soap, const struct srm2__srmExtendFileLifeTimeRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_PointerTosrm2__ArrayOfAnyURI(soap, &a->arrayOfSURLs);
	soap_serialize_PointerToint(soap, &a->newFileLifeTime);
	soap_serialize_PointerToint(soap, &a->newPinLifeTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmExtendFileLifeTimeRequest(struct soap *soap, struct srm2__srmExtendFileLifeTimeRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	soap_default_string(soap, &a->requestToken);
	a->arrayOfSURLs = NULL;
	a->newFileLifeTime = NULL;
	a->newPinLifeTime = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmExtendFileLifeTimeRequest(struct soap *soap, const struct srm2__srmExtendFileLifeTimeRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmExtendFileLifeTimeRequest);
	if (soap_out_srm2__srmExtendFileLifeTimeRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmExtendFileLifeTimeRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmExtendFileLifeTimeRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmExtendFileLifeTimeRequest), type);
	soap_out_string(soap, "authorizationID", -1, &a->authorizationID, "");
	soap_out_string(soap, "requestToken", -1, &a->requestToken, "");
	soap_out_PointerTosrm2__ArrayOfAnyURI(soap, "arrayOfSURLs", -1, &a->arrayOfSURLs, "");
	soap_out_PointerToint(soap, "newFileLifeTime", -1, &a->newFileLifeTime, "");
	soap_out_PointerToint(soap, "newPinLifeTime", -1, &a->newPinLifeTime, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmExtendFileLifeTimeRequest * SOAP_FMAC4 soap_get_srm2__srmExtendFileLifeTimeRequest(struct soap *soap, struct srm2__srmExtendFileLifeTimeRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmExtendFileLifeTimeRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmExtendFileLifeTimeRequest * SOAP_FMAC4 soap_in_srm2__srmExtendFileLifeTimeRequest(struct soap *soap, const char *tag, struct srm2__srmExtendFileLifeTimeRequest *a, const char *type)
{
	short soap_flag_authorizationID = 1, soap_flag_requestToken = 1, soap_flag_arrayOfSURLs = 1, soap_flag_newFileLifeTime = 1, soap_flag_newPinLifeTime = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmExtendFileLifeTimeRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmExtendFileLifeTimeRequest, sizeof(struct srm2__srmExtendFileLifeTimeRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmExtendFileLifeTimeRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_arrayOfSURLs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfAnyURI(soap, "arrayOfSURLs", &a->arrayOfSURLs, "srm2:ArrayOfAnyURI"))
				{	soap_flag_arrayOfSURLs--;
					continue;
				}
			if (soap_flag_newFileLifeTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "newFileLifeTime", &a->newFileLifeTime, "xsd:int"))
				{	soap_flag_newFileLifeTime--;
					continue;
				}
			if (soap_flag_newPinLifeTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "newPinLifeTime", &a->newPinLifeTime, "xsd:int"))
				{	soap_flag_newPinLifeTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arrayOfSURLs > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmExtendFileLifeTimeRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmExtendFileLifeTimeRequest, 0, sizeof(struct srm2__srmExtendFileLifeTimeRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmGetRequestSummaryResponse(struct soap *soap, const struct srm2__srmGetRequestSummaryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerTosrm2__ArrayOfTRequestSummary(soap, &a->arrayOfRequestSummaries);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmGetRequestSummaryResponse(struct soap *soap, struct srm2__srmGetRequestSummaryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->arrayOfRequestSummaries = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmGetRequestSummaryResponse(struct soap *soap, const struct srm2__srmGetRequestSummaryResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmGetRequestSummaryResponse);
	if (soap_out_srm2__srmGetRequestSummaryResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmGetRequestSummaryResponse(struct soap *soap, const char *tag, int id, const struct srm2__srmGetRequestSummaryResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmGetRequestSummaryResponse), type);
	soap_out_PointerTosrm2__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, "");
	soap_out_PointerTosrm2__ArrayOfTRequestSummary(soap, "arrayOfRequestSummaries", -1, &a->arrayOfRequestSummaries, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmGetRequestSummaryResponse * SOAP_FMAC4 soap_get_srm2__srmGetRequestSummaryResponse(struct soap *soap, struct srm2__srmGetRequestSummaryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmGetRequestSummaryResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetRequestSummaryResponse * SOAP_FMAC4 soap_in_srm2__srmGetRequestSummaryResponse(struct soap *soap, const char *tag, struct srm2__srmGetRequestSummaryResponse *a, const char *type)
{
	short soap_flag_returnStatus = 1, soap_flag_arrayOfRequestSummaries = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmGetRequestSummaryResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmGetRequestSummaryResponse, sizeof(struct srm2__srmGetRequestSummaryResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmGetRequestSummaryResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "returnStatus", &a->returnStatus, "srm2:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_arrayOfRequestSummaries && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTRequestSummary(soap, "arrayOfRequestSummaries", &a->arrayOfRequestSummaries, "srm2:ArrayOfTRequestSummary"))
				{	soap_flag_arrayOfRequestSummaries--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetRequestSummaryResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetRequestSummaryResponse, 0, sizeof(struct srm2__srmGetRequestSummaryResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmGetRequestSummaryRequest(struct soap *soap, const struct srm2__srmGetRequestSummaryRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__ArrayOfString(soap, &a->arrayOfRequestTokens);
	soap_serialize_string(soap, &a->authorizationID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmGetRequestSummaryRequest(struct soap *soap, struct srm2__srmGetRequestSummaryRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->arrayOfRequestTokens = NULL;
	soap_default_string(soap, &a->authorizationID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmGetRequestSummaryRequest(struct soap *soap, const struct srm2__srmGetRequestSummaryRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmGetRequestSummaryRequest);
	if (soap_out_srm2__srmGetRequestSummaryRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmGetRequestSummaryRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmGetRequestSummaryRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmGetRequestSummaryRequest), type);
	soap_out_PointerTosrm2__ArrayOfString(soap, "arrayOfRequestTokens", -1, &a->arrayOfRequestTokens, "");
	soap_out_string(soap, "authorizationID", -1, &a->authorizationID, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmGetRequestSummaryRequest * SOAP_FMAC4 soap_get_srm2__srmGetRequestSummaryRequest(struct soap *soap, struct srm2__srmGetRequestSummaryRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmGetRequestSummaryRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetRequestSummaryRequest * SOAP_FMAC4 soap_in_srm2__srmGetRequestSummaryRequest(struct soap *soap, const char *tag, struct srm2__srmGetRequestSummaryRequest *a, const char *type)
{
	short soap_flag_arrayOfRequestTokens = 1, soap_flag_authorizationID = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmGetRequestSummaryRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmGetRequestSummaryRequest, sizeof(struct srm2__srmGetRequestSummaryRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmGetRequestSummaryRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arrayOfRequestTokens && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfString(soap, "arrayOfRequestTokens", &a->arrayOfRequestTokens, "srm2:ArrayOfString"))
				{	soap_flag_arrayOfRequestTokens--;
					continue;
				}
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arrayOfRequestTokens > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetRequestSummaryRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetRequestSummaryRequest, 0, sizeof(struct srm2__srmGetRequestSummaryRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmResumeRequestResponse(struct soap *soap, const struct srm2__srmResumeRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->returnStatus);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmResumeRequestResponse(struct soap *soap, struct srm2__srmResumeRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmResumeRequestResponse(struct soap *soap, const struct srm2__srmResumeRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmResumeRequestResponse);
	if (soap_out_srm2__srmResumeRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmResumeRequestResponse(struct soap *soap, const char *tag, int id, const struct srm2__srmResumeRequestResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmResumeRequestResponse), type);
	soap_out_PointerTosrm2__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmResumeRequestResponse * SOAP_FMAC4 soap_get_srm2__srmResumeRequestResponse(struct soap *soap, struct srm2__srmResumeRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmResumeRequestResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmResumeRequestResponse * SOAP_FMAC4 soap_in_srm2__srmResumeRequestResponse(struct soap *soap, const char *tag, struct srm2__srmResumeRequestResponse *a, const char *type)
{
	short soap_flag_returnStatus = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmResumeRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmResumeRequestResponse, sizeof(struct srm2__srmResumeRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmResumeRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "returnStatus", &a->returnStatus, "srm2:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmResumeRequestResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmResumeRequestResponse, 0, sizeof(struct srm2__srmResumeRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmResumeRequestRequest(struct soap *soap, const struct srm2__srmResumeRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_string(soap, &a->authorizationID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmResumeRequestRequest(struct soap *soap, struct srm2__srmResumeRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->requestToken);
	soap_default_string(soap, &a->authorizationID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmResumeRequestRequest(struct soap *soap, const struct srm2__srmResumeRequestRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmResumeRequestRequest);
	if (soap_out_srm2__srmResumeRequestRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmResumeRequestRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmResumeRequestRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmResumeRequestRequest), type);
	soap_out_string(soap, "requestToken", -1, &a->requestToken, "");
	soap_out_string(soap, "authorizationID", -1, &a->authorizationID, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmResumeRequestRequest * SOAP_FMAC4 soap_get_srm2__srmResumeRequestRequest(struct soap *soap, struct srm2__srmResumeRequestRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmResumeRequestRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmResumeRequestRequest * SOAP_FMAC4 soap_in_srm2__srmResumeRequestRequest(struct soap *soap, const char *tag, struct srm2__srmResumeRequestRequest *a, const char *type)
{
	short soap_flag_requestToken = 1, soap_flag_authorizationID = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmResumeRequestRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmResumeRequestRequest, sizeof(struct srm2__srmResumeRequestRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmResumeRequestRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmResumeRequestRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmResumeRequestRequest, 0, sizeof(struct srm2__srmResumeRequestRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmSuspendRequestResponse(struct soap *soap, const struct srm2__srmSuspendRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->returnStatus);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmSuspendRequestResponse(struct soap *soap, struct srm2__srmSuspendRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmSuspendRequestResponse(struct soap *soap, const struct srm2__srmSuspendRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmSuspendRequestResponse);
	if (soap_out_srm2__srmSuspendRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmSuspendRequestResponse(struct soap *soap, const char *tag, int id, const struct srm2__srmSuspendRequestResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmSuspendRequestResponse), type);
	soap_out_PointerTosrm2__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmSuspendRequestResponse * SOAP_FMAC4 soap_get_srm2__srmSuspendRequestResponse(struct soap *soap, struct srm2__srmSuspendRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmSuspendRequestResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmSuspendRequestResponse * SOAP_FMAC4 soap_in_srm2__srmSuspendRequestResponse(struct soap *soap, const char *tag, struct srm2__srmSuspendRequestResponse *a, const char *type)
{
	short soap_flag_returnStatus = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmSuspendRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmSuspendRequestResponse, sizeof(struct srm2__srmSuspendRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmSuspendRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "returnStatus", &a->returnStatus, "srm2:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmSuspendRequestResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmSuspendRequestResponse, 0, sizeof(struct srm2__srmSuspendRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmSuspendRequestRequest(struct soap *soap, const struct srm2__srmSuspendRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_string(soap, &a->authorizationID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmSuspendRequestRequest(struct soap *soap, struct srm2__srmSuspendRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->requestToken);
	soap_default_string(soap, &a->authorizationID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmSuspendRequestRequest(struct soap *soap, const struct srm2__srmSuspendRequestRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmSuspendRequestRequest);
	if (soap_out_srm2__srmSuspendRequestRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmSuspendRequestRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmSuspendRequestRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmSuspendRequestRequest), type);
	soap_out_string(soap, "requestToken", -1, &a->requestToken, "");
	soap_out_string(soap, "authorizationID", -1, &a->authorizationID, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmSuspendRequestRequest * SOAP_FMAC4 soap_get_srm2__srmSuspendRequestRequest(struct soap *soap, struct srm2__srmSuspendRequestRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmSuspendRequestRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmSuspendRequestRequest * SOAP_FMAC4 soap_in_srm2__srmSuspendRequestRequest(struct soap *soap, const char *tag, struct srm2__srmSuspendRequestRequest *a, const char *type)
{
	short soap_flag_requestToken = 1, soap_flag_authorizationID = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmSuspendRequestRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmSuspendRequestRequest, sizeof(struct srm2__srmSuspendRequestRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmSuspendRequestRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmSuspendRequestRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmSuspendRequestRequest, 0, sizeof(struct srm2__srmSuspendRequestRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmAbortFilesResponse(struct soap *soap, const struct srm2__srmAbortFilesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerTosrm2__ArrayOfTSURLReturnStatus(soap, &a->arrayOfFileStatuses);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmAbortFilesResponse(struct soap *soap, struct srm2__srmAbortFilesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->arrayOfFileStatuses = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmAbortFilesResponse(struct soap *soap, const struct srm2__srmAbortFilesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmAbortFilesResponse);
	if (soap_out_srm2__srmAbortFilesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmAbortFilesResponse(struct soap *soap, const char *tag, int id, const struct srm2__srmAbortFilesResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmAbortFilesResponse), type);
	soap_out_PointerTosrm2__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, "");
	soap_out_PointerTosrm2__ArrayOfTSURLReturnStatus(soap, "arrayOfFileStatuses", -1, &a->arrayOfFileStatuses, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmAbortFilesResponse * SOAP_FMAC4 soap_get_srm2__srmAbortFilesResponse(struct soap *soap, struct srm2__srmAbortFilesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmAbortFilesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmAbortFilesResponse * SOAP_FMAC4 soap_in_srm2__srmAbortFilesResponse(struct soap *soap, const char *tag, struct srm2__srmAbortFilesResponse *a, const char *type)
{
	short soap_flag_returnStatus = 1, soap_flag_arrayOfFileStatuses = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmAbortFilesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmAbortFilesResponse, sizeof(struct srm2__srmAbortFilesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmAbortFilesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "returnStatus", &a->returnStatus, "srm2:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_arrayOfFileStatuses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTSURLReturnStatus(soap, "arrayOfFileStatuses", &a->arrayOfFileStatuses, "srm2:ArrayOfTSURLReturnStatus"))
				{	soap_flag_arrayOfFileStatuses--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmAbortFilesResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmAbortFilesResponse, 0, sizeof(struct srm2__srmAbortFilesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmAbortFilesRequest(struct soap *soap, const struct srm2__srmAbortFilesRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_PointerTosrm2__ArrayOfAnyURI(soap, &a->arrayOfSURLs);
	soap_serialize_string(soap, &a->authorizationID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmAbortFilesRequest(struct soap *soap, struct srm2__srmAbortFilesRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->requestToken);
	a->arrayOfSURLs = NULL;
	soap_default_string(soap, &a->authorizationID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmAbortFilesRequest(struct soap *soap, const struct srm2__srmAbortFilesRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmAbortFilesRequest);
	if (soap_out_srm2__srmAbortFilesRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmAbortFilesRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmAbortFilesRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmAbortFilesRequest), type);
	soap_out_string(soap, "requestToken", -1, &a->requestToken, "");
	soap_out_PointerTosrm2__ArrayOfAnyURI(soap, "arrayOfSURLs", -1, &a->arrayOfSURLs, "");
	soap_out_string(soap, "authorizationID", -1, &a->authorizationID, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmAbortFilesRequest * SOAP_FMAC4 soap_get_srm2__srmAbortFilesRequest(struct soap *soap, struct srm2__srmAbortFilesRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmAbortFilesRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmAbortFilesRequest * SOAP_FMAC4 soap_in_srm2__srmAbortFilesRequest(struct soap *soap, const char *tag, struct srm2__srmAbortFilesRequest *a, const char *type)
{
	short soap_flag_requestToken = 1, soap_flag_arrayOfSURLs = 1, soap_flag_authorizationID = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmAbortFilesRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmAbortFilesRequest, sizeof(struct srm2__srmAbortFilesRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmAbortFilesRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_arrayOfSURLs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfAnyURI(soap, "arrayOfSURLs", &a->arrayOfSURLs, "srm2:ArrayOfAnyURI"))
				{	soap_flag_arrayOfSURLs--;
					continue;
				}
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestToken > 0 || soap_flag_arrayOfSURLs > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmAbortFilesRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmAbortFilesRequest, 0, sizeof(struct srm2__srmAbortFilesRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmAbortRequestResponse(struct soap *soap, const struct srm2__srmAbortRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->returnStatus);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmAbortRequestResponse(struct soap *soap, struct srm2__srmAbortRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmAbortRequestResponse(struct soap *soap, const struct srm2__srmAbortRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmAbortRequestResponse);
	if (soap_out_srm2__srmAbortRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmAbortRequestResponse(struct soap *soap, const char *tag, int id, const struct srm2__srmAbortRequestResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmAbortRequestResponse), type);
	soap_out_PointerTosrm2__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmAbortRequestResponse * SOAP_FMAC4 soap_get_srm2__srmAbortRequestResponse(struct soap *soap, struct srm2__srmAbortRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmAbortRequestResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmAbortRequestResponse * SOAP_FMAC4 soap_in_srm2__srmAbortRequestResponse(struct soap *soap, const char *tag, struct srm2__srmAbortRequestResponse *a, const char *type)
{
	short soap_flag_returnStatus = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmAbortRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmAbortRequestResponse, sizeof(struct srm2__srmAbortRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmAbortRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "returnStatus", &a->returnStatus, "srm2:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmAbortRequestResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmAbortRequestResponse, 0, sizeof(struct srm2__srmAbortRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmAbortRequestRequest(struct soap *soap, const struct srm2__srmAbortRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_string(soap, &a->authorizationID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmAbortRequestRequest(struct soap *soap, struct srm2__srmAbortRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->requestToken);
	soap_default_string(soap, &a->authorizationID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmAbortRequestRequest(struct soap *soap, const struct srm2__srmAbortRequestRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmAbortRequestRequest);
	if (soap_out_srm2__srmAbortRequestRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmAbortRequestRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmAbortRequestRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmAbortRequestRequest), type);
	soap_out_string(soap, "requestToken", -1, &a->requestToken, "");
	soap_out_string(soap, "authorizationID", -1, &a->authorizationID, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmAbortRequestRequest * SOAP_FMAC4 soap_get_srm2__srmAbortRequestRequest(struct soap *soap, struct srm2__srmAbortRequestRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmAbortRequestRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmAbortRequestRequest * SOAP_FMAC4 soap_in_srm2__srmAbortRequestRequest(struct soap *soap, const char *tag, struct srm2__srmAbortRequestRequest *a, const char *type)
{
	short soap_flag_requestToken = 1, soap_flag_authorizationID = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmAbortRequestRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmAbortRequestRequest, sizeof(struct srm2__srmAbortRequestRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmAbortRequestRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmAbortRequestRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmAbortRequestRequest, 0, sizeof(struct srm2__srmAbortRequestRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmPutDoneResponse(struct soap *soap, const struct srm2__srmPutDoneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerTosrm2__ArrayOfTSURLReturnStatus(soap, &a->arrayOfFileStatuses);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmPutDoneResponse(struct soap *soap, struct srm2__srmPutDoneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->arrayOfFileStatuses = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmPutDoneResponse(struct soap *soap, const struct srm2__srmPutDoneResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmPutDoneResponse);
	if (soap_out_srm2__srmPutDoneResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmPutDoneResponse(struct soap *soap, const char *tag, int id, const struct srm2__srmPutDoneResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmPutDoneResponse), type);
	soap_out_PointerTosrm2__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, "");
	soap_out_PointerTosrm2__ArrayOfTSURLReturnStatus(soap, "arrayOfFileStatuses", -1, &a->arrayOfFileStatuses, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmPutDoneResponse * SOAP_FMAC4 soap_get_srm2__srmPutDoneResponse(struct soap *soap, struct srm2__srmPutDoneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmPutDoneResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmPutDoneResponse * SOAP_FMAC4 soap_in_srm2__srmPutDoneResponse(struct soap *soap, const char *tag, struct srm2__srmPutDoneResponse *a, const char *type)
{
	short soap_flag_returnStatus = 1, soap_flag_arrayOfFileStatuses = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmPutDoneResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmPutDoneResponse, sizeof(struct srm2__srmPutDoneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmPutDoneResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "returnStatus", &a->returnStatus, "srm2:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_arrayOfFileStatuses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTSURLReturnStatus(soap, "arrayOfFileStatuses", &a->arrayOfFileStatuses, "srm2:ArrayOfTSURLReturnStatus"))
				{	soap_flag_arrayOfFileStatuses--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmPutDoneResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmPutDoneResponse, 0, sizeof(struct srm2__srmPutDoneResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmPutDoneRequest(struct soap *soap, const struct srm2__srmPutDoneRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_PointerTosrm2__ArrayOfAnyURI(soap, &a->arrayOfSURLs);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmPutDoneRequest(struct soap *soap, struct srm2__srmPutDoneRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->requestToken);
	soap_default_string(soap, &a->authorizationID);
	a->arrayOfSURLs = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmPutDoneRequest(struct soap *soap, const struct srm2__srmPutDoneRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmPutDoneRequest);
	if (soap_out_srm2__srmPutDoneRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmPutDoneRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmPutDoneRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmPutDoneRequest), type);
	soap_out_string(soap, "requestToken", -1, &a->requestToken, "");
	soap_out_string(soap, "authorizationID", -1, &a->authorizationID, "");
	soap_out_PointerTosrm2__ArrayOfAnyURI(soap, "arrayOfSURLs", -1, &a->arrayOfSURLs, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmPutDoneRequest * SOAP_FMAC4 soap_get_srm2__srmPutDoneRequest(struct soap *soap, struct srm2__srmPutDoneRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmPutDoneRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmPutDoneRequest * SOAP_FMAC4 soap_in_srm2__srmPutDoneRequest(struct soap *soap, const char *tag, struct srm2__srmPutDoneRequest *a, const char *type)
{
	short soap_flag_requestToken = 1, soap_flag_authorizationID = 1, soap_flag_arrayOfSURLs = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmPutDoneRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmPutDoneRequest, sizeof(struct srm2__srmPutDoneRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmPutDoneRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_arrayOfSURLs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfAnyURI(soap, "arrayOfSURLs", &a->arrayOfSURLs, "srm2:ArrayOfAnyURI"))
				{	soap_flag_arrayOfSURLs--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestToken > 0 || soap_flag_arrayOfSURLs > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmPutDoneRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmPutDoneRequest, 0, sizeof(struct srm2__srmPutDoneRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmReleaseFilesResponse(struct soap *soap, const struct srm2__srmReleaseFilesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerTosrm2__ArrayOfTSURLReturnStatus(soap, &a->arrayOfFileStatuses);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmReleaseFilesResponse(struct soap *soap, struct srm2__srmReleaseFilesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->arrayOfFileStatuses = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmReleaseFilesResponse(struct soap *soap, const struct srm2__srmReleaseFilesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmReleaseFilesResponse);
	if (soap_out_srm2__srmReleaseFilesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmReleaseFilesResponse(struct soap *soap, const char *tag, int id, const struct srm2__srmReleaseFilesResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmReleaseFilesResponse), type);
	soap_out_PointerTosrm2__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, "");
	soap_out_PointerTosrm2__ArrayOfTSURLReturnStatus(soap, "arrayOfFileStatuses", -1, &a->arrayOfFileStatuses, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmReleaseFilesResponse * SOAP_FMAC4 soap_get_srm2__srmReleaseFilesResponse(struct soap *soap, struct srm2__srmReleaseFilesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmReleaseFilesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmReleaseFilesResponse * SOAP_FMAC4 soap_in_srm2__srmReleaseFilesResponse(struct soap *soap, const char *tag, struct srm2__srmReleaseFilesResponse *a, const char *type)
{
	short soap_flag_returnStatus = 1, soap_flag_arrayOfFileStatuses = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmReleaseFilesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmReleaseFilesResponse, sizeof(struct srm2__srmReleaseFilesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmReleaseFilesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "returnStatus", &a->returnStatus, "srm2:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_arrayOfFileStatuses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTSURLReturnStatus(soap, "arrayOfFileStatuses", &a->arrayOfFileStatuses, "srm2:ArrayOfTSURLReturnStatus"))
				{	soap_flag_arrayOfFileStatuses--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmReleaseFilesResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmReleaseFilesResponse, 0, sizeof(struct srm2__srmReleaseFilesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmReleaseFilesRequest(struct soap *soap, const struct srm2__srmReleaseFilesRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_PointerTosrm2__ArrayOfAnyURI(soap, &a->arrayOfSURLs);
	soap_serialize_PointerToxsd__boolean(soap, &a->doRemove);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmReleaseFilesRequest(struct soap *soap, struct srm2__srmReleaseFilesRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->requestToken);
	soap_default_string(soap, &a->authorizationID);
	a->arrayOfSURLs = NULL;
	a->doRemove = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmReleaseFilesRequest(struct soap *soap, const struct srm2__srmReleaseFilesRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmReleaseFilesRequest);
	if (soap_out_srm2__srmReleaseFilesRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmReleaseFilesRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmReleaseFilesRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmReleaseFilesRequest), type);
	soap_out_string(soap, "requestToken", -1, &a->requestToken, "");
	soap_out_string(soap, "authorizationID", -1, &a->authorizationID, "");
	soap_out_PointerTosrm2__ArrayOfAnyURI(soap, "arrayOfSURLs", -1, &a->arrayOfSURLs, "");
	soap_out_PointerToxsd__boolean(soap, "doRemove", -1, &a->doRemove, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmReleaseFilesRequest * SOAP_FMAC4 soap_get_srm2__srmReleaseFilesRequest(struct soap *soap, struct srm2__srmReleaseFilesRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmReleaseFilesRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmReleaseFilesRequest * SOAP_FMAC4 soap_in_srm2__srmReleaseFilesRequest(struct soap *soap, const char *tag, struct srm2__srmReleaseFilesRequest *a, const char *type)
{
	short soap_flag_requestToken = 1, soap_flag_authorizationID = 1, soap_flag_arrayOfSURLs = 1, soap_flag_doRemove = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmReleaseFilesRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmReleaseFilesRequest, sizeof(struct srm2__srmReleaseFilesRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmReleaseFilesRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_arrayOfSURLs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfAnyURI(soap, "arrayOfSURLs", &a->arrayOfSURLs, "srm2:ArrayOfAnyURI"))
				{	soap_flag_arrayOfSURLs--;
					continue;
				}
			if (soap_flag_doRemove && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "doRemove", &a->doRemove, "xsd:boolean"))
				{	soap_flag_doRemove--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmReleaseFilesRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmReleaseFilesRequest, 0, sizeof(struct srm2__srmReleaseFilesRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmStatusOfCopyRequestResponse(struct soap *soap, const struct srm2__srmStatusOfCopyRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerTosrm2__ArrayOfTCopyRequestFileStatus(soap, &a->arrayOfFileStatuses);
	soap_serialize_PointerToint(soap, &a->remainingTotalRequestTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmStatusOfCopyRequestResponse(struct soap *soap, struct srm2__srmStatusOfCopyRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->arrayOfFileStatuses = NULL;
	a->remainingTotalRequestTime = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmStatusOfCopyRequestResponse(struct soap *soap, const struct srm2__srmStatusOfCopyRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmStatusOfCopyRequestResponse);
	if (soap_out_srm2__srmStatusOfCopyRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmStatusOfCopyRequestResponse(struct soap *soap, const char *tag, int id, const struct srm2__srmStatusOfCopyRequestResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmStatusOfCopyRequestResponse), type);
	soap_out_PointerTosrm2__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, "");
	soap_out_PointerTosrm2__ArrayOfTCopyRequestFileStatus(soap, "arrayOfFileStatuses", -1, &a->arrayOfFileStatuses, "");
	soap_out_PointerToint(soap, "remainingTotalRequestTime", -1, &a->remainingTotalRequestTime, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmStatusOfCopyRequestResponse * SOAP_FMAC4 soap_get_srm2__srmStatusOfCopyRequestResponse(struct soap *soap, struct srm2__srmStatusOfCopyRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmStatusOfCopyRequestResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfCopyRequestResponse * SOAP_FMAC4 soap_in_srm2__srmStatusOfCopyRequestResponse(struct soap *soap, const char *tag, struct srm2__srmStatusOfCopyRequestResponse *a, const char *type)
{
	short soap_flag_returnStatus = 1, soap_flag_arrayOfFileStatuses = 1, soap_flag_remainingTotalRequestTime = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmStatusOfCopyRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmStatusOfCopyRequestResponse, sizeof(struct srm2__srmStatusOfCopyRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmStatusOfCopyRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "returnStatus", &a->returnStatus, "srm2:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_arrayOfFileStatuses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTCopyRequestFileStatus(soap, "arrayOfFileStatuses", &a->arrayOfFileStatuses, "srm2:ArrayOfTCopyRequestFileStatus"))
				{	soap_flag_arrayOfFileStatuses--;
					continue;
				}
			if (soap_flag_remainingTotalRequestTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "remainingTotalRequestTime", &a->remainingTotalRequestTime, "xsd:int"))
				{	soap_flag_remainingTotalRequestTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfCopyRequestResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfCopyRequestResponse, 0, sizeof(struct srm2__srmStatusOfCopyRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmStatusOfCopyRequestRequest(struct soap *soap, const struct srm2__srmStatusOfCopyRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_PointerTosrm2__ArrayOfAnyURI(soap, &a->arrayOfSourceSURLs);
	soap_serialize_PointerTosrm2__ArrayOfAnyURI(soap, &a->arrayOfTargetSURLs);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmStatusOfCopyRequestRequest(struct soap *soap, struct srm2__srmStatusOfCopyRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->requestToken);
	soap_default_string(soap, &a->authorizationID);
	a->arrayOfSourceSURLs = NULL;
	a->arrayOfTargetSURLs = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmStatusOfCopyRequestRequest(struct soap *soap, const struct srm2__srmStatusOfCopyRequestRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmStatusOfCopyRequestRequest);
	if (soap_out_srm2__srmStatusOfCopyRequestRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmStatusOfCopyRequestRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmStatusOfCopyRequestRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmStatusOfCopyRequestRequest), type);
	soap_out_string(soap, "requestToken", -1, &a->requestToken, "");
	soap_out_string(soap, "authorizationID", -1, &a->authorizationID, "");
	soap_out_PointerTosrm2__ArrayOfAnyURI(soap, "arrayOfSourceSURLs", -1, &a->arrayOfSourceSURLs, "");
	soap_out_PointerTosrm2__ArrayOfAnyURI(soap, "arrayOfTargetSURLs", -1, &a->arrayOfTargetSURLs, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmStatusOfCopyRequestRequest * SOAP_FMAC4 soap_get_srm2__srmStatusOfCopyRequestRequest(struct soap *soap, struct srm2__srmStatusOfCopyRequestRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmStatusOfCopyRequestRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfCopyRequestRequest * SOAP_FMAC4 soap_in_srm2__srmStatusOfCopyRequestRequest(struct soap *soap, const char *tag, struct srm2__srmStatusOfCopyRequestRequest *a, const char *type)
{
	short soap_flag_requestToken = 1, soap_flag_authorizationID = 1, soap_flag_arrayOfSourceSURLs = 1, soap_flag_arrayOfTargetSURLs = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmStatusOfCopyRequestRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmStatusOfCopyRequestRequest, sizeof(struct srm2__srmStatusOfCopyRequestRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmStatusOfCopyRequestRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_arrayOfSourceSURLs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfAnyURI(soap, "arrayOfSourceSURLs", &a->arrayOfSourceSURLs, "srm2:ArrayOfAnyURI"))
				{	soap_flag_arrayOfSourceSURLs--;
					continue;
				}
			if (soap_flag_arrayOfTargetSURLs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfAnyURI(soap, "arrayOfTargetSURLs", &a->arrayOfTargetSURLs, "srm2:ArrayOfAnyURI"))
				{	soap_flag_arrayOfTargetSURLs--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfCopyRequestRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfCopyRequestRequest, 0, sizeof(struct srm2__srmStatusOfCopyRequestRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmCopyResponse(struct soap *soap, const struct srm2__srmCopyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_PointerTosrm2__ArrayOfTCopyRequestFileStatus(soap, &a->arrayOfFileStatuses);
	soap_serialize_PointerToint(soap, &a->remainingTotalRequestTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmCopyResponse(struct soap *soap, struct srm2__srmCopyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	soap_default_string(soap, &a->requestToken);
	a->arrayOfFileStatuses = NULL;
	a->remainingTotalRequestTime = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmCopyResponse(struct soap *soap, const struct srm2__srmCopyResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmCopyResponse);
	if (soap_out_srm2__srmCopyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmCopyResponse(struct soap *soap, const char *tag, int id, const struct srm2__srmCopyResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmCopyResponse), type);
	soap_out_PointerTosrm2__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, "");
	soap_out_string(soap, "requestToken", -1, &a->requestToken, "");
	soap_out_PointerTosrm2__ArrayOfTCopyRequestFileStatus(soap, "arrayOfFileStatuses", -1, &a->arrayOfFileStatuses, "");
	soap_out_PointerToint(soap, "remainingTotalRequestTime", -1, &a->remainingTotalRequestTime, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmCopyResponse * SOAP_FMAC4 soap_get_srm2__srmCopyResponse(struct soap *soap, struct srm2__srmCopyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmCopyResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmCopyResponse * SOAP_FMAC4 soap_in_srm2__srmCopyResponse(struct soap *soap, const char *tag, struct srm2__srmCopyResponse *a, const char *type)
{
	short soap_flag_returnStatus = 1, soap_flag_requestToken = 1, soap_flag_arrayOfFileStatuses = 1, soap_flag_remainingTotalRequestTime = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmCopyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmCopyResponse, sizeof(struct srm2__srmCopyResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmCopyResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "returnStatus", &a->returnStatus, "srm2:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_arrayOfFileStatuses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTCopyRequestFileStatus(soap, "arrayOfFileStatuses", &a->arrayOfFileStatuses, "srm2:ArrayOfTCopyRequestFileStatus"))
				{	soap_flag_arrayOfFileStatuses--;
					continue;
				}
			if (soap_flag_remainingTotalRequestTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "remainingTotalRequestTime", &a->remainingTotalRequestTime, "xsd:int"))
				{	soap_flag_remainingTotalRequestTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmCopyResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmCopyResponse, 0, sizeof(struct srm2__srmCopyResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmCopyRequest(struct soap *soap, const struct srm2__srmCopyRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_PointerTosrm2__ArrayOfTCopyFileRequest(soap, &a->arrayOfFileRequests);
	soap_serialize_string(soap, &a->userRequestDescription);
	soap_serialize_PointerTosrm2__TOverwriteMode(soap, &a->overwriteOption);
	soap_serialize_PointerToint(soap, &a->desiredTotalRequestTime);
	soap_serialize_PointerToint(soap, &a->desiredTargetSURLLifeTime);
	soap_serialize_PointerTosrm2__TFileStorageType(soap, &a->targetFileStorageType);
	soap_serialize_string(soap, &a->targetSpaceToken);
	soap_serialize_PointerTosrm2__TRetentionPolicyInfo(soap, &a->targetFileRetentionPolicyInfo);
	soap_serialize_PointerTosrm2__ArrayOfTExtraInfo(soap, &a->sourceStorageSystemInfo);
	soap_serialize_PointerTosrm2__ArrayOfTExtraInfo(soap, &a->targetStorageSystemInfo);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmCopyRequest(struct soap *soap, struct srm2__srmCopyRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	a->arrayOfFileRequests = NULL;
	soap_default_string(soap, &a->userRequestDescription);
	a->overwriteOption = NULL;
	a->desiredTotalRequestTime = NULL;
	a->desiredTargetSURLLifeTime = NULL;
	a->targetFileStorageType = NULL;
	soap_default_string(soap, &a->targetSpaceToken);
	a->targetFileRetentionPolicyInfo = NULL;
	a->sourceStorageSystemInfo = NULL;
	a->targetStorageSystemInfo = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmCopyRequest(struct soap *soap, const struct srm2__srmCopyRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmCopyRequest);
	if (soap_out_srm2__srmCopyRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmCopyRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmCopyRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmCopyRequest), type);
	soap_out_string(soap, "authorizationID", -1, &a->authorizationID, "");
	soap_out_PointerTosrm2__ArrayOfTCopyFileRequest(soap, "arrayOfFileRequests", -1, &a->arrayOfFileRequests, "");
	soap_out_string(soap, "userRequestDescription", -1, &a->userRequestDescription, "");
	soap_out_PointerTosrm2__TOverwriteMode(soap, "overwriteOption", -1, &a->overwriteOption, "");
	soap_out_PointerToint(soap, "desiredTotalRequestTime", -1, &a->desiredTotalRequestTime, "");
	soap_out_PointerToint(soap, "desiredTargetSURLLifeTime", -1, &a->desiredTargetSURLLifeTime, "");
	soap_out_PointerTosrm2__TFileStorageType(soap, "targetFileStorageType", -1, &a->targetFileStorageType, "");
	soap_out_string(soap, "targetSpaceToken", -1, &a->targetSpaceToken, "");
	soap_out_PointerTosrm2__TRetentionPolicyInfo(soap, "targetFileRetentionPolicyInfo", -1, &a->targetFileRetentionPolicyInfo, "");
	soap_out_PointerTosrm2__ArrayOfTExtraInfo(soap, "sourceStorageSystemInfo", -1, &a->sourceStorageSystemInfo, "");
	soap_out_PointerTosrm2__ArrayOfTExtraInfo(soap, "targetStorageSystemInfo", -1, &a->targetStorageSystemInfo, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmCopyRequest * SOAP_FMAC4 soap_get_srm2__srmCopyRequest(struct soap *soap, struct srm2__srmCopyRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmCopyRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmCopyRequest * SOAP_FMAC4 soap_in_srm2__srmCopyRequest(struct soap *soap, const char *tag, struct srm2__srmCopyRequest *a, const char *type)
{
	short soap_flag_authorizationID = 1, soap_flag_arrayOfFileRequests = 1, soap_flag_userRequestDescription = 1, soap_flag_overwriteOption = 1, soap_flag_desiredTotalRequestTime = 1, soap_flag_desiredTargetSURLLifeTime = 1, soap_flag_targetFileStorageType = 1, soap_flag_targetSpaceToken = 1, soap_flag_targetFileRetentionPolicyInfo = 1, soap_flag_sourceStorageSystemInfo = 1, soap_flag_targetStorageSystemInfo = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmCopyRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmCopyRequest, sizeof(struct srm2__srmCopyRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmCopyRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_arrayOfFileRequests && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTCopyFileRequest(soap, "arrayOfFileRequests", &a->arrayOfFileRequests, "srm2:ArrayOfTCopyFileRequest"))
				{	soap_flag_arrayOfFileRequests--;
					continue;
				}
			if (soap_flag_userRequestDescription && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRequestDescription", &a->userRequestDescription, "xsd:string"))
				{	soap_flag_userRequestDescription--;
					continue;
				}
			if (soap_flag_overwriteOption && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TOverwriteMode(soap, "overwriteOption", &a->overwriteOption, "srm2:TOverwriteMode"))
				{	soap_flag_overwriteOption--;
					continue;
				}
			if (soap_flag_desiredTotalRequestTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "desiredTotalRequestTime", &a->desiredTotalRequestTime, "xsd:int"))
				{	soap_flag_desiredTotalRequestTime--;
					continue;
				}
			if (soap_flag_desiredTargetSURLLifeTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "desiredTargetSURLLifeTime", &a->desiredTargetSURLLifeTime, "xsd:int"))
				{	soap_flag_desiredTargetSURLLifeTime--;
					continue;
				}
			if (soap_flag_targetFileStorageType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TFileStorageType(soap, "targetFileStorageType", &a->targetFileStorageType, "srm2:TFileStorageType"))
				{	soap_flag_targetFileStorageType--;
					continue;
				}
			if (soap_flag_targetSpaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "targetSpaceToken", &a->targetSpaceToken, "xsd:string"))
				{	soap_flag_targetSpaceToken--;
					continue;
				}
			if (soap_flag_targetFileRetentionPolicyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TRetentionPolicyInfo(soap, "targetFileRetentionPolicyInfo", &a->targetFileRetentionPolicyInfo, "srm2:TRetentionPolicyInfo"))
				{	soap_flag_targetFileRetentionPolicyInfo--;
					continue;
				}
			if (soap_flag_sourceStorageSystemInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTExtraInfo(soap, "sourceStorageSystemInfo", &a->sourceStorageSystemInfo, "srm2:ArrayOfTExtraInfo"))
				{	soap_flag_sourceStorageSystemInfo--;
					continue;
				}
			if (soap_flag_targetStorageSystemInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTExtraInfo(soap, "targetStorageSystemInfo", &a->targetStorageSystemInfo, "srm2:ArrayOfTExtraInfo"))
				{	soap_flag_targetStorageSystemInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arrayOfFileRequests > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmCopyRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmCopyRequest, 0, sizeof(struct srm2__srmCopyRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmStatusOfPutRequestResponse(struct soap *soap, const struct srm2__srmStatusOfPutRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerTosrm2__ArrayOfTPutRequestFileStatus(soap, &a->arrayOfFileStatuses);
	soap_serialize_PointerToint(soap, &a->remainingTotalRequestTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmStatusOfPutRequestResponse(struct soap *soap, struct srm2__srmStatusOfPutRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->arrayOfFileStatuses = NULL;
	a->remainingTotalRequestTime = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmStatusOfPutRequestResponse(struct soap *soap, const struct srm2__srmStatusOfPutRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmStatusOfPutRequestResponse);
	if (soap_out_srm2__srmStatusOfPutRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmStatusOfPutRequestResponse(struct soap *soap, const char *tag, int id, const struct srm2__srmStatusOfPutRequestResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmStatusOfPutRequestResponse), type);
	soap_out_PointerTosrm2__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, "");
	soap_out_PointerTosrm2__ArrayOfTPutRequestFileStatus(soap, "arrayOfFileStatuses", -1, &a->arrayOfFileStatuses, "");
	soap_out_PointerToint(soap, "remainingTotalRequestTime", -1, &a->remainingTotalRequestTime, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmStatusOfPutRequestResponse * SOAP_FMAC4 soap_get_srm2__srmStatusOfPutRequestResponse(struct soap *soap, struct srm2__srmStatusOfPutRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmStatusOfPutRequestResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfPutRequestResponse * SOAP_FMAC4 soap_in_srm2__srmStatusOfPutRequestResponse(struct soap *soap, const char *tag, struct srm2__srmStatusOfPutRequestResponse *a, const char *type)
{
	short soap_flag_returnStatus = 1, soap_flag_arrayOfFileStatuses = 1, soap_flag_remainingTotalRequestTime = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmStatusOfPutRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmStatusOfPutRequestResponse, sizeof(struct srm2__srmStatusOfPutRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmStatusOfPutRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "returnStatus", &a->returnStatus, "srm2:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_arrayOfFileStatuses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTPutRequestFileStatus(soap, "arrayOfFileStatuses", &a->arrayOfFileStatuses, "srm2:ArrayOfTPutRequestFileStatus"))
				{	soap_flag_arrayOfFileStatuses--;
					continue;
				}
			if (soap_flag_remainingTotalRequestTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "remainingTotalRequestTime", &a->remainingTotalRequestTime, "xsd:int"))
				{	soap_flag_remainingTotalRequestTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfPutRequestResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfPutRequestResponse, 0, sizeof(struct srm2__srmStatusOfPutRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmStatusOfPutRequestRequest(struct soap *soap, const struct srm2__srmStatusOfPutRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_PointerTosrm2__ArrayOfAnyURI(soap, &a->arrayOfTargetSURLs);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmStatusOfPutRequestRequest(struct soap *soap, struct srm2__srmStatusOfPutRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->requestToken);
	soap_default_string(soap, &a->authorizationID);
	a->arrayOfTargetSURLs = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmStatusOfPutRequestRequest(struct soap *soap, const struct srm2__srmStatusOfPutRequestRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmStatusOfPutRequestRequest);
	if (soap_out_srm2__srmStatusOfPutRequestRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmStatusOfPutRequestRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmStatusOfPutRequestRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmStatusOfPutRequestRequest), type);
	soap_out_string(soap, "requestToken", -1, &a->requestToken, "");
	soap_out_string(soap, "authorizationID", -1, &a->authorizationID, "");
	soap_out_PointerTosrm2__ArrayOfAnyURI(soap, "arrayOfTargetSURLs", -1, &a->arrayOfTargetSURLs, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmStatusOfPutRequestRequest * SOAP_FMAC4 soap_get_srm2__srmStatusOfPutRequestRequest(struct soap *soap, struct srm2__srmStatusOfPutRequestRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmStatusOfPutRequestRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfPutRequestRequest * SOAP_FMAC4 soap_in_srm2__srmStatusOfPutRequestRequest(struct soap *soap, const char *tag, struct srm2__srmStatusOfPutRequestRequest *a, const char *type)
{
	short soap_flag_requestToken = 1, soap_flag_authorizationID = 1, soap_flag_arrayOfTargetSURLs = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmStatusOfPutRequestRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmStatusOfPutRequestRequest, sizeof(struct srm2__srmStatusOfPutRequestRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmStatusOfPutRequestRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_arrayOfTargetSURLs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfAnyURI(soap, "arrayOfTargetSURLs", &a->arrayOfTargetSURLs, "srm2:ArrayOfAnyURI"))
				{	soap_flag_arrayOfTargetSURLs--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfPutRequestRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfPutRequestRequest, 0, sizeof(struct srm2__srmStatusOfPutRequestRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmPrepareToPutResponse(struct soap *soap, const struct srm2__srmPrepareToPutResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_PointerTosrm2__ArrayOfTPutRequestFileStatus(soap, &a->arrayOfFileStatuses);
	soap_serialize_PointerToint(soap, &a->remainingTotalRequestTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmPrepareToPutResponse(struct soap *soap, struct srm2__srmPrepareToPutResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	soap_default_string(soap, &a->requestToken);
	a->arrayOfFileStatuses = NULL;
	a->remainingTotalRequestTime = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmPrepareToPutResponse(struct soap *soap, const struct srm2__srmPrepareToPutResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmPrepareToPutResponse);
	if (soap_out_srm2__srmPrepareToPutResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmPrepareToPutResponse(struct soap *soap, const char *tag, int id, const struct srm2__srmPrepareToPutResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmPrepareToPutResponse), type);
	soap_out_PointerTosrm2__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, "");
	soap_out_string(soap, "requestToken", -1, &a->requestToken, "");
	soap_out_PointerTosrm2__ArrayOfTPutRequestFileStatus(soap, "arrayOfFileStatuses", -1, &a->arrayOfFileStatuses, "");
	soap_out_PointerToint(soap, "remainingTotalRequestTime", -1, &a->remainingTotalRequestTime, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmPrepareToPutResponse * SOAP_FMAC4 soap_get_srm2__srmPrepareToPutResponse(struct soap *soap, struct srm2__srmPrepareToPutResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmPrepareToPutResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmPrepareToPutResponse * SOAP_FMAC4 soap_in_srm2__srmPrepareToPutResponse(struct soap *soap, const char *tag, struct srm2__srmPrepareToPutResponse *a, const char *type)
{
	short soap_flag_returnStatus = 1, soap_flag_requestToken = 1, soap_flag_arrayOfFileStatuses = 1, soap_flag_remainingTotalRequestTime = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmPrepareToPutResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmPrepareToPutResponse, sizeof(struct srm2__srmPrepareToPutResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmPrepareToPutResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "returnStatus", &a->returnStatus, "srm2:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_arrayOfFileStatuses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTPutRequestFileStatus(soap, "arrayOfFileStatuses", &a->arrayOfFileStatuses, "srm2:ArrayOfTPutRequestFileStatus"))
				{	soap_flag_arrayOfFileStatuses--;
					continue;
				}
			if (soap_flag_remainingTotalRequestTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "remainingTotalRequestTime", &a->remainingTotalRequestTime, "xsd:int"))
				{	soap_flag_remainingTotalRequestTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmPrepareToPutResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmPrepareToPutResponse, 0, sizeof(struct srm2__srmPrepareToPutResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmPrepareToPutRequest(struct soap *soap, const struct srm2__srmPrepareToPutRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_PointerTosrm2__ArrayOfTPutFileRequest(soap, &a->arrayOfFileRequests);
	soap_serialize_string(soap, &a->userRequestDescription);
	soap_serialize_PointerTosrm2__TOverwriteMode(soap, &a->overwriteOption);
	soap_serialize_PointerTosrm2__ArrayOfTExtraInfo(soap, &a->storageSystemInfo);
	soap_serialize_PointerToint(soap, &a->desiredTotalRequestTime);
	soap_serialize_PointerToint(soap, &a->desiredPinLifeTime);
	soap_serialize_PointerToint(soap, &a->desiredFileLifeTime);
	soap_serialize_PointerTosrm2__TFileStorageType(soap, &a->desiredFileStorageType);
	soap_serialize_string(soap, &a->targetSpaceToken);
	soap_serialize_PointerTosrm2__TRetentionPolicyInfo(soap, &a->targetFileRetentionPolicyInfo);
	soap_serialize_PointerTosrm2__TTransferParameters(soap, &a->transferParameters);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmPrepareToPutRequest(struct soap *soap, struct srm2__srmPrepareToPutRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	a->arrayOfFileRequests = NULL;
	soap_default_string(soap, &a->userRequestDescription);
	a->overwriteOption = NULL;
	a->storageSystemInfo = NULL;
	a->desiredTotalRequestTime = NULL;
	a->desiredPinLifeTime = NULL;
	a->desiredFileLifeTime = NULL;
	a->desiredFileStorageType = NULL;
	soap_default_string(soap, &a->targetSpaceToken);
	a->targetFileRetentionPolicyInfo = NULL;
	a->transferParameters = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmPrepareToPutRequest(struct soap *soap, const struct srm2__srmPrepareToPutRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmPrepareToPutRequest);
	if (soap_out_srm2__srmPrepareToPutRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmPrepareToPutRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmPrepareToPutRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmPrepareToPutRequest), type);
	soap_out_string(soap, "authorizationID", -1, &a->authorizationID, "");
	soap_out_PointerTosrm2__ArrayOfTPutFileRequest(soap, "arrayOfFileRequests", -1, &a->arrayOfFileRequests, "");
	soap_out_string(soap, "userRequestDescription", -1, &a->userRequestDescription, "");
	soap_out_PointerTosrm2__TOverwriteMode(soap, "overwriteOption", -1, &a->overwriteOption, "");
	soap_out_PointerTosrm2__ArrayOfTExtraInfo(soap, "storageSystemInfo", -1, &a->storageSystemInfo, "");
	soap_out_PointerToint(soap, "desiredTotalRequestTime", -1, &a->desiredTotalRequestTime, "");
	soap_out_PointerToint(soap, "desiredPinLifeTime", -1, &a->desiredPinLifeTime, "");
	soap_out_PointerToint(soap, "desiredFileLifeTime", -1, &a->desiredFileLifeTime, "");
	soap_out_PointerTosrm2__TFileStorageType(soap, "desiredFileStorageType", -1, &a->desiredFileStorageType, "");
	soap_out_string(soap, "targetSpaceToken", -1, &a->targetSpaceToken, "");
	soap_out_PointerTosrm2__TRetentionPolicyInfo(soap, "targetFileRetentionPolicyInfo", -1, &a->targetFileRetentionPolicyInfo, "");
	soap_out_PointerTosrm2__TTransferParameters(soap, "transferParameters", -1, &a->transferParameters, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmPrepareToPutRequest * SOAP_FMAC4 soap_get_srm2__srmPrepareToPutRequest(struct soap *soap, struct srm2__srmPrepareToPutRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmPrepareToPutRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmPrepareToPutRequest * SOAP_FMAC4 soap_in_srm2__srmPrepareToPutRequest(struct soap *soap, const char *tag, struct srm2__srmPrepareToPutRequest *a, const char *type)
{
	short soap_flag_authorizationID = 1, soap_flag_arrayOfFileRequests = 1, soap_flag_userRequestDescription = 1, soap_flag_overwriteOption = 1, soap_flag_storageSystemInfo = 1, soap_flag_desiredTotalRequestTime = 1, soap_flag_desiredPinLifeTime = 1, soap_flag_desiredFileLifeTime = 1, soap_flag_desiredFileStorageType = 1, soap_flag_targetSpaceToken = 1, soap_flag_targetFileRetentionPolicyInfo = 1, soap_flag_transferParameters = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmPrepareToPutRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmPrepareToPutRequest, sizeof(struct srm2__srmPrepareToPutRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmPrepareToPutRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_arrayOfFileRequests && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTPutFileRequest(soap, "arrayOfFileRequests", &a->arrayOfFileRequests, "srm2:ArrayOfTPutFileRequest"))
				{	soap_flag_arrayOfFileRequests--;
					continue;
				}
			if (soap_flag_userRequestDescription && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRequestDescription", &a->userRequestDescription, "xsd:string"))
				{	soap_flag_userRequestDescription--;
					continue;
				}
			if (soap_flag_overwriteOption && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TOverwriteMode(soap, "overwriteOption", &a->overwriteOption, "srm2:TOverwriteMode"))
				{	soap_flag_overwriteOption--;
					continue;
				}
			if (soap_flag_storageSystemInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTExtraInfo(soap, "storageSystemInfo", &a->storageSystemInfo, "srm2:ArrayOfTExtraInfo"))
				{	soap_flag_storageSystemInfo--;
					continue;
				}
			if (soap_flag_desiredTotalRequestTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "desiredTotalRequestTime", &a->desiredTotalRequestTime, "xsd:int"))
				{	soap_flag_desiredTotalRequestTime--;
					continue;
				}
			if (soap_flag_desiredPinLifeTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "desiredPinLifeTime", &a->desiredPinLifeTime, "xsd:int"))
				{	soap_flag_desiredPinLifeTime--;
					continue;
				}
			if (soap_flag_desiredFileLifeTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "desiredFileLifeTime", &a->desiredFileLifeTime, "xsd:int"))
				{	soap_flag_desiredFileLifeTime--;
					continue;
				}
			if (soap_flag_desiredFileStorageType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TFileStorageType(soap, "desiredFileStorageType", &a->desiredFileStorageType, "srm2:TFileStorageType"))
				{	soap_flag_desiredFileStorageType--;
					continue;
				}
			if (soap_flag_targetSpaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "targetSpaceToken", &a->targetSpaceToken, "xsd:string"))
				{	soap_flag_targetSpaceToken--;
					continue;
				}
			if (soap_flag_targetFileRetentionPolicyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TRetentionPolicyInfo(soap, "targetFileRetentionPolicyInfo", &a->targetFileRetentionPolicyInfo, "srm2:TRetentionPolicyInfo"))
				{	soap_flag_targetFileRetentionPolicyInfo--;
					continue;
				}
			if (soap_flag_transferParameters && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TTransferParameters(soap, "transferParameters", &a->transferParameters, "srm2:TTransferParameters"))
				{	soap_flag_transferParameters--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmPrepareToPutRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmPrepareToPutRequest, 0, sizeof(struct srm2__srmPrepareToPutRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmStatusOfBringOnlineRequestResponse(struct soap *soap, const struct srm2__srmStatusOfBringOnlineRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerTosrm2__ArrayOfTBringOnlineRequestFileStatus(soap, &a->arrayOfFileStatuses);
	soap_serialize_PointerToint(soap, &a->remainingTotalRequestTime);
	soap_serialize_PointerToint(soap, &a->remainingDeferredStartTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmStatusOfBringOnlineRequestResponse(struct soap *soap, struct srm2__srmStatusOfBringOnlineRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->arrayOfFileStatuses = NULL;
	a->remainingTotalRequestTime = NULL;
	a->remainingDeferredStartTime = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmStatusOfBringOnlineRequestResponse(struct soap *soap, const struct srm2__srmStatusOfBringOnlineRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmStatusOfBringOnlineRequestResponse);
	if (soap_out_srm2__srmStatusOfBringOnlineRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmStatusOfBringOnlineRequestResponse(struct soap *soap, const char *tag, int id, const struct srm2__srmStatusOfBringOnlineRequestResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmStatusOfBringOnlineRequestResponse), type);
	soap_out_PointerTosrm2__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, "");
	soap_out_PointerTosrm2__ArrayOfTBringOnlineRequestFileStatus(soap, "arrayOfFileStatuses", -1, &a->arrayOfFileStatuses, "");
	soap_out_PointerToint(soap, "remainingTotalRequestTime", -1, &a->remainingTotalRequestTime, "");
	soap_out_PointerToint(soap, "remainingDeferredStartTime", -1, &a->remainingDeferredStartTime, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmStatusOfBringOnlineRequestResponse * SOAP_FMAC4 soap_get_srm2__srmStatusOfBringOnlineRequestResponse(struct soap *soap, struct srm2__srmStatusOfBringOnlineRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmStatusOfBringOnlineRequestResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfBringOnlineRequestResponse * SOAP_FMAC4 soap_in_srm2__srmStatusOfBringOnlineRequestResponse(struct soap *soap, const char *tag, struct srm2__srmStatusOfBringOnlineRequestResponse *a, const char *type)
{
	short soap_flag_returnStatus = 1, soap_flag_arrayOfFileStatuses = 1, soap_flag_remainingTotalRequestTime = 1, soap_flag_remainingDeferredStartTime = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmStatusOfBringOnlineRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmStatusOfBringOnlineRequestResponse, sizeof(struct srm2__srmStatusOfBringOnlineRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmStatusOfBringOnlineRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "returnStatus", &a->returnStatus, "srm2:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_arrayOfFileStatuses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTBringOnlineRequestFileStatus(soap, "arrayOfFileStatuses", &a->arrayOfFileStatuses, "srm2:ArrayOfTBringOnlineRequestFileStatus"))
				{	soap_flag_arrayOfFileStatuses--;
					continue;
				}
			if (soap_flag_remainingTotalRequestTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "remainingTotalRequestTime", &a->remainingTotalRequestTime, "xsd:int"))
				{	soap_flag_remainingTotalRequestTime--;
					continue;
				}
			if (soap_flag_remainingDeferredStartTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "remainingDeferredStartTime", &a->remainingDeferredStartTime, "xsd:int"))
				{	soap_flag_remainingDeferredStartTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfBringOnlineRequestResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfBringOnlineRequestResponse, 0, sizeof(struct srm2__srmStatusOfBringOnlineRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmStatusOfBringOnlineRequestRequest(struct soap *soap, const struct srm2__srmStatusOfBringOnlineRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_PointerTosrm2__ArrayOfAnyURI(soap, &a->arrayOfSourceSURLs);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmStatusOfBringOnlineRequestRequest(struct soap *soap, struct srm2__srmStatusOfBringOnlineRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->requestToken);
	soap_default_string(soap, &a->authorizationID);
	a->arrayOfSourceSURLs = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmStatusOfBringOnlineRequestRequest(struct soap *soap, const struct srm2__srmStatusOfBringOnlineRequestRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmStatusOfBringOnlineRequestRequest);
	if (soap_out_srm2__srmStatusOfBringOnlineRequestRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmStatusOfBringOnlineRequestRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmStatusOfBringOnlineRequestRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmStatusOfBringOnlineRequestRequest), type);
	soap_out_string(soap, "requestToken", -1, &a->requestToken, "");
	soap_out_string(soap, "authorizationID", -1, &a->authorizationID, "");
	soap_out_PointerTosrm2__ArrayOfAnyURI(soap, "arrayOfSourceSURLs", -1, &a->arrayOfSourceSURLs, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmStatusOfBringOnlineRequestRequest * SOAP_FMAC4 soap_get_srm2__srmStatusOfBringOnlineRequestRequest(struct soap *soap, struct srm2__srmStatusOfBringOnlineRequestRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmStatusOfBringOnlineRequestRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfBringOnlineRequestRequest * SOAP_FMAC4 soap_in_srm2__srmStatusOfBringOnlineRequestRequest(struct soap *soap, const char *tag, struct srm2__srmStatusOfBringOnlineRequestRequest *a, const char *type)
{
	short soap_flag_requestToken = 1, soap_flag_authorizationID = 1, soap_flag_arrayOfSourceSURLs = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmStatusOfBringOnlineRequestRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmStatusOfBringOnlineRequestRequest, sizeof(struct srm2__srmStatusOfBringOnlineRequestRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmStatusOfBringOnlineRequestRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_arrayOfSourceSURLs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfAnyURI(soap, "arrayOfSourceSURLs", &a->arrayOfSourceSURLs, "srm2:ArrayOfAnyURI"))
				{	soap_flag_arrayOfSourceSURLs--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfBringOnlineRequestRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfBringOnlineRequestRequest, 0, sizeof(struct srm2__srmStatusOfBringOnlineRequestRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmBringOnlineResponse(struct soap *soap, const struct srm2__srmBringOnlineResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_PointerTosrm2__ArrayOfTBringOnlineRequestFileStatus(soap, &a->arrayOfFileStatuses);
	soap_serialize_PointerToint(soap, &a->remainingTotalRequestTime);
	soap_serialize_PointerToint(soap, &a->remainingDeferredStartTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmBringOnlineResponse(struct soap *soap, struct srm2__srmBringOnlineResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	soap_default_string(soap, &a->requestToken);
	a->arrayOfFileStatuses = NULL;
	a->remainingTotalRequestTime = NULL;
	a->remainingDeferredStartTime = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmBringOnlineResponse(struct soap *soap, const struct srm2__srmBringOnlineResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmBringOnlineResponse);
	if (soap_out_srm2__srmBringOnlineResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmBringOnlineResponse(struct soap *soap, const char *tag, int id, const struct srm2__srmBringOnlineResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmBringOnlineResponse), type);
	soap_out_PointerTosrm2__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, "");
	soap_out_string(soap, "requestToken", -1, &a->requestToken, "");
	soap_out_PointerTosrm2__ArrayOfTBringOnlineRequestFileStatus(soap, "arrayOfFileStatuses", -1, &a->arrayOfFileStatuses, "");
	soap_out_PointerToint(soap, "remainingTotalRequestTime", -1, &a->remainingTotalRequestTime, "");
	soap_out_PointerToint(soap, "remainingDeferredStartTime", -1, &a->remainingDeferredStartTime, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmBringOnlineResponse * SOAP_FMAC4 soap_get_srm2__srmBringOnlineResponse(struct soap *soap, struct srm2__srmBringOnlineResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmBringOnlineResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmBringOnlineResponse * SOAP_FMAC4 soap_in_srm2__srmBringOnlineResponse(struct soap *soap, const char *tag, struct srm2__srmBringOnlineResponse *a, const char *type)
{
	short soap_flag_returnStatus = 1, soap_flag_requestToken = 1, soap_flag_arrayOfFileStatuses = 1, soap_flag_remainingTotalRequestTime = 1, soap_flag_remainingDeferredStartTime = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmBringOnlineResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmBringOnlineResponse, sizeof(struct srm2__srmBringOnlineResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmBringOnlineResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "returnStatus", &a->returnStatus, "srm2:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_arrayOfFileStatuses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTBringOnlineRequestFileStatus(soap, "arrayOfFileStatuses", &a->arrayOfFileStatuses, "srm2:ArrayOfTBringOnlineRequestFileStatus"))
				{	soap_flag_arrayOfFileStatuses--;
					continue;
				}
			if (soap_flag_remainingTotalRequestTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "remainingTotalRequestTime", &a->remainingTotalRequestTime, "xsd:int"))
				{	soap_flag_remainingTotalRequestTime--;
					continue;
				}
			if (soap_flag_remainingDeferredStartTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "remainingDeferredStartTime", &a->remainingDeferredStartTime, "xsd:int"))
				{	soap_flag_remainingDeferredStartTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmBringOnlineResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmBringOnlineResponse, 0, sizeof(struct srm2__srmBringOnlineResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmBringOnlineRequest(struct soap *soap, const struct srm2__srmBringOnlineRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_PointerTosrm2__ArrayOfTGetFileRequest(soap, &a->arrayOfFileRequests);
	soap_serialize_string(soap, &a->userRequestDescription);
	soap_serialize_PointerTosrm2__ArrayOfTExtraInfo(soap, &a->storageSystemInfo);
	soap_serialize_PointerTosrm2__TFileStorageType(soap, &a->desiredFileStorageType);
	soap_serialize_PointerToint(soap, &a->desiredTotalRequestTime);
	soap_serialize_PointerToint(soap, &a->desiredLifeTime);
	soap_serialize_string(soap, &a->targetSpaceToken);
	soap_serialize_PointerTosrm2__TRetentionPolicyInfo(soap, &a->targetFileRetentionPolicyInfo);
	soap_serialize_PointerTosrm2__TTransferParameters(soap, &a->transferParameters);
	soap_serialize_PointerToint(soap, &a->deferredStartTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmBringOnlineRequest(struct soap *soap, struct srm2__srmBringOnlineRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	a->arrayOfFileRequests = NULL;
	soap_default_string(soap, &a->userRequestDescription);
	a->storageSystemInfo = NULL;
	a->desiredFileStorageType = NULL;
	a->desiredTotalRequestTime = NULL;
	a->desiredLifeTime = NULL;
	soap_default_string(soap, &a->targetSpaceToken);
	a->targetFileRetentionPolicyInfo = NULL;
	a->transferParameters = NULL;
	a->deferredStartTime = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmBringOnlineRequest(struct soap *soap, const struct srm2__srmBringOnlineRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmBringOnlineRequest);
	if (soap_out_srm2__srmBringOnlineRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmBringOnlineRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmBringOnlineRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmBringOnlineRequest), type);
	soap_out_string(soap, "authorizationID", -1, &a->authorizationID, "");
	soap_out_PointerTosrm2__ArrayOfTGetFileRequest(soap, "arrayOfFileRequests", -1, &a->arrayOfFileRequests, "");
	soap_out_string(soap, "userRequestDescription", -1, &a->userRequestDescription, "");
	soap_out_PointerTosrm2__ArrayOfTExtraInfo(soap, "storageSystemInfo", -1, &a->storageSystemInfo, "");
	soap_out_PointerTosrm2__TFileStorageType(soap, "desiredFileStorageType", -1, &a->desiredFileStorageType, "");
	soap_out_PointerToint(soap, "desiredTotalRequestTime", -1, &a->desiredTotalRequestTime, "");
	soap_out_PointerToint(soap, "desiredLifeTime", -1, &a->desiredLifeTime, "");
	soap_out_string(soap, "targetSpaceToken", -1, &a->targetSpaceToken, "");
	soap_out_PointerTosrm2__TRetentionPolicyInfo(soap, "targetFileRetentionPolicyInfo", -1, &a->targetFileRetentionPolicyInfo, "");
	soap_out_PointerTosrm2__TTransferParameters(soap, "transferParameters", -1, &a->transferParameters, "");
	soap_out_PointerToint(soap, "deferredStartTime", -1, &a->deferredStartTime, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmBringOnlineRequest * SOAP_FMAC4 soap_get_srm2__srmBringOnlineRequest(struct soap *soap, struct srm2__srmBringOnlineRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmBringOnlineRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmBringOnlineRequest * SOAP_FMAC4 soap_in_srm2__srmBringOnlineRequest(struct soap *soap, const char *tag, struct srm2__srmBringOnlineRequest *a, const char *type)
{
	short soap_flag_authorizationID = 1, soap_flag_arrayOfFileRequests = 1, soap_flag_userRequestDescription = 1, soap_flag_storageSystemInfo = 1, soap_flag_desiredFileStorageType = 1, soap_flag_desiredTotalRequestTime = 1, soap_flag_desiredLifeTime = 1, soap_flag_targetSpaceToken = 1, soap_flag_targetFileRetentionPolicyInfo = 1, soap_flag_transferParameters = 1, soap_flag_deferredStartTime = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmBringOnlineRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmBringOnlineRequest, sizeof(struct srm2__srmBringOnlineRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmBringOnlineRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_arrayOfFileRequests && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTGetFileRequest(soap, "arrayOfFileRequests", &a->arrayOfFileRequests, "srm2:ArrayOfTGetFileRequest"))
				{	soap_flag_arrayOfFileRequests--;
					continue;
				}
			if (soap_flag_userRequestDescription && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRequestDescription", &a->userRequestDescription, "xsd:string"))
				{	soap_flag_userRequestDescription--;
					continue;
				}
			if (soap_flag_storageSystemInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTExtraInfo(soap, "storageSystemInfo", &a->storageSystemInfo, "srm2:ArrayOfTExtraInfo"))
				{	soap_flag_storageSystemInfo--;
					continue;
				}
			if (soap_flag_desiredFileStorageType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TFileStorageType(soap, "desiredFileStorageType", &a->desiredFileStorageType, "srm2:TFileStorageType"))
				{	soap_flag_desiredFileStorageType--;
					continue;
				}
			if (soap_flag_desiredTotalRequestTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "desiredTotalRequestTime", &a->desiredTotalRequestTime, "xsd:int"))
				{	soap_flag_desiredTotalRequestTime--;
					continue;
				}
			if (soap_flag_desiredLifeTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "desiredLifeTime", &a->desiredLifeTime, "xsd:int"))
				{	soap_flag_desiredLifeTime--;
					continue;
				}
			if (soap_flag_targetSpaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "targetSpaceToken", &a->targetSpaceToken, "xsd:string"))
				{	soap_flag_targetSpaceToken--;
					continue;
				}
			if (soap_flag_targetFileRetentionPolicyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TRetentionPolicyInfo(soap, "targetFileRetentionPolicyInfo", &a->targetFileRetentionPolicyInfo, "srm2:TRetentionPolicyInfo"))
				{	soap_flag_targetFileRetentionPolicyInfo--;
					continue;
				}
			if (soap_flag_transferParameters && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TTransferParameters(soap, "transferParameters", &a->transferParameters, "srm2:TTransferParameters"))
				{	soap_flag_transferParameters--;
					continue;
				}
			if (soap_flag_deferredStartTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "deferredStartTime", &a->deferredStartTime, "xsd:int"))
				{	soap_flag_deferredStartTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arrayOfFileRequests > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmBringOnlineRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmBringOnlineRequest, 0, sizeof(struct srm2__srmBringOnlineRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmStatusOfGetRequestResponse(struct soap *soap, const struct srm2__srmStatusOfGetRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerTosrm2__ArrayOfTGetRequestFileStatus(soap, &a->arrayOfFileStatuses);
	soap_serialize_PointerToint(soap, &a->remainingTotalRequestTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmStatusOfGetRequestResponse(struct soap *soap, struct srm2__srmStatusOfGetRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->arrayOfFileStatuses = NULL;
	a->remainingTotalRequestTime = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmStatusOfGetRequestResponse(struct soap *soap, const struct srm2__srmStatusOfGetRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmStatusOfGetRequestResponse);
	if (soap_out_srm2__srmStatusOfGetRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmStatusOfGetRequestResponse(struct soap *soap, const char *tag, int id, const struct srm2__srmStatusOfGetRequestResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmStatusOfGetRequestResponse), type);
	soap_out_PointerTosrm2__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, "");
	soap_out_PointerTosrm2__ArrayOfTGetRequestFileStatus(soap, "arrayOfFileStatuses", -1, &a->arrayOfFileStatuses, "");
	soap_out_PointerToint(soap, "remainingTotalRequestTime", -1, &a->remainingTotalRequestTime, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmStatusOfGetRequestResponse * SOAP_FMAC4 soap_get_srm2__srmStatusOfGetRequestResponse(struct soap *soap, struct srm2__srmStatusOfGetRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmStatusOfGetRequestResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfGetRequestResponse * SOAP_FMAC4 soap_in_srm2__srmStatusOfGetRequestResponse(struct soap *soap, const char *tag, struct srm2__srmStatusOfGetRequestResponse *a, const char *type)
{
	short soap_flag_returnStatus = 1, soap_flag_arrayOfFileStatuses = 1, soap_flag_remainingTotalRequestTime = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmStatusOfGetRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmStatusOfGetRequestResponse, sizeof(struct srm2__srmStatusOfGetRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmStatusOfGetRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "returnStatus", &a->returnStatus, "srm2:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_arrayOfFileStatuses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTGetRequestFileStatus(soap, "arrayOfFileStatuses", &a->arrayOfFileStatuses, "srm2:ArrayOfTGetRequestFileStatus"))
				{	soap_flag_arrayOfFileStatuses--;
					continue;
				}
			if (soap_flag_remainingTotalRequestTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "remainingTotalRequestTime", &a->remainingTotalRequestTime, "xsd:int"))
				{	soap_flag_remainingTotalRequestTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfGetRequestResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfGetRequestResponse, 0, sizeof(struct srm2__srmStatusOfGetRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmStatusOfGetRequestRequest(struct soap *soap, const struct srm2__srmStatusOfGetRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_PointerTosrm2__ArrayOfAnyURI(soap, &a->arrayOfSourceSURLs);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmStatusOfGetRequestRequest(struct soap *soap, struct srm2__srmStatusOfGetRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->requestToken);
	soap_default_string(soap, &a->authorizationID);
	a->arrayOfSourceSURLs = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmStatusOfGetRequestRequest(struct soap *soap, const struct srm2__srmStatusOfGetRequestRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmStatusOfGetRequestRequest);
	if (soap_out_srm2__srmStatusOfGetRequestRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmStatusOfGetRequestRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmStatusOfGetRequestRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmStatusOfGetRequestRequest), type);
	soap_out_string(soap, "requestToken", -1, &a->requestToken, "");
	soap_out_string(soap, "authorizationID", -1, &a->authorizationID, "");
	soap_out_PointerTosrm2__ArrayOfAnyURI(soap, "arrayOfSourceSURLs", -1, &a->arrayOfSourceSURLs, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmStatusOfGetRequestRequest * SOAP_FMAC4 soap_get_srm2__srmStatusOfGetRequestRequest(struct soap *soap, struct srm2__srmStatusOfGetRequestRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmStatusOfGetRequestRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfGetRequestRequest * SOAP_FMAC4 soap_in_srm2__srmStatusOfGetRequestRequest(struct soap *soap, const char *tag, struct srm2__srmStatusOfGetRequestRequest *a, const char *type)
{
	short soap_flag_requestToken = 1, soap_flag_authorizationID = 1, soap_flag_arrayOfSourceSURLs = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmStatusOfGetRequestRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmStatusOfGetRequestRequest, sizeof(struct srm2__srmStatusOfGetRequestRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmStatusOfGetRequestRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_arrayOfSourceSURLs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfAnyURI(soap, "arrayOfSourceSURLs", &a->arrayOfSourceSURLs, "srm2:ArrayOfAnyURI"))
				{	soap_flag_arrayOfSourceSURLs--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfGetRequestRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfGetRequestRequest, 0, sizeof(struct srm2__srmStatusOfGetRequestRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmPrepareToGetResponse(struct soap *soap, const struct srm2__srmPrepareToGetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_PointerTosrm2__ArrayOfTGetRequestFileStatus(soap, &a->arrayOfFileStatuses);
	soap_serialize_PointerToint(soap, &a->remainingTotalRequestTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmPrepareToGetResponse(struct soap *soap, struct srm2__srmPrepareToGetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	soap_default_string(soap, &a->requestToken);
	a->arrayOfFileStatuses = NULL;
	a->remainingTotalRequestTime = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmPrepareToGetResponse(struct soap *soap, const struct srm2__srmPrepareToGetResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmPrepareToGetResponse);
	if (soap_out_srm2__srmPrepareToGetResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmPrepareToGetResponse(struct soap *soap, const char *tag, int id, const struct srm2__srmPrepareToGetResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmPrepareToGetResponse), type);
	soap_out_PointerTosrm2__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, "");
	soap_out_string(soap, "requestToken", -1, &a->requestToken, "");
	soap_out_PointerTosrm2__ArrayOfTGetRequestFileStatus(soap, "arrayOfFileStatuses", -1, &a->arrayOfFileStatuses, "");
	soap_out_PointerToint(soap, "remainingTotalRequestTime", -1, &a->remainingTotalRequestTime, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmPrepareToGetResponse * SOAP_FMAC4 soap_get_srm2__srmPrepareToGetResponse(struct soap *soap, struct srm2__srmPrepareToGetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmPrepareToGetResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmPrepareToGetResponse * SOAP_FMAC4 soap_in_srm2__srmPrepareToGetResponse(struct soap *soap, const char *tag, struct srm2__srmPrepareToGetResponse *a, const char *type)
{
	short soap_flag_returnStatus = 1, soap_flag_requestToken = 1, soap_flag_arrayOfFileStatuses = 1, soap_flag_remainingTotalRequestTime = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmPrepareToGetResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmPrepareToGetResponse, sizeof(struct srm2__srmPrepareToGetResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmPrepareToGetResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "returnStatus", &a->returnStatus, "srm2:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_arrayOfFileStatuses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTGetRequestFileStatus(soap, "arrayOfFileStatuses", &a->arrayOfFileStatuses, "srm2:ArrayOfTGetRequestFileStatus"))
				{	soap_flag_arrayOfFileStatuses--;
					continue;
				}
			if (soap_flag_remainingTotalRequestTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "remainingTotalRequestTime", &a->remainingTotalRequestTime, "xsd:int"))
				{	soap_flag_remainingTotalRequestTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmPrepareToGetResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmPrepareToGetResponse, 0, sizeof(struct srm2__srmPrepareToGetResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmPrepareToGetRequest(struct soap *soap, const struct srm2__srmPrepareToGetRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_PointerTosrm2__ArrayOfTGetFileRequest(soap, &a->arrayOfFileRequests);
	soap_serialize_string(soap, &a->userRequestDescription);
	soap_serialize_PointerTosrm2__ArrayOfTExtraInfo(soap, &a->storageSystemInfo);
	soap_serialize_PointerTosrm2__TFileStorageType(soap, &a->desiredFileStorageType);
	soap_serialize_PointerToint(soap, &a->desiredTotalRequestTime);
	soap_serialize_PointerToint(soap, &a->desiredPinLifeTime);
	soap_serialize_string(soap, &a->targetSpaceToken);
	soap_serialize_PointerTosrm2__TRetentionPolicyInfo(soap, &a->targetFileRetentionPolicyInfo);
	soap_serialize_PointerTosrm2__TTransferParameters(soap, &a->transferParameters);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmPrepareToGetRequest(struct soap *soap, struct srm2__srmPrepareToGetRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	a->arrayOfFileRequests = NULL;
	soap_default_string(soap, &a->userRequestDescription);
	a->storageSystemInfo = NULL;
	a->desiredFileStorageType = NULL;
	a->desiredTotalRequestTime = NULL;
	a->desiredPinLifeTime = NULL;
	soap_default_string(soap, &a->targetSpaceToken);
	a->targetFileRetentionPolicyInfo = NULL;
	a->transferParameters = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmPrepareToGetRequest(struct soap *soap, const struct srm2__srmPrepareToGetRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmPrepareToGetRequest);
	if (soap_out_srm2__srmPrepareToGetRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmPrepareToGetRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmPrepareToGetRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmPrepareToGetRequest), type);
	soap_out_string(soap, "authorizationID", -1, &a->authorizationID, "");
	soap_out_PointerTosrm2__ArrayOfTGetFileRequest(soap, "arrayOfFileRequests", -1, &a->arrayOfFileRequests, "");
	soap_out_string(soap, "userRequestDescription", -1, &a->userRequestDescription, "");
	soap_out_PointerTosrm2__ArrayOfTExtraInfo(soap, "storageSystemInfo", -1, &a->storageSystemInfo, "");
	soap_out_PointerTosrm2__TFileStorageType(soap, "desiredFileStorageType", -1, &a->desiredFileStorageType, "");
	soap_out_PointerToint(soap, "desiredTotalRequestTime", -1, &a->desiredTotalRequestTime, "");
	soap_out_PointerToint(soap, "desiredPinLifeTime", -1, &a->desiredPinLifeTime, "");
	soap_out_string(soap, "targetSpaceToken", -1, &a->targetSpaceToken, "");
	soap_out_PointerTosrm2__TRetentionPolicyInfo(soap, "targetFileRetentionPolicyInfo", -1, &a->targetFileRetentionPolicyInfo, "");
	soap_out_PointerTosrm2__TTransferParameters(soap, "transferParameters", -1, &a->transferParameters, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmPrepareToGetRequest * SOAP_FMAC4 soap_get_srm2__srmPrepareToGetRequest(struct soap *soap, struct srm2__srmPrepareToGetRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmPrepareToGetRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmPrepareToGetRequest * SOAP_FMAC4 soap_in_srm2__srmPrepareToGetRequest(struct soap *soap, const char *tag, struct srm2__srmPrepareToGetRequest *a, const char *type)
{
	short soap_flag_authorizationID = 1, soap_flag_arrayOfFileRequests = 1, soap_flag_userRequestDescription = 1, soap_flag_storageSystemInfo = 1, soap_flag_desiredFileStorageType = 1, soap_flag_desiredTotalRequestTime = 1, soap_flag_desiredPinLifeTime = 1, soap_flag_targetSpaceToken = 1, soap_flag_targetFileRetentionPolicyInfo = 1, soap_flag_transferParameters = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmPrepareToGetRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmPrepareToGetRequest, sizeof(struct srm2__srmPrepareToGetRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmPrepareToGetRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_arrayOfFileRequests && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTGetFileRequest(soap, "arrayOfFileRequests", &a->arrayOfFileRequests, "srm2:ArrayOfTGetFileRequest"))
				{	soap_flag_arrayOfFileRequests--;
					continue;
				}
			if (soap_flag_userRequestDescription && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRequestDescription", &a->userRequestDescription, "xsd:string"))
				{	soap_flag_userRequestDescription--;
					continue;
				}
			if (soap_flag_storageSystemInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTExtraInfo(soap, "storageSystemInfo", &a->storageSystemInfo, "srm2:ArrayOfTExtraInfo"))
				{	soap_flag_storageSystemInfo--;
					continue;
				}
			if (soap_flag_desiredFileStorageType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TFileStorageType(soap, "desiredFileStorageType", &a->desiredFileStorageType, "srm2:TFileStorageType"))
				{	soap_flag_desiredFileStorageType--;
					continue;
				}
			if (soap_flag_desiredTotalRequestTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "desiredTotalRequestTime", &a->desiredTotalRequestTime, "xsd:int"))
				{	soap_flag_desiredTotalRequestTime--;
					continue;
				}
			if (soap_flag_desiredPinLifeTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "desiredPinLifeTime", &a->desiredPinLifeTime, "xsd:int"))
				{	soap_flag_desiredPinLifeTime--;
					continue;
				}
			if (soap_flag_targetSpaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "targetSpaceToken", &a->targetSpaceToken, "xsd:string"))
				{	soap_flag_targetSpaceToken--;
					continue;
				}
			if (soap_flag_targetFileRetentionPolicyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TRetentionPolicyInfo(soap, "targetFileRetentionPolicyInfo", &a->targetFileRetentionPolicyInfo, "srm2:TRetentionPolicyInfo"))
				{	soap_flag_targetFileRetentionPolicyInfo--;
					continue;
				}
			if (soap_flag_transferParameters && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TTransferParameters(soap, "transferParameters", &a->transferParameters, "srm2:TTransferParameters"))
				{	soap_flag_transferParameters--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arrayOfFileRequests > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmPrepareToGetRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmPrepareToGetRequest, 0, sizeof(struct srm2__srmPrepareToGetRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmMvResponse(struct soap *soap, const struct srm2__srmMvResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->returnStatus);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmMvResponse(struct soap *soap, struct srm2__srmMvResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmMvResponse(struct soap *soap, const struct srm2__srmMvResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmMvResponse);
	if (soap_out_srm2__srmMvResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmMvResponse(struct soap *soap, const char *tag, int id, const struct srm2__srmMvResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmMvResponse), type);
	soap_out_PointerTosrm2__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmMvResponse * SOAP_FMAC4 soap_get_srm2__srmMvResponse(struct soap *soap, struct srm2__srmMvResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmMvResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmMvResponse * SOAP_FMAC4 soap_in_srm2__srmMvResponse(struct soap *soap, const char *tag, struct srm2__srmMvResponse *a, const char *type)
{
	short soap_flag_returnStatus = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmMvResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmMvResponse, sizeof(struct srm2__srmMvResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmMvResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "returnStatus", &a->returnStatus, "srm2:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmMvResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmMvResponse, 0, sizeof(struct srm2__srmMvResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmMvRequest(struct soap *soap, const struct srm2__srmMvRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_xsd__anyURI(soap, &a->fromSURL);
	soap_serialize_xsd__anyURI(soap, &a->toSURL);
	soap_serialize_PointerTosrm2__ArrayOfTExtraInfo(soap, &a->storageSystemInfo);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmMvRequest(struct soap *soap, struct srm2__srmMvRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	soap_default_xsd__anyURI(soap, &a->fromSURL);
	soap_default_xsd__anyURI(soap, &a->toSURL);
	a->storageSystemInfo = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmMvRequest(struct soap *soap, const struct srm2__srmMvRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmMvRequest);
	if (soap_out_srm2__srmMvRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmMvRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmMvRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmMvRequest), type);
	soap_out_string(soap, "authorizationID", -1, &a->authorizationID, "");
	soap_out_xsd__anyURI(soap, "fromSURL", -1, &a->fromSURL, "");
	soap_out_xsd__anyURI(soap, "toSURL", -1, &a->toSURL, "");
	soap_out_PointerTosrm2__ArrayOfTExtraInfo(soap, "storageSystemInfo", -1, &a->storageSystemInfo, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmMvRequest * SOAP_FMAC4 soap_get_srm2__srmMvRequest(struct soap *soap, struct srm2__srmMvRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmMvRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmMvRequest * SOAP_FMAC4 soap_in_srm2__srmMvRequest(struct soap *soap, const char *tag, struct srm2__srmMvRequest *a, const char *type)
{
	short soap_flag_authorizationID = 1, soap_flag_fromSURL = 1, soap_flag_toSURL = 1, soap_flag_storageSystemInfo = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmMvRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmMvRequest, sizeof(struct srm2__srmMvRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmMvRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_fromSURL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "fromSURL", &a->fromSURL, "xsd:anyURI"))
				{	soap_flag_fromSURL--;
					continue;
				}
			if (soap_flag_toSURL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "toSURL", &a->toSURL, "xsd:anyURI"))
				{	soap_flag_toSURL--;
					continue;
				}
			if (soap_flag_storageSystemInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTExtraInfo(soap, "storageSystemInfo", &a->storageSystemInfo, "srm2:ArrayOfTExtraInfo"))
				{	soap_flag_storageSystemInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fromSURL > 0 || soap_flag_toSURL > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmMvRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmMvRequest, 0, sizeof(struct srm2__srmMvRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmStatusOfLsRequestResponse(struct soap *soap, const struct srm2__srmStatusOfLsRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerTosrm2__ArrayOfTMetaDataPathDetail(soap, &a->details);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmStatusOfLsRequestResponse(struct soap *soap, struct srm2__srmStatusOfLsRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->details = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmStatusOfLsRequestResponse(struct soap *soap, const struct srm2__srmStatusOfLsRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmStatusOfLsRequestResponse);
	if (soap_out_srm2__srmStatusOfLsRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmStatusOfLsRequestResponse(struct soap *soap, const char *tag, int id, const struct srm2__srmStatusOfLsRequestResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmStatusOfLsRequestResponse), type);
	soap_out_PointerTosrm2__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, "");
	soap_out_PointerTosrm2__ArrayOfTMetaDataPathDetail(soap, "details", -1, &a->details, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmStatusOfLsRequestResponse * SOAP_FMAC4 soap_get_srm2__srmStatusOfLsRequestResponse(struct soap *soap, struct srm2__srmStatusOfLsRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmStatusOfLsRequestResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfLsRequestResponse * SOAP_FMAC4 soap_in_srm2__srmStatusOfLsRequestResponse(struct soap *soap, const char *tag, struct srm2__srmStatusOfLsRequestResponse *a, const char *type)
{
	short soap_flag_returnStatus = 1, soap_flag_details = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmStatusOfLsRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmStatusOfLsRequestResponse, sizeof(struct srm2__srmStatusOfLsRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmStatusOfLsRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "returnStatus", &a->returnStatus, "srm2:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_details && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTMetaDataPathDetail(soap, "details", &a->details, "srm2:ArrayOfTMetaDataPathDetail"))
				{	soap_flag_details--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfLsRequestResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfLsRequestResponse, 0, sizeof(struct srm2__srmStatusOfLsRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmStatusOfLsRequestRequest(struct soap *soap, const struct srm2__srmStatusOfLsRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_PointerToint(soap, &a->offset);
	soap_serialize_PointerToint(soap, &a->count);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmStatusOfLsRequestRequest(struct soap *soap, struct srm2__srmStatusOfLsRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	soap_default_string(soap, &a->requestToken);
	a->offset = NULL;
	a->count = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmStatusOfLsRequestRequest(struct soap *soap, const struct srm2__srmStatusOfLsRequestRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmStatusOfLsRequestRequest);
	if (soap_out_srm2__srmStatusOfLsRequestRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmStatusOfLsRequestRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmStatusOfLsRequestRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmStatusOfLsRequestRequest), type);
	soap_out_string(soap, "authorizationID", -1, &a->authorizationID, "");
	soap_out_string(soap, "requestToken", -1, &a->requestToken, "");
	soap_out_PointerToint(soap, "offset", -1, &a->offset, "");
	soap_out_PointerToint(soap, "count", -1, &a->count, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmStatusOfLsRequestRequest * SOAP_FMAC4 soap_get_srm2__srmStatusOfLsRequestRequest(struct soap *soap, struct srm2__srmStatusOfLsRequestRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmStatusOfLsRequestRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfLsRequestRequest * SOAP_FMAC4 soap_in_srm2__srmStatusOfLsRequestRequest(struct soap *soap, const char *tag, struct srm2__srmStatusOfLsRequestRequest *a, const char *type)
{
	short soap_flag_authorizationID = 1, soap_flag_requestToken = 1, soap_flag_offset = 1, soap_flag_count = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmStatusOfLsRequestRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmStatusOfLsRequestRequest, sizeof(struct srm2__srmStatusOfLsRequestRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmStatusOfLsRequestRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_offset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "offset", &a->offset, "xsd:int"))
				{	soap_flag_offset--;
					continue;
				}
			if (soap_flag_count && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "count", &a->count, "xsd:int"))
				{	soap_flag_count--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfLsRequestRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfLsRequestRequest, 0, sizeof(struct srm2__srmStatusOfLsRequestRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmLsResponse(struct soap *soap, const struct srm2__srmLsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_PointerTosrm2__ArrayOfTMetaDataPathDetail(soap, &a->details);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmLsResponse(struct soap *soap, struct srm2__srmLsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	soap_default_string(soap, &a->requestToken);
	a->details = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmLsResponse(struct soap *soap, const struct srm2__srmLsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmLsResponse);
	if (soap_out_srm2__srmLsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmLsResponse(struct soap *soap, const char *tag, int id, const struct srm2__srmLsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmLsResponse), type);
	soap_out_PointerTosrm2__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, "");
	soap_out_string(soap, "requestToken", -1, &a->requestToken, "");
	soap_out_PointerTosrm2__ArrayOfTMetaDataPathDetail(soap, "details", -1, &a->details, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmLsResponse * SOAP_FMAC4 soap_get_srm2__srmLsResponse(struct soap *soap, struct srm2__srmLsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmLsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmLsResponse * SOAP_FMAC4 soap_in_srm2__srmLsResponse(struct soap *soap, const char *tag, struct srm2__srmLsResponse *a, const char *type)
{
	short soap_flag_returnStatus = 1, soap_flag_requestToken = 1, soap_flag_details = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmLsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmLsResponse, sizeof(struct srm2__srmLsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmLsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "returnStatus", &a->returnStatus, "srm2:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_details && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTMetaDataPathDetail(soap, "details", &a->details, "srm2:ArrayOfTMetaDataPathDetail"))
				{	soap_flag_details--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmLsResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmLsResponse, 0, sizeof(struct srm2__srmLsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmLsRequest(struct soap *soap, const struct srm2__srmLsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_PointerTosrm2__ArrayOfAnyURI(soap, &a->arrayOfSURLs);
	soap_serialize_PointerTosrm2__ArrayOfTExtraInfo(soap, &a->storageSystemInfo);
	soap_serialize_PointerTosrm2__TFileStorageType(soap, &a->fileStorageType);
	soap_serialize_PointerToxsd__boolean(soap, &a->fullDetailedList);
	soap_serialize_PointerToxsd__boolean(soap, &a->allLevelRecursive);
	soap_serialize_PointerToint(soap, &a->numOfLevels);
	soap_serialize_PointerToint(soap, &a->offset);
	soap_serialize_PointerToint(soap, &a->count);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmLsRequest(struct soap *soap, struct srm2__srmLsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	a->arrayOfSURLs = NULL;
	a->storageSystemInfo = NULL;
	a->fileStorageType = NULL;
	a->fullDetailedList = NULL;
	a->allLevelRecursive = NULL;
	a->numOfLevels = NULL;
	a->offset = NULL;
	a->count = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmLsRequest(struct soap *soap, const struct srm2__srmLsRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmLsRequest);
	if (soap_out_srm2__srmLsRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmLsRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmLsRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmLsRequest), type);
	soap_out_string(soap, "authorizationID", -1, &a->authorizationID, "");
	soap_out_PointerTosrm2__ArrayOfAnyURI(soap, "arrayOfSURLs", -1, &a->arrayOfSURLs, "");
	soap_out_PointerTosrm2__ArrayOfTExtraInfo(soap, "storageSystemInfo", -1, &a->storageSystemInfo, "");
	soap_out_PointerTosrm2__TFileStorageType(soap, "fileStorageType", -1, &a->fileStorageType, "");
	soap_out_PointerToxsd__boolean(soap, "fullDetailedList", -1, &a->fullDetailedList, "");
	soap_out_PointerToxsd__boolean(soap, "allLevelRecursive", -1, &a->allLevelRecursive, "");
	soap_out_PointerToint(soap, "numOfLevels", -1, &a->numOfLevels, "");
	soap_out_PointerToint(soap, "offset", -1, &a->offset, "");
	soap_out_PointerToint(soap, "count", -1, &a->count, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmLsRequest * SOAP_FMAC4 soap_get_srm2__srmLsRequest(struct soap *soap, struct srm2__srmLsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmLsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmLsRequest * SOAP_FMAC4 soap_in_srm2__srmLsRequest(struct soap *soap, const char *tag, struct srm2__srmLsRequest *a, const char *type)
{
	short soap_flag_authorizationID = 1, soap_flag_arrayOfSURLs = 1, soap_flag_storageSystemInfo = 1, soap_flag_fileStorageType = 1, soap_flag_fullDetailedList = 1, soap_flag_allLevelRecursive = 1, soap_flag_numOfLevels = 1, soap_flag_offset = 1, soap_flag_count = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmLsRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmLsRequest, sizeof(struct srm2__srmLsRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmLsRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_arrayOfSURLs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfAnyURI(soap, "arrayOfSURLs", &a->arrayOfSURLs, "srm2:ArrayOfAnyURI"))
				{	soap_flag_arrayOfSURLs--;
					continue;
				}
			if (soap_flag_storageSystemInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTExtraInfo(soap, "storageSystemInfo", &a->storageSystemInfo, "srm2:ArrayOfTExtraInfo"))
				{	soap_flag_storageSystemInfo--;
					continue;
				}
			if (soap_flag_fileStorageType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TFileStorageType(soap, "fileStorageType", &a->fileStorageType, "srm2:TFileStorageType"))
				{	soap_flag_fileStorageType--;
					continue;
				}
			if (soap_flag_fullDetailedList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "fullDetailedList", &a->fullDetailedList, "xsd:boolean"))
				{	soap_flag_fullDetailedList--;
					continue;
				}
			if (soap_flag_allLevelRecursive && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "allLevelRecursive", &a->allLevelRecursive, "xsd:boolean"))
				{	soap_flag_allLevelRecursive--;
					continue;
				}
			if (soap_flag_numOfLevels && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "numOfLevels", &a->numOfLevels, "xsd:int"))
				{	soap_flag_numOfLevels--;
					continue;
				}
			if (soap_flag_offset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "offset", &a->offset, "xsd:int"))
				{	soap_flag_offset--;
					continue;
				}
			if (soap_flag_count && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "count", &a->count, "xsd:int"))
				{	soap_flag_count--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arrayOfSURLs > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmLsRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmLsRequest, 0, sizeof(struct srm2__srmLsRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmRmResponse(struct soap *soap, const struct srm2__srmRmResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerTosrm2__ArrayOfTSURLReturnStatus(soap, &a->arrayOfFileStatuses);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmRmResponse(struct soap *soap, struct srm2__srmRmResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->arrayOfFileStatuses = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmRmResponse(struct soap *soap, const struct srm2__srmRmResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmRmResponse);
	if (soap_out_srm2__srmRmResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmRmResponse(struct soap *soap, const char *tag, int id, const struct srm2__srmRmResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmRmResponse), type);
	soap_out_PointerTosrm2__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, "");
	soap_out_PointerTosrm2__ArrayOfTSURLReturnStatus(soap, "arrayOfFileStatuses", -1, &a->arrayOfFileStatuses, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmRmResponse * SOAP_FMAC4 soap_get_srm2__srmRmResponse(struct soap *soap, struct srm2__srmRmResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmRmResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmRmResponse * SOAP_FMAC4 soap_in_srm2__srmRmResponse(struct soap *soap, const char *tag, struct srm2__srmRmResponse *a, const char *type)
{
	short soap_flag_returnStatus = 1, soap_flag_arrayOfFileStatuses = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmRmResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmRmResponse, sizeof(struct srm2__srmRmResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmRmResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "returnStatus", &a->returnStatus, "srm2:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_arrayOfFileStatuses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTSURLReturnStatus(soap, "arrayOfFileStatuses", &a->arrayOfFileStatuses, "srm2:ArrayOfTSURLReturnStatus"))
				{	soap_flag_arrayOfFileStatuses--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmRmResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmRmResponse, 0, sizeof(struct srm2__srmRmResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmRmRequest(struct soap *soap, const struct srm2__srmRmRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_PointerTosrm2__ArrayOfAnyURI(soap, &a->arrayOfSURLs);
	soap_serialize_PointerTosrm2__ArrayOfTExtraInfo(soap, &a->storageSystemInfo);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmRmRequest(struct soap *soap, struct srm2__srmRmRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	a->arrayOfSURLs = NULL;
	a->storageSystemInfo = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmRmRequest(struct soap *soap, const struct srm2__srmRmRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmRmRequest);
	if (soap_out_srm2__srmRmRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmRmRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmRmRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmRmRequest), type);
	soap_out_string(soap, "authorizationID", -1, &a->authorizationID, "");
	soap_out_PointerTosrm2__ArrayOfAnyURI(soap, "arrayOfSURLs", -1, &a->arrayOfSURLs, "");
	soap_out_PointerTosrm2__ArrayOfTExtraInfo(soap, "storageSystemInfo", -1, &a->storageSystemInfo, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmRmRequest * SOAP_FMAC4 soap_get_srm2__srmRmRequest(struct soap *soap, struct srm2__srmRmRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmRmRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmRmRequest * SOAP_FMAC4 soap_in_srm2__srmRmRequest(struct soap *soap, const char *tag, struct srm2__srmRmRequest *a, const char *type)
{
	short soap_flag_authorizationID = 1, soap_flag_arrayOfSURLs = 1, soap_flag_storageSystemInfo = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmRmRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmRmRequest, sizeof(struct srm2__srmRmRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmRmRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_arrayOfSURLs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfAnyURI(soap, "arrayOfSURLs", &a->arrayOfSURLs, "srm2:ArrayOfAnyURI"))
				{	soap_flag_arrayOfSURLs--;
					continue;
				}
			if (soap_flag_storageSystemInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTExtraInfo(soap, "storageSystemInfo", &a->storageSystemInfo, "srm2:ArrayOfTExtraInfo"))
				{	soap_flag_storageSystemInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arrayOfSURLs > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmRmRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmRmRequest, 0, sizeof(struct srm2__srmRmRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmRmdirResponse(struct soap *soap, const struct srm2__srmRmdirResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->returnStatus);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmRmdirResponse(struct soap *soap, struct srm2__srmRmdirResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmRmdirResponse(struct soap *soap, const struct srm2__srmRmdirResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmRmdirResponse);
	if (soap_out_srm2__srmRmdirResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmRmdirResponse(struct soap *soap, const char *tag, int id, const struct srm2__srmRmdirResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmRmdirResponse), type);
	soap_out_PointerTosrm2__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmRmdirResponse * SOAP_FMAC4 soap_get_srm2__srmRmdirResponse(struct soap *soap, struct srm2__srmRmdirResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmRmdirResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmRmdirResponse * SOAP_FMAC4 soap_in_srm2__srmRmdirResponse(struct soap *soap, const char *tag, struct srm2__srmRmdirResponse *a, const char *type)
{
	short soap_flag_returnStatus = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmRmdirResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmRmdirResponse, sizeof(struct srm2__srmRmdirResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmRmdirResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "returnStatus", &a->returnStatus, "srm2:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmRmdirResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmRmdirResponse, 0, sizeof(struct srm2__srmRmdirResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmRmdirRequest(struct soap *soap, const struct srm2__srmRmdirRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_xsd__anyURI(soap, &a->SURL);
	soap_serialize_PointerTosrm2__ArrayOfTExtraInfo(soap, &a->storageSystemInfo);
	soap_serialize_PointerToxsd__boolean(soap, &a->recursive);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmRmdirRequest(struct soap *soap, struct srm2__srmRmdirRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	soap_default_xsd__anyURI(soap, &a->SURL);
	a->storageSystemInfo = NULL;
	a->recursive = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmRmdirRequest(struct soap *soap, const struct srm2__srmRmdirRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmRmdirRequest);
	if (soap_out_srm2__srmRmdirRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmRmdirRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmRmdirRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmRmdirRequest), type);
	soap_out_string(soap, "authorizationID", -1, &a->authorizationID, "");
	soap_out_xsd__anyURI(soap, "SURL", -1, &a->SURL, "");
	soap_out_PointerTosrm2__ArrayOfTExtraInfo(soap, "storageSystemInfo", -1, &a->storageSystemInfo, "");
	soap_out_PointerToxsd__boolean(soap, "recursive", -1, &a->recursive, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmRmdirRequest * SOAP_FMAC4 soap_get_srm2__srmRmdirRequest(struct soap *soap, struct srm2__srmRmdirRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmRmdirRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmRmdirRequest * SOAP_FMAC4 soap_in_srm2__srmRmdirRequest(struct soap *soap, const char *tag, struct srm2__srmRmdirRequest *a, const char *type)
{
	short soap_flag_authorizationID = 1, soap_flag_SURL = 1, soap_flag_storageSystemInfo = 1, soap_flag_recursive = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmRmdirRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmRmdirRequest, sizeof(struct srm2__srmRmdirRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmRmdirRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_SURL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "SURL", &a->SURL, "xsd:anyURI"))
				{	soap_flag_SURL--;
					continue;
				}
			if (soap_flag_storageSystemInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTExtraInfo(soap, "storageSystemInfo", &a->storageSystemInfo, "srm2:ArrayOfTExtraInfo"))
				{	soap_flag_storageSystemInfo--;
					continue;
				}
			if (soap_flag_recursive && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "recursive", &a->recursive, "xsd:boolean"))
				{	soap_flag_recursive--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SURL > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmRmdirRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmRmdirRequest, 0, sizeof(struct srm2__srmRmdirRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmMkdirResponse(struct soap *soap, const struct srm2__srmMkdirResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->returnStatus);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmMkdirResponse(struct soap *soap, struct srm2__srmMkdirResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmMkdirResponse(struct soap *soap, const struct srm2__srmMkdirResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmMkdirResponse);
	if (soap_out_srm2__srmMkdirResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmMkdirResponse(struct soap *soap, const char *tag, int id, const struct srm2__srmMkdirResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmMkdirResponse), type);
	soap_out_PointerTosrm2__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmMkdirResponse * SOAP_FMAC4 soap_get_srm2__srmMkdirResponse(struct soap *soap, struct srm2__srmMkdirResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmMkdirResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmMkdirResponse * SOAP_FMAC4 soap_in_srm2__srmMkdirResponse(struct soap *soap, const char *tag, struct srm2__srmMkdirResponse *a, const char *type)
{
	short soap_flag_returnStatus = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmMkdirResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmMkdirResponse, sizeof(struct srm2__srmMkdirResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmMkdirResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "returnStatus", &a->returnStatus, "srm2:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmMkdirResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmMkdirResponse, 0, sizeof(struct srm2__srmMkdirResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmMkdirRequest(struct soap *soap, const struct srm2__srmMkdirRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_xsd__anyURI(soap, &a->SURL);
	soap_serialize_PointerTosrm2__ArrayOfTExtraInfo(soap, &a->storageSystemInfo);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmMkdirRequest(struct soap *soap, struct srm2__srmMkdirRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	soap_default_xsd__anyURI(soap, &a->SURL);
	a->storageSystemInfo = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmMkdirRequest(struct soap *soap, const struct srm2__srmMkdirRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmMkdirRequest);
	if (soap_out_srm2__srmMkdirRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmMkdirRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmMkdirRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmMkdirRequest), type);
	soap_out_string(soap, "authorizationID", -1, &a->authorizationID, "");
	soap_out_xsd__anyURI(soap, "SURL", -1, &a->SURL, "");
	soap_out_PointerTosrm2__ArrayOfTExtraInfo(soap, "storageSystemInfo", -1, &a->storageSystemInfo, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmMkdirRequest * SOAP_FMAC4 soap_get_srm2__srmMkdirRequest(struct soap *soap, struct srm2__srmMkdirRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmMkdirRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmMkdirRequest * SOAP_FMAC4 soap_in_srm2__srmMkdirRequest(struct soap *soap, const char *tag, struct srm2__srmMkdirRequest *a, const char *type)
{
	short soap_flag_authorizationID = 1, soap_flag_SURL = 1, soap_flag_storageSystemInfo = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmMkdirRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmMkdirRequest, sizeof(struct srm2__srmMkdirRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmMkdirRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_SURL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "SURL", &a->SURL, "xsd:anyURI"))
				{	soap_flag_SURL--;
					continue;
				}
			if (soap_flag_storageSystemInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTExtraInfo(soap, "storageSystemInfo", &a->storageSystemInfo, "srm2:ArrayOfTExtraInfo"))
				{	soap_flag_storageSystemInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SURL > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmMkdirRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmMkdirRequest, 0, sizeof(struct srm2__srmMkdirRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmGetPermissionResponse(struct soap *soap, const struct srm2__srmGetPermissionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerTosrm2__ArrayOfTPermissionReturn(soap, &a->arrayOfPermissionReturns);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmGetPermissionResponse(struct soap *soap, struct srm2__srmGetPermissionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->arrayOfPermissionReturns = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmGetPermissionResponse(struct soap *soap, const struct srm2__srmGetPermissionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmGetPermissionResponse);
	if (soap_out_srm2__srmGetPermissionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmGetPermissionResponse(struct soap *soap, const char *tag, int id, const struct srm2__srmGetPermissionResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmGetPermissionResponse), type);
	soap_out_PointerTosrm2__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, "");
	soap_out_PointerTosrm2__ArrayOfTPermissionReturn(soap, "arrayOfPermissionReturns", -1, &a->arrayOfPermissionReturns, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmGetPermissionResponse * SOAP_FMAC4 soap_get_srm2__srmGetPermissionResponse(struct soap *soap, struct srm2__srmGetPermissionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmGetPermissionResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetPermissionResponse * SOAP_FMAC4 soap_in_srm2__srmGetPermissionResponse(struct soap *soap, const char *tag, struct srm2__srmGetPermissionResponse *a, const char *type)
{
	short soap_flag_returnStatus = 1, soap_flag_arrayOfPermissionReturns = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmGetPermissionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmGetPermissionResponse, sizeof(struct srm2__srmGetPermissionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmGetPermissionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "returnStatus", &a->returnStatus, "srm2:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_arrayOfPermissionReturns && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTPermissionReturn(soap, "arrayOfPermissionReturns", &a->arrayOfPermissionReturns, "srm2:ArrayOfTPermissionReturn"))
				{	soap_flag_arrayOfPermissionReturns--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetPermissionResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetPermissionResponse, 0, sizeof(struct srm2__srmGetPermissionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmGetPermissionRequest(struct soap *soap, const struct srm2__srmGetPermissionRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_PointerTosrm2__ArrayOfAnyURI(soap, &a->arrayOfSURLs);
	soap_serialize_PointerTosrm2__ArrayOfTExtraInfo(soap, &a->storageSystemInfo);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmGetPermissionRequest(struct soap *soap, struct srm2__srmGetPermissionRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	a->arrayOfSURLs = NULL;
	a->storageSystemInfo = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmGetPermissionRequest(struct soap *soap, const struct srm2__srmGetPermissionRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmGetPermissionRequest);
	if (soap_out_srm2__srmGetPermissionRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmGetPermissionRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmGetPermissionRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmGetPermissionRequest), type);
	soap_out_string(soap, "authorizationID", -1, &a->authorizationID, "");
	soap_out_PointerTosrm2__ArrayOfAnyURI(soap, "arrayOfSURLs", -1, &a->arrayOfSURLs, "");
	soap_out_PointerTosrm2__ArrayOfTExtraInfo(soap, "storageSystemInfo", -1, &a->storageSystemInfo, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmGetPermissionRequest * SOAP_FMAC4 soap_get_srm2__srmGetPermissionRequest(struct soap *soap, struct srm2__srmGetPermissionRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmGetPermissionRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetPermissionRequest * SOAP_FMAC4 soap_in_srm2__srmGetPermissionRequest(struct soap *soap, const char *tag, struct srm2__srmGetPermissionRequest *a, const char *type)
{
	short soap_flag_authorizationID = 1, soap_flag_arrayOfSURLs = 1, soap_flag_storageSystemInfo = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmGetPermissionRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmGetPermissionRequest, sizeof(struct srm2__srmGetPermissionRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmGetPermissionRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_arrayOfSURLs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfAnyURI(soap, "arrayOfSURLs", &a->arrayOfSURLs, "srm2:ArrayOfAnyURI"))
				{	soap_flag_arrayOfSURLs--;
					continue;
				}
			if (soap_flag_storageSystemInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTExtraInfo(soap, "storageSystemInfo", &a->storageSystemInfo, "srm2:ArrayOfTExtraInfo"))
				{	soap_flag_storageSystemInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arrayOfSURLs > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetPermissionRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetPermissionRequest, 0, sizeof(struct srm2__srmGetPermissionRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmCheckPermissionResponse(struct soap *soap, const struct srm2__srmCheckPermissionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerTosrm2__ArrayOfTSURLPermissionReturn(soap, &a->arrayOfPermissions);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmCheckPermissionResponse(struct soap *soap, struct srm2__srmCheckPermissionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->arrayOfPermissions = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmCheckPermissionResponse(struct soap *soap, const struct srm2__srmCheckPermissionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmCheckPermissionResponse);
	if (soap_out_srm2__srmCheckPermissionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmCheckPermissionResponse(struct soap *soap, const char *tag, int id, const struct srm2__srmCheckPermissionResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmCheckPermissionResponse), type);
	soap_out_PointerTosrm2__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, "");
	soap_out_PointerTosrm2__ArrayOfTSURLPermissionReturn(soap, "arrayOfPermissions", -1, &a->arrayOfPermissions, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmCheckPermissionResponse * SOAP_FMAC4 soap_get_srm2__srmCheckPermissionResponse(struct soap *soap, struct srm2__srmCheckPermissionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmCheckPermissionResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmCheckPermissionResponse * SOAP_FMAC4 soap_in_srm2__srmCheckPermissionResponse(struct soap *soap, const char *tag, struct srm2__srmCheckPermissionResponse *a, const char *type)
{
	short soap_flag_returnStatus = 1, soap_flag_arrayOfPermissions = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmCheckPermissionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmCheckPermissionResponse, sizeof(struct srm2__srmCheckPermissionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmCheckPermissionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "returnStatus", &a->returnStatus, "srm2:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_arrayOfPermissions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTSURLPermissionReturn(soap, "arrayOfPermissions", &a->arrayOfPermissions, "srm2:ArrayOfTSURLPermissionReturn"))
				{	soap_flag_arrayOfPermissions--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmCheckPermissionResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmCheckPermissionResponse, 0, sizeof(struct srm2__srmCheckPermissionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmCheckPermissionRequest(struct soap *soap, const struct srm2__srmCheckPermissionRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__ArrayOfAnyURI(soap, &a->arrayOfSURLs);
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_PointerTosrm2__ArrayOfTExtraInfo(soap, &a->storageSystemInfo);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmCheckPermissionRequest(struct soap *soap, struct srm2__srmCheckPermissionRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->arrayOfSURLs = NULL;
	soap_default_string(soap, &a->authorizationID);
	a->storageSystemInfo = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmCheckPermissionRequest(struct soap *soap, const struct srm2__srmCheckPermissionRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmCheckPermissionRequest);
	if (soap_out_srm2__srmCheckPermissionRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmCheckPermissionRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmCheckPermissionRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmCheckPermissionRequest), type);
	soap_out_PointerTosrm2__ArrayOfAnyURI(soap, "arrayOfSURLs", -1, &a->arrayOfSURLs, "");
	soap_out_string(soap, "authorizationID", -1, &a->authorizationID, "");
	soap_out_PointerTosrm2__ArrayOfTExtraInfo(soap, "storageSystemInfo", -1, &a->storageSystemInfo, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmCheckPermissionRequest * SOAP_FMAC4 soap_get_srm2__srmCheckPermissionRequest(struct soap *soap, struct srm2__srmCheckPermissionRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmCheckPermissionRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmCheckPermissionRequest * SOAP_FMAC4 soap_in_srm2__srmCheckPermissionRequest(struct soap *soap, const char *tag, struct srm2__srmCheckPermissionRequest *a, const char *type)
{
	short soap_flag_arrayOfSURLs = 1, soap_flag_authorizationID = 1, soap_flag_storageSystemInfo = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmCheckPermissionRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmCheckPermissionRequest, sizeof(struct srm2__srmCheckPermissionRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmCheckPermissionRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arrayOfSURLs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfAnyURI(soap, "arrayOfSURLs", &a->arrayOfSURLs, "srm2:ArrayOfAnyURI"))
				{	soap_flag_arrayOfSURLs--;
					continue;
				}
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_storageSystemInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTExtraInfo(soap, "storageSystemInfo", &a->storageSystemInfo, "srm2:ArrayOfTExtraInfo"))
				{	soap_flag_storageSystemInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arrayOfSURLs > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmCheckPermissionRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmCheckPermissionRequest, 0, sizeof(struct srm2__srmCheckPermissionRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmSetPermissionResponse(struct soap *soap, const struct srm2__srmSetPermissionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->returnStatus);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmSetPermissionResponse(struct soap *soap, struct srm2__srmSetPermissionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmSetPermissionResponse(struct soap *soap, const struct srm2__srmSetPermissionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmSetPermissionResponse);
	if (soap_out_srm2__srmSetPermissionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmSetPermissionResponse(struct soap *soap, const char *tag, int id, const struct srm2__srmSetPermissionResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmSetPermissionResponse), type);
	soap_out_PointerTosrm2__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmSetPermissionResponse * SOAP_FMAC4 soap_get_srm2__srmSetPermissionResponse(struct soap *soap, struct srm2__srmSetPermissionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmSetPermissionResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmSetPermissionResponse * SOAP_FMAC4 soap_in_srm2__srmSetPermissionResponse(struct soap *soap, const char *tag, struct srm2__srmSetPermissionResponse *a, const char *type)
{
	short soap_flag_returnStatus = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmSetPermissionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmSetPermissionResponse, sizeof(struct srm2__srmSetPermissionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmSetPermissionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "returnStatus", &a->returnStatus, "srm2:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmSetPermissionResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmSetPermissionResponse, 0, sizeof(struct srm2__srmSetPermissionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmSetPermissionRequest(struct soap *soap, const struct srm2__srmSetPermissionRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_xsd__anyURI(soap, &a->SURL);
	soap_serialize_PointerTosrm2__TPermissionMode(soap, &a->ownerPermission);
	soap_serialize_PointerTosrm2__ArrayOfTUserPermission(soap, &a->arrayOfUserPermissions);
	soap_serialize_PointerTosrm2__ArrayOfTGroupPermission(soap, &a->arrayOfGroupPermissions);
	soap_serialize_PointerTosrm2__TPermissionMode(soap, &a->otherPermission);
	soap_serialize_PointerTosrm2__ArrayOfTExtraInfo(soap, &a->storageSystemInfo);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmSetPermissionRequest(struct soap *soap, struct srm2__srmSetPermissionRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	soap_default_xsd__anyURI(soap, &a->SURL);
	soap_default_srm2__TPermissionType(soap, &a->permissionType);
	a->ownerPermission = NULL;
	a->arrayOfUserPermissions = NULL;
	a->arrayOfGroupPermissions = NULL;
	a->otherPermission = NULL;
	a->storageSystemInfo = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmSetPermissionRequest(struct soap *soap, const struct srm2__srmSetPermissionRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmSetPermissionRequest);
	if (soap_out_srm2__srmSetPermissionRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmSetPermissionRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmSetPermissionRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmSetPermissionRequest), type);
	soap_out_string(soap, "authorizationID", -1, &a->authorizationID, "");
	soap_out_xsd__anyURI(soap, "SURL", -1, &a->SURL, "");
	soap_out_srm2__TPermissionType(soap, "permissionType", -1, &a->permissionType, "");
	soap_out_PointerTosrm2__TPermissionMode(soap, "ownerPermission", -1, &a->ownerPermission, "");
	soap_out_PointerTosrm2__ArrayOfTUserPermission(soap, "arrayOfUserPermissions", -1, &a->arrayOfUserPermissions, "");
	soap_out_PointerTosrm2__ArrayOfTGroupPermission(soap, "arrayOfGroupPermissions", -1, &a->arrayOfGroupPermissions, "");
	soap_out_PointerTosrm2__TPermissionMode(soap, "otherPermission", -1, &a->otherPermission, "");
	soap_out_PointerTosrm2__ArrayOfTExtraInfo(soap, "storageSystemInfo", -1, &a->storageSystemInfo, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmSetPermissionRequest * SOAP_FMAC4 soap_get_srm2__srmSetPermissionRequest(struct soap *soap, struct srm2__srmSetPermissionRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmSetPermissionRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmSetPermissionRequest * SOAP_FMAC4 soap_in_srm2__srmSetPermissionRequest(struct soap *soap, const char *tag, struct srm2__srmSetPermissionRequest *a, const char *type)
{
	short soap_flag_authorizationID = 1, soap_flag_SURL = 1, soap_flag_permissionType = 1, soap_flag_ownerPermission = 1, soap_flag_arrayOfUserPermissions = 1, soap_flag_arrayOfGroupPermissions = 1, soap_flag_otherPermission = 1, soap_flag_storageSystemInfo = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmSetPermissionRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmSetPermissionRequest, sizeof(struct srm2__srmSetPermissionRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmSetPermissionRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_SURL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "SURL", &a->SURL, "xsd:anyURI"))
				{	soap_flag_SURL--;
					continue;
				}
			if (soap_flag_permissionType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_srm2__TPermissionType(soap, "permissionType", &a->permissionType, "srm2:TPermissionType"))
				{	soap_flag_permissionType--;
					continue;
				}
			if (soap_flag_ownerPermission && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TPermissionMode(soap, "ownerPermission", &a->ownerPermission, "srm2:TPermissionMode"))
				{	soap_flag_ownerPermission--;
					continue;
				}
			if (soap_flag_arrayOfUserPermissions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTUserPermission(soap, "arrayOfUserPermissions", &a->arrayOfUserPermissions, "srm2:ArrayOfTUserPermission"))
				{	soap_flag_arrayOfUserPermissions--;
					continue;
				}
			if (soap_flag_arrayOfGroupPermissions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTGroupPermission(soap, "arrayOfGroupPermissions", &a->arrayOfGroupPermissions, "srm2:ArrayOfTGroupPermission"))
				{	soap_flag_arrayOfGroupPermissions--;
					continue;
				}
			if (soap_flag_otherPermission && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TPermissionMode(soap, "otherPermission", &a->otherPermission, "srm2:TPermissionMode"))
				{	soap_flag_otherPermission--;
					continue;
				}
			if (soap_flag_storageSystemInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTExtraInfo(soap, "storageSystemInfo", &a->storageSystemInfo, "srm2:ArrayOfTExtraInfo"))
				{	soap_flag_storageSystemInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SURL > 0 || soap_flag_permissionType > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmSetPermissionRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmSetPermissionRequest, 0, sizeof(struct srm2__srmSetPermissionRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmGetSpaceTokensResponse(struct soap *soap, const struct srm2__srmGetSpaceTokensResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerTosrm2__ArrayOfString(soap, &a->arrayOfSpaceTokens);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmGetSpaceTokensResponse(struct soap *soap, struct srm2__srmGetSpaceTokensResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->arrayOfSpaceTokens = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmGetSpaceTokensResponse(struct soap *soap, const struct srm2__srmGetSpaceTokensResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmGetSpaceTokensResponse);
	if (soap_out_srm2__srmGetSpaceTokensResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmGetSpaceTokensResponse(struct soap *soap, const char *tag, int id, const struct srm2__srmGetSpaceTokensResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmGetSpaceTokensResponse), type);
	soap_out_PointerTosrm2__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, "");
	soap_out_PointerTosrm2__ArrayOfString(soap, "arrayOfSpaceTokens", -1, &a->arrayOfSpaceTokens, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmGetSpaceTokensResponse * SOAP_FMAC4 soap_get_srm2__srmGetSpaceTokensResponse(struct soap *soap, struct srm2__srmGetSpaceTokensResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmGetSpaceTokensResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetSpaceTokensResponse * SOAP_FMAC4 soap_in_srm2__srmGetSpaceTokensResponse(struct soap *soap, const char *tag, struct srm2__srmGetSpaceTokensResponse *a, const char *type)
{
	short soap_flag_returnStatus = 1, soap_flag_arrayOfSpaceTokens = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmGetSpaceTokensResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmGetSpaceTokensResponse, sizeof(struct srm2__srmGetSpaceTokensResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmGetSpaceTokensResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "returnStatus", &a->returnStatus, "srm2:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_arrayOfSpaceTokens && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfString(soap, "arrayOfSpaceTokens", &a->arrayOfSpaceTokens, "srm2:ArrayOfString"))
				{	soap_flag_arrayOfSpaceTokens--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetSpaceTokensResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetSpaceTokensResponse, 0, sizeof(struct srm2__srmGetSpaceTokensResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmGetSpaceTokensRequest(struct soap *soap, const struct srm2__srmGetSpaceTokensRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->userSpaceTokenDescription);
	soap_serialize_string(soap, &a->authorizationID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmGetSpaceTokensRequest(struct soap *soap, struct srm2__srmGetSpaceTokensRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->userSpaceTokenDescription);
	soap_default_string(soap, &a->authorizationID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmGetSpaceTokensRequest(struct soap *soap, const struct srm2__srmGetSpaceTokensRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmGetSpaceTokensRequest);
	if (soap_out_srm2__srmGetSpaceTokensRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmGetSpaceTokensRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmGetSpaceTokensRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmGetSpaceTokensRequest), type);
	soap_out_string(soap, "userSpaceTokenDescription", -1, &a->userSpaceTokenDescription, "");
	soap_out_string(soap, "authorizationID", -1, &a->authorizationID, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmGetSpaceTokensRequest * SOAP_FMAC4 soap_get_srm2__srmGetSpaceTokensRequest(struct soap *soap, struct srm2__srmGetSpaceTokensRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmGetSpaceTokensRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetSpaceTokensRequest * SOAP_FMAC4 soap_in_srm2__srmGetSpaceTokensRequest(struct soap *soap, const char *tag, struct srm2__srmGetSpaceTokensRequest *a, const char *type)
{
	short soap_flag_userSpaceTokenDescription = 1, soap_flag_authorizationID = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmGetSpaceTokensRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmGetSpaceTokensRequest, sizeof(struct srm2__srmGetSpaceTokensRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmGetSpaceTokensRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userSpaceTokenDescription && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userSpaceTokenDescription", &a->userSpaceTokenDescription, "xsd:string"))
				{	soap_flag_userSpaceTokenDescription--;
					continue;
				}
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetSpaceTokensRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetSpaceTokensRequest, 0, sizeof(struct srm2__srmGetSpaceTokensRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmPurgeFromSpaceResponse(struct soap *soap, const struct srm2__srmPurgeFromSpaceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerTosrm2__ArrayOfTSURLReturnStatus(soap, &a->arrayOfFileStatuses);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmPurgeFromSpaceResponse(struct soap *soap, struct srm2__srmPurgeFromSpaceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->arrayOfFileStatuses = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmPurgeFromSpaceResponse(struct soap *soap, const struct srm2__srmPurgeFromSpaceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmPurgeFromSpaceResponse);
	if (soap_out_srm2__srmPurgeFromSpaceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmPurgeFromSpaceResponse(struct soap *soap, const char *tag, int id, const struct srm2__srmPurgeFromSpaceResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmPurgeFromSpaceResponse), type);
	soap_out_PointerTosrm2__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, "");
	soap_out_PointerTosrm2__ArrayOfTSURLReturnStatus(soap, "arrayOfFileStatuses", -1, &a->arrayOfFileStatuses, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmPurgeFromSpaceResponse * SOAP_FMAC4 soap_get_srm2__srmPurgeFromSpaceResponse(struct soap *soap, struct srm2__srmPurgeFromSpaceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmPurgeFromSpaceResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmPurgeFromSpaceResponse * SOAP_FMAC4 soap_in_srm2__srmPurgeFromSpaceResponse(struct soap *soap, const char *tag, struct srm2__srmPurgeFromSpaceResponse *a, const char *type)
{
	short soap_flag_returnStatus = 1, soap_flag_arrayOfFileStatuses = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmPurgeFromSpaceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmPurgeFromSpaceResponse, sizeof(struct srm2__srmPurgeFromSpaceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmPurgeFromSpaceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "returnStatus", &a->returnStatus, "srm2:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_arrayOfFileStatuses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTSURLReturnStatus(soap, "arrayOfFileStatuses", &a->arrayOfFileStatuses, "srm2:ArrayOfTSURLReturnStatus"))
				{	soap_flag_arrayOfFileStatuses--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmPurgeFromSpaceResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmPurgeFromSpaceResponse, 0, sizeof(struct srm2__srmPurgeFromSpaceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmPurgeFromSpaceRequest(struct soap *soap, const struct srm2__srmPurgeFromSpaceRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_PointerTosrm2__ArrayOfAnyURI(soap, &a->arrayOfSURLs);
	soap_serialize_string(soap, &a->spaceToken);
	soap_serialize_PointerTosrm2__ArrayOfTExtraInfo(soap, &a->storageSystemInfo);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmPurgeFromSpaceRequest(struct soap *soap, struct srm2__srmPurgeFromSpaceRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	a->arrayOfSURLs = NULL;
	soap_default_string(soap, &a->spaceToken);
	a->storageSystemInfo = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmPurgeFromSpaceRequest(struct soap *soap, const struct srm2__srmPurgeFromSpaceRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmPurgeFromSpaceRequest);
	if (soap_out_srm2__srmPurgeFromSpaceRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmPurgeFromSpaceRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmPurgeFromSpaceRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmPurgeFromSpaceRequest), type);
	soap_out_string(soap, "authorizationID", -1, &a->authorizationID, "");
	soap_out_PointerTosrm2__ArrayOfAnyURI(soap, "arrayOfSURLs", -1, &a->arrayOfSURLs, "");
	soap_out_string(soap, "spaceToken", -1, &a->spaceToken, "");
	soap_out_PointerTosrm2__ArrayOfTExtraInfo(soap, "storageSystemInfo", -1, &a->storageSystemInfo, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmPurgeFromSpaceRequest * SOAP_FMAC4 soap_get_srm2__srmPurgeFromSpaceRequest(struct soap *soap, struct srm2__srmPurgeFromSpaceRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmPurgeFromSpaceRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmPurgeFromSpaceRequest * SOAP_FMAC4 soap_in_srm2__srmPurgeFromSpaceRequest(struct soap *soap, const char *tag, struct srm2__srmPurgeFromSpaceRequest *a, const char *type)
{
	short soap_flag_authorizationID = 1, soap_flag_arrayOfSURLs = 1, soap_flag_spaceToken = 1, soap_flag_storageSystemInfo = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmPurgeFromSpaceRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmPurgeFromSpaceRequest, sizeof(struct srm2__srmPurgeFromSpaceRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmPurgeFromSpaceRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_arrayOfSURLs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfAnyURI(soap, "arrayOfSURLs", &a->arrayOfSURLs, "srm2:ArrayOfAnyURI"))
				{	soap_flag_arrayOfSURLs--;
					continue;
				}
			if (soap_flag_spaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "spaceToken", &a->spaceToken, "xsd:string"))
				{	soap_flag_spaceToken--;
					continue;
				}
			if (soap_flag_storageSystemInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTExtraInfo(soap, "storageSystemInfo", &a->storageSystemInfo, "srm2:ArrayOfTExtraInfo"))
				{	soap_flag_storageSystemInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arrayOfSURLs > 0 || soap_flag_spaceToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmPurgeFromSpaceRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmPurgeFromSpaceRequest, 0, sizeof(struct srm2__srmPurgeFromSpaceRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmExtendFileLifeTimeInSpaceResponse(struct soap *soap, const struct srm2__srmExtendFileLifeTimeInSpaceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerTosrm2__ArrayOfTSURLLifetimeReturnStatus(soap, &a->arrayOfFileStatuses);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmExtendFileLifeTimeInSpaceResponse(struct soap *soap, struct srm2__srmExtendFileLifeTimeInSpaceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->arrayOfFileStatuses = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmExtendFileLifeTimeInSpaceResponse(struct soap *soap, const struct srm2__srmExtendFileLifeTimeInSpaceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpaceResponse);
	if (soap_out_srm2__srmExtendFileLifeTimeInSpaceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmExtendFileLifeTimeInSpaceResponse(struct soap *soap, const char *tag, int id, const struct srm2__srmExtendFileLifeTimeInSpaceResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpaceResponse), type);
	soap_out_PointerTosrm2__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, "");
	soap_out_PointerTosrm2__ArrayOfTSURLLifetimeReturnStatus(soap, "arrayOfFileStatuses", -1, &a->arrayOfFileStatuses, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmExtendFileLifeTimeInSpaceResponse * SOAP_FMAC4 soap_get_srm2__srmExtendFileLifeTimeInSpaceResponse(struct soap *soap, struct srm2__srmExtendFileLifeTimeInSpaceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmExtendFileLifeTimeInSpaceResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmExtendFileLifeTimeInSpaceResponse * SOAP_FMAC4 soap_in_srm2__srmExtendFileLifeTimeInSpaceResponse(struct soap *soap, const char *tag, struct srm2__srmExtendFileLifeTimeInSpaceResponse *a, const char *type)
{
	short soap_flag_returnStatus = 1, soap_flag_arrayOfFileStatuses = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmExtendFileLifeTimeInSpaceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpaceResponse, sizeof(struct srm2__srmExtendFileLifeTimeInSpaceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmExtendFileLifeTimeInSpaceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "returnStatus", &a->returnStatus, "srm2:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_arrayOfFileStatuses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTSURLLifetimeReturnStatus(soap, "arrayOfFileStatuses", &a->arrayOfFileStatuses, "srm2:ArrayOfTSURLLifetimeReturnStatus"))
				{	soap_flag_arrayOfFileStatuses--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmExtendFileLifeTimeInSpaceResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpaceResponse, 0, sizeof(struct srm2__srmExtendFileLifeTimeInSpaceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmExtendFileLifeTimeInSpaceRequest(struct soap *soap, const struct srm2__srmExtendFileLifeTimeInSpaceRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_string(soap, &a->spaceToken);
	soap_serialize_PointerTosrm2__ArrayOfAnyURI(soap, &a->arrayOfSURLs);
	soap_serialize_PointerToint(soap, &a->newLifeTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmExtendFileLifeTimeInSpaceRequest(struct soap *soap, struct srm2__srmExtendFileLifeTimeInSpaceRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	soap_default_string(soap, &a->spaceToken);
	a->arrayOfSURLs = NULL;
	a->newLifeTime = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmExtendFileLifeTimeInSpaceRequest(struct soap *soap, const struct srm2__srmExtendFileLifeTimeInSpaceRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpaceRequest);
	if (soap_out_srm2__srmExtendFileLifeTimeInSpaceRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmExtendFileLifeTimeInSpaceRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmExtendFileLifeTimeInSpaceRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpaceRequest), type);
	soap_out_string(soap, "authorizationID", -1, &a->authorizationID, "");
	soap_out_string(soap, "spaceToken", -1, &a->spaceToken, "");
	soap_out_PointerTosrm2__ArrayOfAnyURI(soap, "arrayOfSURLs", -1, &a->arrayOfSURLs, "");
	soap_out_PointerToint(soap, "newLifeTime", -1, &a->newLifeTime, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmExtendFileLifeTimeInSpaceRequest * SOAP_FMAC4 soap_get_srm2__srmExtendFileLifeTimeInSpaceRequest(struct soap *soap, struct srm2__srmExtendFileLifeTimeInSpaceRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmExtendFileLifeTimeInSpaceRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmExtendFileLifeTimeInSpaceRequest * SOAP_FMAC4 soap_in_srm2__srmExtendFileLifeTimeInSpaceRequest(struct soap *soap, const char *tag, struct srm2__srmExtendFileLifeTimeInSpaceRequest *a, const char *type)
{
	short soap_flag_authorizationID = 1, soap_flag_spaceToken = 1, soap_flag_arrayOfSURLs = 1, soap_flag_newLifeTime = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmExtendFileLifeTimeInSpaceRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpaceRequest, sizeof(struct srm2__srmExtendFileLifeTimeInSpaceRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmExtendFileLifeTimeInSpaceRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_spaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "spaceToken", &a->spaceToken, "xsd:string"))
				{	soap_flag_spaceToken--;
					continue;
				}
			if (soap_flag_arrayOfSURLs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfAnyURI(soap, "arrayOfSURLs", &a->arrayOfSURLs, "srm2:ArrayOfAnyURI"))
				{	soap_flag_arrayOfSURLs--;
					continue;
				}
			if (soap_flag_newLifeTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "newLifeTime", &a->newLifeTime, "xsd:int"))
				{	soap_flag_newLifeTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_spaceToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmExtendFileLifeTimeInSpaceRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpaceRequest, 0, sizeof(struct srm2__srmExtendFileLifeTimeInSpaceRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmStatusOfChangeSpaceForFilesRequestResponse(struct soap *soap, const struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerToint(soap, &a->estimatedProcessingTime);
	soap_serialize_PointerTosrm2__ArrayOfTSURLReturnStatus(soap, &a->arrayOfFileStatuses);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmStatusOfChangeSpaceForFilesRequestResponse(struct soap *soap, struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->estimatedProcessingTime = NULL;
	a->arrayOfFileStatuses = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmStatusOfChangeSpaceForFilesRequestResponse(struct soap *soap, const struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequestResponse);
	if (soap_out_srm2__srmStatusOfChangeSpaceForFilesRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmStatusOfChangeSpaceForFilesRequestResponse(struct soap *soap, const char *tag, int id, const struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequestResponse), type);
	soap_out_PointerTosrm2__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, "");
	soap_out_PointerToint(soap, "estimatedProcessingTime", -1, &a->estimatedProcessingTime, "");
	soap_out_PointerTosrm2__ArrayOfTSURLReturnStatus(soap, "arrayOfFileStatuses", -1, &a->arrayOfFileStatuses, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse * SOAP_FMAC4 soap_get_srm2__srmStatusOfChangeSpaceForFilesRequestResponse(struct soap *soap, struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmStatusOfChangeSpaceForFilesRequestResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse * SOAP_FMAC4 soap_in_srm2__srmStatusOfChangeSpaceForFilesRequestResponse(struct soap *soap, const char *tag, struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse *a, const char *type)
{
	short soap_flag_returnStatus = 1, soap_flag_estimatedProcessingTime = 1, soap_flag_arrayOfFileStatuses = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequestResponse, sizeof(struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmStatusOfChangeSpaceForFilesRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "returnStatus", &a->returnStatus, "srm2:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_estimatedProcessingTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "estimatedProcessingTime", &a->estimatedProcessingTime, "xsd:int"))
				{	soap_flag_estimatedProcessingTime--;
					continue;
				}
			if (soap_flag_arrayOfFileStatuses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTSURLReturnStatus(soap, "arrayOfFileStatuses", &a->arrayOfFileStatuses, "srm2:ArrayOfTSURLReturnStatus"))
				{	soap_flag_arrayOfFileStatuses--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequestResponse, 0, sizeof(struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmStatusOfChangeSpaceForFilesRequestRequest(struct soap *soap, const struct srm2__srmStatusOfChangeSpaceForFilesRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_string(soap, &a->requestToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmStatusOfChangeSpaceForFilesRequestRequest(struct soap *soap, struct srm2__srmStatusOfChangeSpaceForFilesRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	soap_default_string(soap, &a->requestToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmStatusOfChangeSpaceForFilesRequestRequest(struct soap *soap, const struct srm2__srmStatusOfChangeSpaceForFilesRequestRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequestRequest);
	if (soap_out_srm2__srmStatusOfChangeSpaceForFilesRequestRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmStatusOfChangeSpaceForFilesRequestRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmStatusOfChangeSpaceForFilesRequestRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequestRequest), type);
	soap_out_string(soap, "authorizationID", -1, &a->authorizationID, "");
	soap_out_string(soap, "requestToken", -1, &a->requestToken, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmStatusOfChangeSpaceForFilesRequestRequest * SOAP_FMAC4 soap_get_srm2__srmStatusOfChangeSpaceForFilesRequestRequest(struct soap *soap, struct srm2__srmStatusOfChangeSpaceForFilesRequestRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmStatusOfChangeSpaceForFilesRequestRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfChangeSpaceForFilesRequestRequest * SOAP_FMAC4 soap_in_srm2__srmStatusOfChangeSpaceForFilesRequestRequest(struct soap *soap, const char *tag, struct srm2__srmStatusOfChangeSpaceForFilesRequestRequest *a, const char *type)
{
	short soap_flag_authorizationID = 1, soap_flag_requestToken = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmStatusOfChangeSpaceForFilesRequestRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequestRequest, sizeof(struct srm2__srmStatusOfChangeSpaceForFilesRequestRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmStatusOfChangeSpaceForFilesRequestRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfChangeSpaceForFilesRequestRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequestRequest, 0, sizeof(struct srm2__srmStatusOfChangeSpaceForFilesRequestRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmChangeSpaceForFilesResponse(struct soap *soap, const struct srm2__srmChangeSpaceForFilesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_PointerToint(soap, &a->estimatedProcessingTime);
	soap_serialize_PointerTosrm2__ArrayOfTSURLReturnStatus(soap, &a->arrayOfFileStatuses);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmChangeSpaceForFilesResponse(struct soap *soap, struct srm2__srmChangeSpaceForFilesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	soap_default_string(soap, &a->requestToken);
	a->estimatedProcessingTime = NULL;
	a->arrayOfFileStatuses = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmChangeSpaceForFilesResponse(struct soap *soap, const struct srm2__srmChangeSpaceForFilesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmChangeSpaceForFilesResponse);
	if (soap_out_srm2__srmChangeSpaceForFilesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmChangeSpaceForFilesResponse(struct soap *soap, const char *tag, int id, const struct srm2__srmChangeSpaceForFilesResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmChangeSpaceForFilesResponse), type);
	soap_out_PointerTosrm2__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, "");
	soap_out_string(soap, "requestToken", -1, &a->requestToken, "");
	soap_out_PointerToint(soap, "estimatedProcessingTime", -1, &a->estimatedProcessingTime, "");
	soap_out_PointerTosrm2__ArrayOfTSURLReturnStatus(soap, "arrayOfFileStatuses", -1, &a->arrayOfFileStatuses, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmChangeSpaceForFilesResponse * SOAP_FMAC4 soap_get_srm2__srmChangeSpaceForFilesResponse(struct soap *soap, struct srm2__srmChangeSpaceForFilesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmChangeSpaceForFilesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmChangeSpaceForFilesResponse * SOAP_FMAC4 soap_in_srm2__srmChangeSpaceForFilesResponse(struct soap *soap, const char *tag, struct srm2__srmChangeSpaceForFilesResponse *a, const char *type)
{
	short soap_flag_returnStatus = 1, soap_flag_requestToken = 1, soap_flag_estimatedProcessingTime = 1, soap_flag_arrayOfFileStatuses = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmChangeSpaceForFilesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmChangeSpaceForFilesResponse, sizeof(struct srm2__srmChangeSpaceForFilesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmChangeSpaceForFilesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "returnStatus", &a->returnStatus, "srm2:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_estimatedProcessingTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "estimatedProcessingTime", &a->estimatedProcessingTime, "xsd:int"))
				{	soap_flag_estimatedProcessingTime--;
					continue;
				}
			if (soap_flag_arrayOfFileStatuses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTSURLReturnStatus(soap, "arrayOfFileStatuses", &a->arrayOfFileStatuses, "srm2:ArrayOfTSURLReturnStatus"))
				{	soap_flag_arrayOfFileStatuses--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmChangeSpaceForFilesResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmChangeSpaceForFilesResponse, 0, sizeof(struct srm2__srmChangeSpaceForFilesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmChangeSpaceForFilesRequest(struct soap *soap, const struct srm2__srmChangeSpaceForFilesRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_PointerTosrm2__ArrayOfAnyURI(soap, &a->arrayOfSURLs);
	soap_serialize_string(soap, &a->targetSpaceToken);
	soap_serialize_PointerTosrm2__ArrayOfTExtraInfo(soap, &a->storageSystemInfo);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmChangeSpaceForFilesRequest(struct soap *soap, struct srm2__srmChangeSpaceForFilesRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	a->arrayOfSURLs = NULL;
	soap_default_string(soap, &a->targetSpaceToken);
	a->storageSystemInfo = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmChangeSpaceForFilesRequest(struct soap *soap, const struct srm2__srmChangeSpaceForFilesRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmChangeSpaceForFilesRequest);
	if (soap_out_srm2__srmChangeSpaceForFilesRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmChangeSpaceForFilesRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmChangeSpaceForFilesRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmChangeSpaceForFilesRequest), type);
	soap_out_string(soap, "authorizationID", -1, &a->authorizationID, "");
	soap_out_PointerTosrm2__ArrayOfAnyURI(soap, "arrayOfSURLs", -1, &a->arrayOfSURLs, "");
	soap_out_string(soap, "targetSpaceToken", -1, &a->targetSpaceToken, "");
	soap_out_PointerTosrm2__ArrayOfTExtraInfo(soap, "storageSystemInfo", -1, &a->storageSystemInfo, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmChangeSpaceForFilesRequest * SOAP_FMAC4 soap_get_srm2__srmChangeSpaceForFilesRequest(struct soap *soap, struct srm2__srmChangeSpaceForFilesRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmChangeSpaceForFilesRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmChangeSpaceForFilesRequest * SOAP_FMAC4 soap_in_srm2__srmChangeSpaceForFilesRequest(struct soap *soap, const char *tag, struct srm2__srmChangeSpaceForFilesRequest *a, const char *type)
{
	short soap_flag_authorizationID = 1, soap_flag_arrayOfSURLs = 1, soap_flag_targetSpaceToken = 1, soap_flag_storageSystemInfo = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmChangeSpaceForFilesRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmChangeSpaceForFilesRequest, sizeof(struct srm2__srmChangeSpaceForFilesRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmChangeSpaceForFilesRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_arrayOfSURLs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfAnyURI(soap, "arrayOfSURLs", &a->arrayOfSURLs, "srm2:ArrayOfAnyURI"))
				{	soap_flag_arrayOfSURLs--;
					continue;
				}
			if (soap_flag_targetSpaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "targetSpaceToken", &a->targetSpaceToken, "xsd:string"))
				{	soap_flag_targetSpaceToken--;
					continue;
				}
			if (soap_flag_storageSystemInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTExtraInfo(soap, "storageSystemInfo", &a->storageSystemInfo, "srm2:ArrayOfTExtraInfo"))
				{	soap_flag_storageSystemInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arrayOfSURLs > 0 || soap_flag_targetSpaceToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmChangeSpaceForFilesRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmChangeSpaceForFilesRequest, 0, sizeof(struct srm2__srmChangeSpaceForFilesRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmGetSpaceMetaDataResponse(struct soap *soap, const struct srm2__srmGetSpaceMetaDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerTosrm2__ArrayOfTMetaDataSpace(soap, &a->arrayOfSpaceDetails);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmGetSpaceMetaDataResponse(struct soap *soap, struct srm2__srmGetSpaceMetaDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->arrayOfSpaceDetails = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmGetSpaceMetaDataResponse(struct soap *soap, const struct srm2__srmGetSpaceMetaDataResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmGetSpaceMetaDataResponse);
	if (soap_out_srm2__srmGetSpaceMetaDataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmGetSpaceMetaDataResponse(struct soap *soap, const char *tag, int id, const struct srm2__srmGetSpaceMetaDataResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmGetSpaceMetaDataResponse), type);
	soap_out_PointerTosrm2__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, "");
	soap_out_PointerTosrm2__ArrayOfTMetaDataSpace(soap, "arrayOfSpaceDetails", -1, &a->arrayOfSpaceDetails, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmGetSpaceMetaDataResponse * SOAP_FMAC4 soap_get_srm2__srmGetSpaceMetaDataResponse(struct soap *soap, struct srm2__srmGetSpaceMetaDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmGetSpaceMetaDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetSpaceMetaDataResponse * SOAP_FMAC4 soap_in_srm2__srmGetSpaceMetaDataResponse(struct soap *soap, const char *tag, struct srm2__srmGetSpaceMetaDataResponse *a, const char *type)
{
	short soap_flag_returnStatus = 1, soap_flag_arrayOfSpaceDetails = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmGetSpaceMetaDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmGetSpaceMetaDataResponse, sizeof(struct srm2__srmGetSpaceMetaDataResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmGetSpaceMetaDataResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "returnStatus", &a->returnStatus, "srm2:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_arrayOfSpaceDetails && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTMetaDataSpace(soap, "arrayOfSpaceDetails", &a->arrayOfSpaceDetails, "srm2:ArrayOfTMetaDataSpace"))
				{	soap_flag_arrayOfSpaceDetails--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetSpaceMetaDataResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetSpaceMetaDataResponse, 0, sizeof(struct srm2__srmGetSpaceMetaDataResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmGetSpaceMetaDataRequest(struct soap *soap, const struct srm2__srmGetSpaceMetaDataRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_PointerTosrm2__ArrayOfString(soap, &a->arrayOfSpaceTokens);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmGetSpaceMetaDataRequest(struct soap *soap, struct srm2__srmGetSpaceMetaDataRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	a->arrayOfSpaceTokens = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmGetSpaceMetaDataRequest(struct soap *soap, const struct srm2__srmGetSpaceMetaDataRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmGetSpaceMetaDataRequest);
	if (soap_out_srm2__srmGetSpaceMetaDataRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmGetSpaceMetaDataRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmGetSpaceMetaDataRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmGetSpaceMetaDataRequest), type);
	soap_out_string(soap, "authorizationID", -1, &a->authorizationID, "");
	soap_out_PointerTosrm2__ArrayOfString(soap, "arrayOfSpaceTokens", -1, &a->arrayOfSpaceTokens, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmGetSpaceMetaDataRequest * SOAP_FMAC4 soap_get_srm2__srmGetSpaceMetaDataRequest(struct soap *soap, struct srm2__srmGetSpaceMetaDataRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmGetSpaceMetaDataRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetSpaceMetaDataRequest * SOAP_FMAC4 soap_in_srm2__srmGetSpaceMetaDataRequest(struct soap *soap, const char *tag, struct srm2__srmGetSpaceMetaDataRequest *a, const char *type)
{
	short soap_flag_authorizationID = 1, soap_flag_arrayOfSpaceTokens = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmGetSpaceMetaDataRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmGetSpaceMetaDataRequest, sizeof(struct srm2__srmGetSpaceMetaDataRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmGetSpaceMetaDataRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_arrayOfSpaceTokens && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfString(soap, "arrayOfSpaceTokens", &a->arrayOfSpaceTokens, "srm2:ArrayOfString"))
				{	soap_flag_arrayOfSpaceTokens--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arrayOfSpaceTokens > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetSpaceMetaDataRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetSpaceMetaDataRequest, 0, sizeof(struct srm2__srmGetSpaceMetaDataRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmStatusOfUpdateSpaceRequestResponse(struct soap *soap, const struct srm2__srmStatusOfUpdateSpaceRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerTounsignedLONG64(soap, &a->sizeOfTotalSpace);
	soap_serialize_PointerTounsignedLONG64(soap, &a->sizeOfGuaranteedSpace);
	soap_serialize_PointerToint(soap, &a->lifetimeGranted);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmStatusOfUpdateSpaceRequestResponse(struct soap *soap, struct srm2__srmStatusOfUpdateSpaceRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->sizeOfTotalSpace = NULL;
	a->sizeOfGuaranteedSpace = NULL;
	a->lifetimeGranted = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmStatusOfUpdateSpaceRequestResponse(struct soap *soap, const struct srm2__srmStatusOfUpdateSpaceRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequestResponse);
	if (soap_out_srm2__srmStatusOfUpdateSpaceRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmStatusOfUpdateSpaceRequestResponse(struct soap *soap, const char *tag, int id, const struct srm2__srmStatusOfUpdateSpaceRequestResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequestResponse), type);
	soap_out_PointerTosrm2__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, "");
	soap_out_PointerTounsignedLONG64(soap, "sizeOfTotalSpace", -1, &a->sizeOfTotalSpace, "");
	soap_out_PointerTounsignedLONG64(soap, "sizeOfGuaranteedSpace", -1, &a->sizeOfGuaranteedSpace, "");
	soap_out_PointerToint(soap, "lifetimeGranted", -1, &a->lifetimeGranted, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmStatusOfUpdateSpaceRequestResponse * SOAP_FMAC4 soap_get_srm2__srmStatusOfUpdateSpaceRequestResponse(struct soap *soap, struct srm2__srmStatusOfUpdateSpaceRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmStatusOfUpdateSpaceRequestResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfUpdateSpaceRequestResponse * SOAP_FMAC4 soap_in_srm2__srmStatusOfUpdateSpaceRequestResponse(struct soap *soap, const char *tag, struct srm2__srmStatusOfUpdateSpaceRequestResponse *a, const char *type)
{
	short soap_flag_returnStatus = 1, soap_flag_sizeOfTotalSpace = 1, soap_flag_sizeOfGuaranteedSpace = 1, soap_flag_lifetimeGranted = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmStatusOfUpdateSpaceRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequestResponse, sizeof(struct srm2__srmStatusOfUpdateSpaceRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmStatusOfUpdateSpaceRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "returnStatus", &a->returnStatus, "srm2:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_sizeOfTotalSpace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "sizeOfTotalSpace", &a->sizeOfTotalSpace, "xsd:unsignedLong"))
				{	soap_flag_sizeOfTotalSpace--;
					continue;
				}
			if (soap_flag_sizeOfGuaranteedSpace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "sizeOfGuaranteedSpace", &a->sizeOfGuaranteedSpace, "xsd:unsignedLong"))
				{	soap_flag_sizeOfGuaranteedSpace--;
					continue;
				}
			if (soap_flag_lifetimeGranted && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "lifetimeGranted", &a->lifetimeGranted, "xsd:int"))
				{	soap_flag_lifetimeGranted--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfUpdateSpaceRequestResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequestResponse, 0, sizeof(struct srm2__srmStatusOfUpdateSpaceRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmStatusOfUpdateSpaceRequestRequest(struct soap *soap, const struct srm2__srmStatusOfUpdateSpaceRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_string(soap, &a->requestToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmStatusOfUpdateSpaceRequestRequest(struct soap *soap, struct srm2__srmStatusOfUpdateSpaceRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	soap_default_string(soap, &a->requestToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmStatusOfUpdateSpaceRequestRequest(struct soap *soap, const struct srm2__srmStatusOfUpdateSpaceRequestRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequestRequest);
	if (soap_out_srm2__srmStatusOfUpdateSpaceRequestRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmStatusOfUpdateSpaceRequestRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmStatusOfUpdateSpaceRequestRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequestRequest), type);
	soap_out_string(soap, "authorizationID", -1, &a->authorizationID, "");
	soap_out_string(soap, "requestToken", -1, &a->requestToken, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmStatusOfUpdateSpaceRequestRequest * SOAP_FMAC4 soap_get_srm2__srmStatusOfUpdateSpaceRequestRequest(struct soap *soap, struct srm2__srmStatusOfUpdateSpaceRequestRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmStatusOfUpdateSpaceRequestRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfUpdateSpaceRequestRequest * SOAP_FMAC4 soap_in_srm2__srmStatusOfUpdateSpaceRequestRequest(struct soap *soap, const char *tag, struct srm2__srmStatusOfUpdateSpaceRequestRequest *a, const char *type)
{
	short soap_flag_authorizationID = 1, soap_flag_requestToken = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmStatusOfUpdateSpaceRequestRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequestRequest, sizeof(struct srm2__srmStatusOfUpdateSpaceRequestRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmStatusOfUpdateSpaceRequestRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfUpdateSpaceRequestRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequestRequest, 0, sizeof(struct srm2__srmStatusOfUpdateSpaceRequestRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmUpdateSpaceResponse(struct soap *soap, const struct srm2__srmUpdateSpaceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_PointerTounsignedLONG64(soap, &a->sizeOfTotalSpace);
	soap_serialize_PointerTounsignedLONG64(soap, &a->sizeOfGuaranteedSpace);
	soap_serialize_PointerToint(soap, &a->lifetimeGranted);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmUpdateSpaceResponse(struct soap *soap, struct srm2__srmUpdateSpaceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	soap_default_string(soap, &a->requestToken);
	a->sizeOfTotalSpace = NULL;
	a->sizeOfGuaranteedSpace = NULL;
	a->lifetimeGranted = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmUpdateSpaceResponse(struct soap *soap, const struct srm2__srmUpdateSpaceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmUpdateSpaceResponse);
	if (soap_out_srm2__srmUpdateSpaceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmUpdateSpaceResponse(struct soap *soap, const char *tag, int id, const struct srm2__srmUpdateSpaceResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmUpdateSpaceResponse), type);
	soap_out_PointerTosrm2__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, "");
	soap_out_string(soap, "requestToken", -1, &a->requestToken, "");
	soap_out_PointerTounsignedLONG64(soap, "sizeOfTotalSpace", -1, &a->sizeOfTotalSpace, "");
	soap_out_PointerTounsignedLONG64(soap, "sizeOfGuaranteedSpace", -1, &a->sizeOfGuaranteedSpace, "");
	soap_out_PointerToint(soap, "lifetimeGranted", -1, &a->lifetimeGranted, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmUpdateSpaceResponse * SOAP_FMAC4 soap_get_srm2__srmUpdateSpaceResponse(struct soap *soap, struct srm2__srmUpdateSpaceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmUpdateSpaceResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmUpdateSpaceResponse * SOAP_FMAC4 soap_in_srm2__srmUpdateSpaceResponse(struct soap *soap, const char *tag, struct srm2__srmUpdateSpaceResponse *a, const char *type)
{
	short soap_flag_returnStatus = 1, soap_flag_requestToken = 1, soap_flag_sizeOfTotalSpace = 1, soap_flag_sizeOfGuaranteedSpace = 1, soap_flag_lifetimeGranted = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmUpdateSpaceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmUpdateSpaceResponse, sizeof(struct srm2__srmUpdateSpaceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmUpdateSpaceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "returnStatus", &a->returnStatus, "srm2:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_sizeOfTotalSpace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "sizeOfTotalSpace", &a->sizeOfTotalSpace, "xsd:unsignedLong"))
				{	soap_flag_sizeOfTotalSpace--;
					continue;
				}
			if (soap_flag_sizeOfGuaranteedSpace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "sizeOfGuaranteedSpace", &a->sizeOfGuaranteedSpace, "xsd:unsignedLong"))
				{	soap_flag_sizeOfGuaranteedSpace--;
					continue;
				}
			if (soap_flag_lifetimeGranted && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "lifetimeGranted", &a->lifetimeGranted, "xsd:int"))
				{	soap_flag_lifetimeGranted--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmUpdateSpaceResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmUpdateSpaceResponse, 0, sizeof(struct srm2__srmUpdateSpaceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmUpdateSpaceRequest(struct soap *soap, const struct srm2__srmUpdateSpaceRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_string(soap, &a->spaceToken);
	soap_serialize_PointerTounsignedLONG64(soap, &a->newSizeOfTotalSpaceDesired);
	soap_serialize_PointerTounsignedLONG64(soap, &a->newSizeOfGuaranteedSpaceDesired);
	soap_serialize_PointerToint(soap, &a->newLifeTime);
	soap_serialize_PointerTosrm2__ArrayOfTExtraInfo(soap, &a->storageSystemInfo);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmUpdateSpaceRequest(struct soap *soap, struct srm2__srmUpdateSpaceRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	soap_default_string(soap, &a->spaceToken);
	a->newSizeOfTotalSpaceDesired = NULL;
	a->newSizeOfGuaranteedSpaceDesired = NULL;
	a->newLifeTime = NULL;
	a->storageSystemInfo = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmUpdateSpaceRequest(struct soap *soap, const struct srm2__srmUpdateSpaceRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmUpdateSpaceRequest);
	if (soap_out_srm2__srmUpdateSpaceRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmUpdateSpaceRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmUpdateSpaceRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmUpdateSpaceRequest), type);
	soap_out_string(soap, "authorizationID", -1, &a->authorizationID, "");
	soap_out_string(soap, "spaceToken", -1, &a->spaceToken, "");
	soap_out_PointerTounsignedLONG64(soap, "newSizeOfTotalSpaceDesired", -1, &a->newSizeOfTotalSpaceDesired, "");
	soap_out_PointerTounsignedLONG64(soap, "newSizeOfGuaranteedSpaceDesired", -1, &a->newSizeOfGuaranteedSpaceDesired, "");
	soap_out_PointerToint(soap, "newLifeTime", -1, &a->newLifeTime, "");
	soap_out_PointerTosrm2__ArrayOfTExtraInfo(soap, "storageSystemInfo", -1, &a->storageSystemInfo, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmUpdateSpaceRequest * SOAP_FMAC4 soap_get_srm2__srmUpdateSpaceRequest(struct soap *soap, struct srm2__srmUpdateSpaceRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmUpdateSpaceRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmUpdateSpaceRequest * SOAP_FMAC4 soap_in_srm2__srmUpdateSpaceRequest(struct soap *soap, const char *tag, struct srm2__srmUpdateSpaceRequest *a, const char *type)
{
	short soap_flag_authorizationID = 1, soap_flag_spaceToken = 1, soap_flag_newSizeOfTotalSpaceDesired = 1, soap_flag_newSizeOfGuaranteedSpaceDesired = 1, soap_flag_newLifeTime = 1, soap_flag_storageSystemInfo = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmUpdateSpaceRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmUpdateSpaceRequest, sizeof(struct srm2__srmUpdateSpaceRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmUpdateSpaceRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_spaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "spaceToken", &a->spaceToken, "xsd:string"))
				{	soap_flag_spaceToken--;
					continue;
				}
			if (soap_flag_newSizeOfTotalSpaceDesired && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "newSizeOfTotalSpaceDesired", &a->newSizeOfTotalSpaceDesired, "xsd:unsignedLong"))
				{	soap_flag_newSizeOfTotalSpaceDesired--;
					continue;
				}
			if (soap_flag_newSizeOfGuaranteedSpaceDesired && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "newSizeOfGuaranteedSpaceDesired", &a->newSizeOfGuaranteedSpaceDesired, "xsd:unsignedLong"))
				{	soap_flag_newSizeOfGuaranteedSpaceDesired--;
					continue;
				}
			if (soap_flag_newLifeTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "newLifeTime", &a->newLifeTime, "xsd:int"))
				{	soap_flag_newLifeTime--;
					continue;
				}
			if (soap_flag_storageSystemInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTExtraInfo(soap, "storageSystemInfo", &a->storageSystemInfo, "srm2:ArrayOfTExtraInfo"))
				{	soap_flag_storageSystemInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_spaceToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmUpdateSpaceRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmUpdateSpaceRequest, 0, sizeof(struct srm2__srmUpdateSpaceRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmReleaseSpaceResponse(struct soap *soap, const struct srm2__srmReleaseSpaceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->returnStatus);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmReleaseSpaceResponse(struct soap *soap, struct srm2__srmReleaseSpaceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmReleaseSpaceResponse(struct soap *soap, const struct srm2__srmReleaseSpaceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmReleaseSpaceResponse);
	if (soap_out_srm2__srmReleaseSpaceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmReleaseSpaceResponse(struct soap *soap, const char *tag, int id, const struct srm2__srmReleaseSpaceResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmReleaseSpaceResponse), type);
	soap_out_PointerTosrm2__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmReleaseSpaceResponse * SOAP_FMAC4 soap_get_srm2__srmReleaseSpaceResponse(struct soap *soap, struct srm2__srmReleaseSpaceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmReleaseSpaceResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmReleaseSpaceResponse * SOAP_FMAC4 soap_in_srm2__srmReleaseSpaceResponse(struct soap *soap, const char *tag, struct srm2__srmReleaseSpaceResponse *a, const char *type)
{
	short soap_flag_returnStatus = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmReleaseSpaceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmReleaseSpaceResponse, sizeof(struct srm2__srmReleaseSpaceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmReleaseSpaceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "returnStatus", &a->returnStatus, "srm2:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmReleaseSpaceResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmReleaseSpaceResponse, 0, sizeof(struct srm2__srmReleaseSpaceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmReleaseSpaceRequest(struct soap *soap, const struct srm2__srmReleaseSpaceRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_string(soap, &a->spaceToken);
	soap_serialize_PointerTosrm2__ArrayOfTExtraInfo(soap, &a->storageSystemInfo);
	soap_serialize_PointerToxsd__boolean(soap, &a->forceFileRelease);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmReleaseSpaceRequest(struct soap *soap, struct srm2__srmReleaseSpaceRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	soap_default_string(soap, &a->spaceToken);
	a->storageSystemInfo = NULL;
	a->forceFileRelease = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmReleaseSpaceRequest(struct soap *soap, const struct srm2__srmReleaseSpaceRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmReleaseSpaceRequest);
	if (soap_out_srm2__srmReleaseSpaceRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmReleaseSpaceRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmReleaseSpaceRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmReleaseSpaceRequest), type);
	soap_out_string(soap, "authorizationID", -1, &a->authorizationID, "");
	soap_out_string(soap, "spaceToken", -1, &a->spaceToken, "");
	soap_out_PointerTosrm2__ArrayOfTExtraInfo(soap, "storageSystemInfo", -1, &a->storageSystemInfo, "");
	soap_out_PointerToxsd__boolean(soap, "forceFileRelease", -1, &a->forceFileRelease, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmReleaseSpaceRequest * SOAP_FMAC4 soap_get_srm2__srmReleaseSpaceRequest(struct soap *soap, struct srm2__srmReleaseSpaceRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmReleaseSpaceRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmReleaseSpaceRequest * SOAP_FMAC4 soap_in_srm2__srmReleaseSpaceRequest(struct soap *soap, const char *tag, struct srm2__srmReleaseSpaceRequest *a, const char *type)
{
	short soap_flag_authorizationID = 1, soap_flag_spaceToken = 1, soap_flag_storageSystemInfo = 1, soap_flag_forceFileRelease = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmReleaseSpaceRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmReleaseSpaceRequest, sizeof(struct srm2__srmReleaseSpaceRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmReleaseSpaceRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_spaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "spaceToken", &a->spaceToken, "xsd:string"))
				{	soap_flag_spaceToken--;
					continue;
				}
			if (soap_flag_storageSystemInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTExtraInfo(soap, "storageSystemInfo", &a->storageSystemInfo, "srm2:ArrayOfTExtraInfo"))
				{	soap_flag_storageSystemInfo--;
					continue;
				}
			if (soap_flag_forceFileRelease && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "forceFileRelease", &a->forceFileRelease, "xsd:boolean"))
				{	soap_flag_forceFileRelease--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_spaceToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmReleaseSpaceRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmReleaseSpaceRequest, 0, sizeof(struct srm2__srmReleaseSpaceRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmStatusOfReserveSpaceRequestResponse(struct soap *soap, const struct srm2__srmStatusOfReserveSpaceRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_PointerToint(soap, &a->estimatedProcessingTime);
	soap_serialize_PointerTosrm2__TRetentionPolicyInfo(soap, &a->retentionPolicyInfo);
	soap_serialize_PointerTounsignedLONG64(soap, &a->sizeOfTotalReservedSpace);
	soap_serialize_PointerTounsignedLONG64(soap, &a->sizeOfGuaranteedReservedSpace);
	soap_serialize_PointerToint(soap, &a->lifetimeOfReservedSpace);
	soap_serialize_string(soap, &a->spaceToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmStatusOfReserveSpaceRequestResponse(struct soap *soap, struct srm2__srmStatusOfReserveSpaceRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	a->estimatedProcessingTime = NULL;
	a->retentionPolicyInfo = NULL;
	a->sizeOfTotalReservedSpace = NULL;
	a->sizeOfGuaranteedReservedSpace = NULL;
	a->lifetimeOfReservedSpace = NULL;
	soap_default_string(soap, &a->spaceToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmStatusOfReserveSpaceRequestResponse(struct soap *soap, const struct srm2__srmStatusOfReserveSpaceRequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequestResponse);
	if (soap_out_srm2__srmStatusOfReserveSpaceRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmStatusOfReserveSpaceRequestResponse(struct soap *soap, const char *tag, int id, const struct srm2__srmStatusOfReserveSpaceRequestResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequestResponse), type);
	soap_out_PointerTosrm2__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, "");
	soap_out_PointerToint(soap, "estimatedProcessingTime", -1, &a->estimatedProcessingTime, "");
	soap_out_PointerTosrm2__TRetentionPolicyInfo(soap, "retentionPolicyInfo", -1, &a->retentionPolicyInfo, "");
	soap_out_PointerTounsignedLONG64(soap, "sizeOfTotalReservedSpace", -1, &a->sizeOfTotalReservedSpace, "");
	soap_out_PointerTounsignedLONG64(soap, "sizeOfGuaranteedReservedSpace", -1, &a->sizeOfGuaranteedReservedSpace, "");
	soap_out_PointerToint(soap, "lifetimeOfReservedSpace", -1, &a->lifetimeOfReservedSpace, "");
	soap_out_string(soap, "spaceToken", -1, &a->spaceToken, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmStatusOfReserveSpaceRequestResponse * SOAP_FMAC4 soap_get_srm2__srmStatusOfReserveSpaceRequestResponse(struct soap *soap, struct srm2__srmStatusOfReserveSpaceRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmStatusOfReserveSpaceRequestResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfReserveSpaceRequestResponse * SOAP_FMAC4 soap_in_srm2__srmStatusOfReserveSpaceRequestResponse(struct soap *soap, const char *tag, struct srm2__srmStatusOfReserveSpaceRequestResponse *a, const char *type)
{
	short soap_flag_returnStatus = 1, soap_flag_estimatedProcessingTime = 1, soap_flag_retentionPolicyInfo = 1, soap_flag_sizeOfTotalReservedSpace = 1, soap_flag_sizeOfGuaranteedReservedSpace = 1, soap_flag_lifetimeOfReservedSpace = 1, soap_flag_spaceToken = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmStatusOfReserveSpaceRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequestResponse, sizeof(struct srm2__srmStatusOfReserveSpaceRequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmStatusOfReserveSpaceRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "returnStatus", &a->returnStatus, "srm2:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_estimatedProcessingTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "estimatedProcessingTime", &a->estimatedProcessingTime, "xsd:int"))
				{	soap_flag_estimatedProcessingTime--;
					continue;
				}
			if (soap_flag_retentionPolicyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TRetentionPolicyInfo(soap, "retentionPolicyInfo", &a->retentionPolicyInfo, "srm2:TRetentionPolicyInfo"))
				{	soap_flag_retentionPolicyInfo--;
					continue;
				}
			if (soap_flag_sizeOfTotalReservedSpace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "sizeOfTotalReservedSpace", &a->sizeOfTotalReservedSpace, "xsd:unsignedLong"))
				{	soap_flag_sizeOfTotalReservedSpace--;
					continue;
				}
			if (soap_flag_sizeOfGuaranteedReservedSpace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "sizeOfGuaranteedReservedSpace", &a->sizeOfGuaranteedReservedSpace, "xsd:unsignedLong"))
				{	soap_flag_sizeOfGuaranteedReservedSpace--;
					continue;
				}
			if (soap_flag_lifetimeOfReservedSpace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "lifetimeOfReservedSpace", &a->lifetimeOfReservedSpace, "xsd:int"))
				{	soap_flag_lifetimeOfReservedSpace--;
					continue;
				}
			if (soap_flag_spaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "spaceToken", &a->spaceToken, "xsd:string"))
				{	soap_flag_spaceToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfReserveSpaceRequestResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequestResponse, 0, sizeof(struct srm2__srmStatusOfReserveSpaceRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmStatusOfReserveSpaceRequestRequest(struct soap *soap, const struct srm2__srmStatusOfReserveSpaceRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_string(soap, &a->requestToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmStatusOfReserveSpaceRequestRequest(struct soap *soap, struct srm2__srmStatusOfReserveSpaceRequestRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	soap_default_string(soap, &a->requestToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmStatusOfReserveSpaceRequestRequest(struct soap *soap, const struct srm2__srmStatusOfReserveSpaceRequestRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequestRequest);
	if (soap_out_srm2__srmStatusOfReserveSpaceRequestRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmStatusOfReserveSpaceRequestRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmStatusOfReserveSpaceRequestRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequestRequest), type);
	soap_out_string(soap, "authorizationID", -1, &a->authorizationID, "");
	soap_out_string(soap, "requestToken", -1, &a->requestToken, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmStatusOfReserveSpaceRequestRequest * SOAP_FMAC4 soap_get_srm2__srmStatusOfReserveSpaceRequestRequest(struct soap *soap, struct srm2__srmStatusOfReserveSpaceRequestRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmStatusOfReserveSpaceRequestRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfReserveSpaceRequestRequest * SOAP_FMAC4 soap_in_srm2__srmStatusOfReserveSpaceRequestRequest(struct soap *soap, const char *tag, struct srm2__srmStatusOfReserveSpaceRequestRequest *a, const char *type)
{
	short soap_flag_authorizationID = 1, soap_flag_requestToken = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmStatusOfReserveSpaceRequestRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequestRequest, sizeof(struct srm2__srmStatusOfReserveSpaceRequestRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmStatusOfReserveSpaceRequestRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfReserveSpaceRequestRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequestRequest, 0, sizeof(struct srm2__srmStatusOfReserveSpaceRequestRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmReserveSpaceResponse(struct soap *soap, const struct srm2__srmReserveSpaceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->returnStatus);
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_PointerToint(soap, &a->estimatedProcessingTime);
	soap_serialize_PointerTosrm2__TRetentionPolicyInfo(soap, &a->retentionPolicyInfo);
	soap_serialize_PointerTounsignedLONG64(soap, &a->sizeOfTotalReservedSpace);
	soap_serialize_PointerTounsignedLONG64(soap, &a->sizeOfGuaranteedReservedSpace);
	soap_serialize_PointerToint(soap, &a->lifetimeOfReservedSpace);
	soap_serialize_string(soap, &a->spaceToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmReserveSpaceResponse(struct soap *soap, struct srm2__srmReserveSpaceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnStatus = NULL;
	soap_default_string(soap, &a->requestToken);
	a->estimatedProcessingTime = NULL;
	a->retentionPolicyInfo = NULL;
	a->sizeOfTotalReservedSpace = NULL;
	a->sizeOfGuaranteedReservedSpace = NULL;
	a->lifetimeOfReservedSpace = NULL;
	soap_default_string(soap, &a->spaceToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmReserveSpaceResponse(struct soap *soap, const struct srm2__srmReserveSpaceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmReserveSpaceResponse);
	if (soap_out_srm2__srmReserveSpaceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmReserveSpaceResponse(struct soap *soap, const char *tag, int id, const struct srm2__srmReserveSpaceResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmReserveSpaceResponse), type);
	soap_out_PointerTosrm2__TReturnStatus(soap, "returnStatus", -1, &a->returnStatus, "");
	soap_out_string(soap, "requestToken", -1, &a->requestToken, "");
	soap_out_PointerToint(soap, "estimatedProcessingTime", -1, &a->estimatedProcessingTime, "");
	soap_out_PointerTosrm2__TRetentionPolicyInfo(soap, "retentionPolicyInfo", -1, &a->retentionPolicyInfo, "");
	soap_out_PointerTounsignedLONG64(soap, "sizeOfTotalReservedSpace", -1, &a->sizeOfTotalReservedSpace, "");
	soap_out_PointerTounsignedLONG64(soap, "sizeOfGuaranteedReservedSpace", -1, &a->sizeOfGuaranteedReservedSpace, "");
	soap_out_PointerToint(soap, "lifetimeOfReservedSpace", -1, &a->lifetimeOfReservedSpace, "");
	soap_out_string(soap, "spaceToken", -1, &a->spaceToken, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmReserveSpaceResponse * SOAP_FMAC4 soap_get_srm2__srmReserveSpaceResponse(struct soap *soap, struct srm2__srmReserveSpaceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmReserveSpaceResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmReserveSpaceResponse * SOAP_FMAC4 soap_in_srm2__srmReserveSpaceResponse(struct soap *soap, const char *tag, struct srm2__srmReserveSpaceResponse *a, const char *type)
{
	short soap_flag_returnStatus = 1, soap_flag_requestToken = 1, soap_flag_estimatedProcessingTime = 1, soap_flag_retentionPolicyInfo = 1, soap_flag_sizeOfTotalReservedSpace = 1, soap_flag_sizeOfGuaranteedReservedSpace = 1, soap_flag_lifetimeOfReservedSpace = 1, soap_flag_spaceToken = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmReserveSpaceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmReserveSpaceResponse, sizeof(struct srm2__srmReserveSpaceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmReserveSpaceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "returnStatus", &a->returnStatus, "srm2:TReturnStatus"))
				{	soap_flag_returnStatus--;
					continue;
				}
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_estimatedProcessingTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "estimatedProcessingTime", &a->estimatedProcessingTime, "xsd:int"))
				{	soap_flag_estimatedProcessingTime--;
					continue;
				}
			if (soap_flag_retentionPolicyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TRetentionPolicyInfo(soap, "retentionPolicyInfo", &a->retentionPolicyInfo, "srm2:TRetentionPolicyInfo"))
				{	soap_flag_retentionPolicyInfo--;
					continue;
				}
			if (soap_flag_sizeOfTotalReservedSpace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "sizeOfTotalReservedSpace", &a->sizeOfTotalReservedSpace, "xsd:unsignedLong"))
				{	soap_flag_sizeOfTotalReservedSpace--;
					continue;
				}
			if (soap_flag_sizeOfGuaranteedReservedSpace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "sizeOfGuaranteedReservedSpace", &a->sizeOfGuaranteedReservedSpace, "xsd:unsignedLong"))
				{	soap_flag_sizeOfGuaranteedReservedSpace--;
					continue;
				}
			if (soap_flag_lifetimeOfReservedSpace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "lifetimeOfReservedSpace", &a->lifetimeOfReservedSpace, "xsd:int"))
				{	soap_flag_lifetimeOfReservedSpace--;
					continue;
				}
			if (soap_flag_spaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "spaceToken", &a->spaceToken, "xsd:string"))
				{	soap_flag_spaceToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmReserveSpaceResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmReserveSpaceResponse, 0, sizeof(struct srm2__srmReserveSpaceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__srmReserveSpaceRequest(struct soap *soap, const struct srm2__srmReserveSpaceRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authorizationID);
	soap_serialize_string(soap, &a->userSpaceTokenDescription);
	soap_serialize_PointerTosrm2__TRetentionPolicyInfo(soap, &a->retentionPolicyInfo);
	soap_serialize_PointerTounsignedLONG64(soap, &a->desiredSizeOfTotalSpace);
	soap_embedded(soap, &a->desiredSizeOfGuaranteedSpace, SOAP_TYPE_unsignedLONG64);
	soap_serialize_PointerToint(soap, &a->desiredLifetimeOfReservedSpace);
	soap_serialize_PointerTosrm2__ArrayOfUnsignedLong(soap, &a->arrayOfExpectedFileSizes);
	soap_serialize_PointerTosrm2__ArrayOfTExtraInfo(soap, &a->storageSystemInfo);
	soap_serialize_PointerTosrm2__TTransferParameters(soap, &a->transferParameters);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__srmReserveSpaceRequest(struct soap *soap, struct srm2__srmReserveSpaceRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authorizationID);
	soap_default_string(soap, &a->userSpaceTokenDescription);
	a->retentionPolicyInfo = NULL;
	a->desiredSizeOfTotalSpace = NULL;
	soap_default_unsignedLONG64(soap, &a->desiredSizeOfGuaranteedSpace);
	a->desiredLifetimeOfReservedSpace = NULL;
	a->arrayOfExpectedFileSizes = NULL;
	a->storageSystemInfo = NULL;
	a->transferParameters = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__srmReserveSpaceRequest(struct soap *soap, const struct srm2__srmReserveSpaceRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__srmReserveSpaceRequest);
	if (soap_out_srm2__srmReserveSpaceRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__srmReserveSpaceRequest(struct soap *soap, const char *tag, int id, const struct srm2__srmReserveSpaceRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__srmReserveSpaceRequest), type);
	soap_out_string(soap, "authorizationID", -1, &a->authorizationID, "");
	soap_out_string(soap, "userSpaceTokenDescription", -1, &a->userSpaceTokenDescription, "");
	soap_out_PointerTosrm2__TRetentionPolicyInfo(soap, "retentionPolicyInfo", -1, &a->retentionPolicyInfo, "");
	soap_out_PointerTounsignedLONG64(soap, "desiredSizeOfTotalSpace", -1, &a->desiredSizeOfTotalSpace, "");
	soap_out_unsignedLONG64(soap, "desiredSizeOfGuaranteedSpace", -1, &a->desiredSizeOfGuaranteedSpace, "");
	soap_out_PointerToint(soap, "desiredLifetimeOfReservedSpace", -1, &a->desiredLifetimeOfReservedSpace, "");
	soap_out_PointerTosrm2__ArrayOfUnsignedLong(soap, "arrayOfExpectedFileSizes", -1, &a->arrayOfExpectedFileSizes, "");
	soap_out_PointerTosrm2__ArrayOfTExtraInfo(soap, "storageSystemInfo", -1, &a->storageSystemInfo, "");
	soap_out_PointerTosrm2__TTransferParameters(soap, "transferParameters", -1, &a->transferParameters, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__srmReserveSpaceRequest * SOAP_FMAC4 soap_get_srm2__srmReserveSpaceRequest(struct soap *soap, struct srm2__srmReserveSpaceRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__srmReserveSpaceRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmReserveSpaceRequest * SOAP_FMAC4 soap_in_srm2__srmReserveSpaceRequest(struct soap *soap, const char *tag, struct srm2__srmReserveSpaceRequest *a, const char *type)
{
	short soap_flag_authorizationID = 1, soap_flag_userSpaceTokenDescription = 1, soap_flag_retentionPolicyInfo = 1, soap_flag_desiredSizeOfTotalSpace = 1, soap_flag_desiredSizeOfGuaranteedSpace = 1, soap_flag_desiredLifetimeOfReservedSpace = 1, soap_flag_arrayOfExpectedFileSizes = 1, soap_flag_storageSystemInfo = 1, soap_flag_transferParameters = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__srmReserveSpaceRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__srmReserveSpaceRequest, sizeof(struct srm2__srmReserveSpaceRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__srmReserveSpaceRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authorizationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authorizationID", &a->authorizationID, "xsd:string"))
				{	soap_flag_authorizationID--;
					continue;
				}
			if (soap_flag_userSpaceTokenDescription && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userSpaceTokenDescription", &a->userSpaceTokenDescription, "xsd:string"))
				{	soap_flag_userSpaceTokenDescription--;
					continue;
				}
			if (soap_flag_retentionPolicyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TRetentionPolicyInfo(soap, "retentionPolicyInfo", &a->retentionPolicyInfo, "srm2:TRetentionPolicyInfo"))
				{	soap_flag_retentionPolicyInfo--;
					continue;
				}
			if (soap_flag_desiredSizeOfTotalSpace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "desiredSizeOfTotalSpace", &a->desiredSizeOfTotalSpace, "xsd:unsignedLong"))
				{	soap_flag_desiredSizeOfTotalSpace--;
					continue;
				}
			if (soap_flag_desiredSizeOfGuaranteedSpace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLONG64(soap, "desiredSizeOfGuaranteedSpace", &a->desiredSizeOfGuaranteedSpace, "xsd:unsignedLong"))
				{	soap_flag_desiredSizeOfGuaranteedSpace--;
					continue;
				}
			if (soap_flag_desiredLifetimeOfReservedSpace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "desiredLifetimeOfReservedSpace", &a->desiredLifetimeOfReservedSpace, "xsd:int"))
				{	soap_flag_desiredLifetimeOfReservedSpace--;
					continue;
				}
			if (soap_flag_arrayOfExpectedFileSizes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfUnsignedLong(soap, "arrayOfExpectedFileSizes", &a->arrayOfExpectedFileSizes, "srm2:ArrayOfUnsignedLong"))
				{	soap_flag_arrayOfExpectedFileSizes--;
					continue;
				}
			if (soap_flag_storageSystemInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTExtraInfo(soap, "storageSystemInfo", &a->storageSystemInfo, "srm2:ArrayOfTExtraInfo"))
				{	soap_flag_storageSystemInfo--;
					continue;
				}
			if (soap_flag_transferParameters && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TTransferParameters(soap, "transferParameters", &a->transferParameters, "srm2:TTransferParameters"))
				{	soap_flag_transferParameters--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_retentionPolicyInfo > 0 || soap_flag_desiredSizeOfGuaranteedSpace > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__srmReserveSpaceRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmReserveSpaceRequest, 0, sizeof(struct srm2__srmReserveSpaceRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__ArrayOfTSupportedTransferProtocol(struct soap *soap, const struct srm2__ArrayOfTSupportedTransferProtocol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->protocolArray)
	{	int i;
		for (i = 0; i < a->__sizeprotocolArray; i++)
		{
			soap_serialize_PointerTosrm2__TSupportedTransferProtocol(soap, a->protocolArray + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__ArrayOfTSupportedTransferProtocol(struct soap *soap, struct srm2__ArrayOfTSupportedTransferProtocol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeprotocolArray = 0;
	a->protocolArray = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__ArrayOfTSupportedTransferProtocol(struct soap *soap, const struct srm2__ArrayOfTSupportedTransferProtocol *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__ArrayOfTSupportedTransferProtocol);
	if (soap_out_srm2__ArrayOfTSupportedTransferProtocol(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__ArrayOfTSupportedTransferProtocol(struct soap *soap, const char *tag, int id, const struct srm2__ArrayOfTSupportedTransferProtocol *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__ArrayOfTSupportedTransferProtocol), type);
	if (a->protocolArray)
	{	int i;
		for (i = 0; i < a->__sizeprotocolArray; i++)
			soap_out_PointerTosrm2__TSupportedTransferProtocol(soap, "protocolArray", -1, a->protocolArray + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__ArrayOfTSupportedTransferProtocol * SOAP_FMAC4 soap_get_srm2__ArrayOfTSupportedTransferProtocol(struct soap *soap, struct srm2__ArrayOfTSupportedTransferProtocol *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__ArrayOfTSupportedTransferProtocol(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfTSupportedTransferProtocol * SOAP_FMAC4 soap_in_srm2__ArrayOfTSupportedTransferProtocol(struct soap *soap, const char *tag, struct srm2__ArrayOfTSupportedTransferProtocol *a, const char *type)
{
	short soap_flag_protocolArray = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__ArrayOfTSupportedTransferProtocol *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__ArrayOfTSupportedTransferProtocol, sizeof(struct srm2__ArrayOfTSupportedTransferProtocol), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__ArrayOfTSupportedTransferProtocol(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_protocolArray && soap->error == SOAP_TAG_MISMATCH)
			{	struct srm2__TSupportedTransferProtocol **p;
				soap_new_block(soap);
				for (a->__sizeprotocolArray = 0; !soap_element_begin_in(soap, "protocolArray", 1); a->__sizeprotocolArray++)
				{	p = (struct srm2__TSupportedTransferProtocol **)soap_push_block(soap, sizeof(struct srm2__TSupportedTransferProtocol *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_PointerTosrm2__TSupportedTransferProtocol(soap, "protocolArray", p, "srm2:TSupportedTransferProtocol"))
						break;
					soap_flag_protocolArray = 0;
				}
				a->protocolArray = (struct srm2__TSupportedTransferProtocol **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_protocolArray && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfTSupportedTransferProtocol *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfTSupportedTransferProtocol, 0, sizeof(struct srm2__ArrayOfTSupportedTransferProtocol), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__TSupportedTransferProtocol(struct soap *soap, const struct srm2__TSupportedTransferProtocol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->transferProtocol);
	soap_serialize_PointerTosrm2__ArrayOfTExtraInfo(soap, &a->attributes);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__TSupportedTransferProtocol(struct soap *soap, struct srm2__TSupportedTransferProtocol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->transferProtocol);
	a->attributes = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__TSupportedTransferProtocol(struct soap *soap, const struct srm2__TSupportedTransferProtocol *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__TSupportedTransferProtocol);
	if (soap_out_srm2__TSupportedTransferProtocol(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__TSupportedTransferProtocol(struct soap *soap, const char *tag, int id, const struct srm2__TSupportedTransferProtocol *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__TSupportedTransferProtocol), type);
	soap_out_string(soap, "transferProtocol", -1, &a->transferProtocol, "");
	soap_out_PointerTosrm2__ArrayOfTExtraInfo(soap, "attributes", -1, &a->attributes, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__TSupportedTransferProtocol * SOAP_FMAC4 soap_get_srm2__TSupportedTransferProtocol(struct soap *soap, struct srm2__TSupportedTransferProtocol *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__TSupportedTransferProtocol(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TSupportedTransferProtocol * SOAP_FMAC4 soap_in_srm2__TSupportedTransferProtocol(struct soap *soap, const char *tag, struct srm2__TSupportedTransferProtocol *a, const char *type)
{
	short soap_flag_transferProtocol = 1, soap_flag_attributes = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__TSupportedTransferProtocol *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__TSupportedTransferProtocol, sizeof(struct srm2__TSupportedTransferProtocol), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__TSupportedTransferProtocol(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_transferProtocol && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "transferProtocol", &a->transferProtocol, "xsd:string"))
				{	soap_flag_transferProtocol--;
					continue;
				}
			if (soap_flag_attributes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTExtraInfo(soap, "attributes", &a->attributes, "srm2:ArrayOfTExtraInfo"))
				{	soap_flag_attributes--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_transferProtocol > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__TSupportedTransferProtocol *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TSupportedTransferProtocol, 0, sizeof(struct srm2__TSupportedTransferProtocol), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__ArrayOfTRequestTokenReturn(struct soap *soap, const struct srm2__ArrayOfTRequestTokenReturn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->tokenArray)
	{	int i;
		for (i = 0; i < a->__sizetokenArray; i++)
		{
			soap_serialize_PointerTosrm2__TRequestTokenReturn(soap, a->tokenArray + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__ArrayOfTRequestTokenReturn(struct soap *soap, struct srm2__ArrayOfTRequestTokenReturn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizetokenArray = 0;
	a->tokenArray = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__ArrayOfTRequestTokenReturn(struct soap *soap, const struct srm2__ArrayOfTRequestTokenReturn *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__ArrayOfTRequestTokenReturn);
	if (soap_out_srm2__ArrayOfTRequestTokenReturn(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__ArrayOfTRequestTokenReturn(struct soap *soap, const char *tag, int id, const struct srm2__ArrayOfTRequestTokenReturn *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__ArrayOfTRequestTokenReturn), type);
	if (a->tokenArray)
	{	int i;
		for (i = 0; i < a->__sizetokenArray; i++)
			soap_out_PointerTosrm2__TRequestTokenReturn(soap, "tokenArray", -1, a->tokenArray + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__ArrayOfTRequestTokenReturn * SOAP_FMAC4 soap_get_srm2__ArrayOfTRequestTokenReturn(struct soap *soap, struct srm2__ArrayOfTRequestTokenReturn *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__ArrayOfTRequestTokenReturn(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfTRequestTokenReturn * SOAP_FMAC4 soap_in_srm2__ArrayOfTRequestTokenReturn(struct soap *soap, const char *tag, struct srm2__ArrayOfTRequestTokenReturn *a, const char *type)
{
	short soap_flag_tokenArray = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__ArrayOfTRequestTokenReturn *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__ArrayOfTRequestTokenReturn, sizeof(struct srm2__ArrayOfTRequestTokenReturn), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__ArrayOfTRequestTokenReturn(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tokenArray && soap->error == SOAP_TAG_MISMATCH)
			{	struct srm2__TRequestTokenReturn **p;
				soap_new_block(soap);
				for (a->__sizetokenArray = 0; !soap_element_begin_in(soap, "tokenArray", 1); a->__sizetokenArray++)
				{	p = (struct srm2__TRequestTokenReturn **)soap_push_block(soap, sizeof(struct srm2__TRequestTokenReturn *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_PointerTosrm2__TRequestTokenReturn(soap, "tokenArray", p, "srm2:TRequestTokenReturn"))
						break;
					soap_flag_tokenArray = 0;
				}
				a->tokenArray = (struct srm2__TRequestTokenReturn **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_tokenArray && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfTRequestTokenReturn *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfTRequestTokenReturn, 0, sizeof(struct srm2__ArrayOfTRequestTokenReturn), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__TRequestTokenReturn(struct soap *soap, const struct srm2__TRequestTokenReturn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_string(soap, &a->createdAtTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__TRequestTokenReturn(struct soap *soap, struct srm2__TRequestTokenReturn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->requestToken);
	soap_default_string(soap, &a->createdAtTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__TRequestTokenReturn(struct soap *soap, const struct srm2__TRequestTokenReturn *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__TRequestTokenReturn);
	if (soap_out_srm2__TRequestTokenReturn(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__TRequestTokenReturn(struct soap *soap, const char *tag, int id, const struct srm2__TRequestTokenReturn *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__TRequestTokenReturn), type);
	soap_out_string(soap, "requestToken", -1, &a->requestToken, "");
	soap_out_string(soap, "createdAtTime", -1, &a->createdAtTime, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__TRequestTokenReturn * SOAP_FMAC4 soap_get_srm2__TRequestTokenReturn(struct soap *soap, struct srm2__TRequestTokenReturn *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__TRequestTokenReturn(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TRequestTokenReturn * SOAP_FMAC4 soap_in_srm2__TRequestTokenReturn(struct soap *soap, const char *tag, struct srm2__TRequestTokenReturn *a, const char *type)
{
	short soap_flag_requestToken = 1, soap_flag_createdAtTime = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__TRequestTokenReturn *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__TRequestTokenReturn, sizeof(struct srm2__TRequestTokenReturn), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__TRequestTokenReturn(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_createdAtTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "createdAtTime", &a->createdAtTime, "xsd:string"))
				{	soap_flag_createdAtTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__TRequestTokenReturn *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TRequestTokenReturn, 0, sizeof(struct srm2__TRequestTokenReturn), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__ArrayOfTPermissionReturn(struct soap *soap, const struct srm2__ArrayOfTPermissionReturn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->permissionArray)
	{	int i;
		for (i = 0; i < a->__sizepermissionArray; i++)
		{
			soap_serialize_PointerTosrm2__TPermissionReturn(soap, a->permissionArray + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__ArrayOfTPermissionReturn(struct soap *soap, struct srm2__ArrayOfTPermissionReturn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizepermissionArray = 0;
	a->permissionArray = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__ArrayOfTPermissionReturn(struct soap *soap, const struct srm2__ArrayOfTPermissionReturn *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__ArrayOfTPermissionReturn);
	if (soap_out_srm2__ArrayOfTPermissionReturn(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__ArrayOfTPermissionReturn(struct soap *soap, const char *tag, int id, const struct srm2__ArrayOfTPermissionReturn *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__ArrayOfTPermissionReturn), type);
	if (a->permissionArray)
	{	int i;
		for (i = 0; i < a->__sizepermissionArray; i++)
			soap_out_PointerTosrm2__TPermissionReturn(soap, "permissionArray", -1, a->permissionArray + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__ArrayOfTPermissionReturn * SOAP_FMAC4 soap_get_srm2__ArrayOfTPermissionReturn(struct soap *soap, struct srm2__ArrayOfTPermissionReturn *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__ArrayOfTPermissionReturn(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfTPermissionReturn * SOAP_FMAC4 soap_in_srm2__ArrayOfTPermissionReturn(struct soap *soap, const char *tag, struct srm2__ArrayOfTPermissionReturn *a, const char *type)
{
	short soap_flag_permissionArray = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__ArrayOfTPermissionReturn *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__ArrayOfTPermissionReturn, sizeof(struct srm2__ArrayOfTPermissionReturn), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__ArrayOfTPermissionReturn(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_permissionArray && soap->error == SOAP_TAG_MISMATCH)
			{	struct srm2__TPermissionReturn **p;
				soap_new_block(soap);
				for (a->__sizepermissionArray = 0; !soap_element_begin_in(soap, "permissionArray", 1); a->__sizepermissionArray++)
				{	p = (struct srm2__TPermissionReturn **)soap_push_block(soap, sizeof(struct srm2__TPermissionReturn *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_PointerTosrm2__TPermissionReturn(soap, "permissionArray", p, "srm2:TPermissionReturn"))
						break;
					soap_flag_permissionArray = 0;
				}
				a->permissionArray = (struct srm2__TPermissionReturn **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_permissionArray && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfTPermissionReturn *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfTPermissionReturn, 0, sizeof(struct srm2__ArrayOfTPermissionReturn), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__TPermissionReturn(struct soap *soap, const struct srm2__TPermissionReturn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->surl);
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->status);
	soap_serialize_string(soap, &a->owner);
	soap_serialize_PointerTosrm2__TPermissionMode(soap, &a->ownerPermission);
	soap_serialize_PointerTosrm2__ArrayOfTUserPermission(soap, &a->arrayOfUserPermissions);
	soap_serialize_PointerTosrm2__ArrayOfTGroupPermission(soap, &a->arrayOfGroupPermissions);
	soap_serialize_PointerTosrm2__TPermissionMode(soap, &a->otherPermission);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__TPermissionReturn(struct soap *soap, struct srm2__TPermissionReturn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->surl);
	a->status = NULL;
	soap_default_string(soap, &a->owner);
	a->ownerPermission = NULL;
	a->arrayOfUserPermissions = NULL;
	a->arrayOfGroupPermissions = NULL;
	a->otherPermission = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__TPermissionReturn(struct soap *soap, const struct srm2__TPermissionReturn *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__TPermissionReturn);
	if (soap_out_srm2__TPermissionReturn(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__TPermissionReturn(struct soap *soap, const char *tag, int id, const struct srm2__TPermissionReturn *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__TPermissionReturn), type);
	soap_out_xsd__anyURI(soap, "surl", -1, &a->surl, "");
	soap_out_PointerTosrm2__TReturnStatus(soap, "status", -1, &a->status, "");
	soap_out_string(soap, "owner", -1, &a->owner, "");
	soap_out_PointerTosrm2__TPermissionMode(soap, "ownerPermission", -1, &a->ownerPermission, "");
	soap_out_PointerTosrm2__ArrayOfTUserPermission(soap, "arrayOfUserPermissions", -1, &a->arrayOfUserPermissions, "");
	soap_out_PointerTosrm2__ArrayOfTGroupPermission(soap, "arrayOfGroupPermissions", -1, &a->arrayOfGroupPermissions, "");
	soap_out_PointerTosrm2__TPermissionMode(soap, "otherPermission", -1, &a->otherPermission, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__TPermissionReturn * SOAP_FMAC4 soap_get_srm2__TPermissionReturn(struct soap *soap, struct srm2__TPermissionReturn *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__TPermissionReturn(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TPermissionReturn * SOAP_FMAC4 soap_in_srm2__TPermissionReturn(struct soap *soap, const char *tag, struct srm2__TPermissionReturn *a, const char *type)
{
	short soap_flag_surl = 1, soap_flag_status = 1, soap_flag_owner = 1, soap_flag_ownerPermission = 1, soap_flag_arrayOfUserPermissions = 1, soap_flag_arrayOfGroupPermissions = 1, soap_flag_otherPermission = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__TPermissionReturn *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__TPermissionReturn, sizeof(struct srm2__TPermissionReturn), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__TPermissionReturn(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_surl && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "surl", &a->surl, "xsd:anyURI"))
				{	soap_flag_surl--;
					continue;
				}
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "status", &a->status, "srm2:TReturnStatus"))
				{	soap_flag_status--;
					continue;
				}
			if (soap_flag_owner && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "owner", &a->owner, "xsd:string"))
				{	soap_flag_owner--;
					continue;
				}
			if (soap_flag_ownerPermission && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TPermissionMode(soap, "ownerPermission", &a->ownerPermission, "srm2:TPermissionMode"))
				{	soap_flag_ownerPermission--;
					continue;
				}
			if (soap_flag_arrayOfUserPermissions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTUserPermission(soap, "arrayOfUserPermissions", &a->arrayOfUserPermissions, "srm2:ArrayOfTUserPermission"))
				{	soap_flag_arrayOfUserPermissions--;
					continue;
				}
			if (soap_flag_arrayOfGroupPermissions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTGroupPermission(soap, "arrayOfGroupPermissions", &a->arrayOfGroupPermissions, "srm2:ArrayOfTGroupPermission"))
				{	soap_flag_arrayOfGroupPermissions--;
					continue;
				}
			if (soap_flag_otherPermission && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TPermissionMode(soap, "otherPermission", &a->otherPermission, "srm2:TPermissionMode"))
				{	soap_flag_otherPermission--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_surl > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__TPermissionReturn *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TPermissionReturn, 0, sizeof(struct srm2__TPermissionReturn), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__ArrayOfTSURLPermissionReturn(struct soap *soap, const struct srm2__ArrayOfTSURLPermissionReturn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->surlPermissionArray)
	{	int i;
		for (i = 0; i < a->__sizesurlPermissionArray; i++)
		{
			soap_serialize_PointerTosrm2__TSURLPermissionReturn(soap, a->surlPermissionArray + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__ArrayOfTSURLPermissionReturn(struct soap *soap, struct srm2__ArrayOfTSURLPermissionReturn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizesurlPermissionArray = 0;
	a->surlPermissionArray = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__ArrayOfTSURLPermissionReturn(struct soap *soap, const struct srm2__ArrayOfTSURLPermissionReturn *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__ArrayOfTSURLPermissionReturn);
	if (soap_out_srm2__ArrayOfTSURLPermissionReturn(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__ArrayOfTSURLPermissionReturn(struct soap *soap, const char *tag, int id, const struct srm2__ArrayOfTSURLPermissionReturn *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__ArrayOfTSURLPermissionReturn), type);
	if (a->surlPermissionArray)
	{	int i;
		for (i = 0; i < a->__sizesurlPermissionArray; i++)
			soap_out_PointerTosrm2__TSURLPermissionReturn(soap, "surlPermissionArray", -1, a->surlPermissionArray + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__ArrayOfTSURLPermissionReturn * SOAP_FMAC4 soap_get_srm2__ArrayOfTSURLPermissionReturn(struct soap *soap, struct srm2__ArrayOfTSURLPermissionReturn *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__ArrayOfTSURLPermissionReturn(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfTSURLPermissionReturn * SOAP_FMAC4 soap_in_srm2__ArrayOfTSURLPermissionReturn(struct soap *soap, const char *tag, struct srm2__ArrayOfTSURLPermissionReturn *a, const char *type)
{
	short soap_flag_surlPermissionArray = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__ArrayOfTSURLPermissionReturn *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__ArrayOfTSURLPermissionReturn, sizeof(struct srm2__ArrayOfTSURLPermissionReturn), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__ArrayOfTSURLPermissionReturn(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_surlPermissionArray && soap->error == SOAP_TAG_MISMATCH)
			{	struct srm2__TSURLPermissionReturn **p;
				soap_new_block(soap);
				for (a->__sizesurlPermissionArray = 0; !soap_element_begin_in(soap, "surlPermissionArray", 1); a->__sizesurlPermissionArray++)
				{	p = (struct srm2__TSURLPermissionReturn **)soap_push_block(soap, sizeof(struct srm2__TSURLPermissionReturn *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_PointerTosrm2__TSURLPermissionReturn(soap, "surlPermissionArray", p, "srm2:TSURLPermissionReturn"))
						break;
					soap_flag_surlPermissionArray = 0;
				}
				a->surlPermissionArray = (struct srm2__TSURLPermissionReturn **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_surlPermissionArray && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfTSURLPermissionReturn *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfTSURLPermissionReturn, 0, sizeof(struct srm2__ArrayOfTSURLPermissionReturn), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__TSURLPermissionReturn(struct soap *soap, const struct srm2__TSURLPermissionReturn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->surl);
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->status);
	soap_serialize_PointerTosrm2__TPermissionMode(soap, &a->permission);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__TSURLPermissionReturn(struct soap *soap, struct srm2__TSURLPermissionReturn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->surl);
	a->status = NULL;
	a->permission = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__TSURLPermissionReturn(struct soap *soap, const struct srm2__TSURLPermissionReturn *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__TSURLPermissionReturn);
	if (soap_out_srm2__TSURLPermissionReturn(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__TSURLPermissionReturn(struct soap *soap, const char *tag, int id, const struct srm2__TSURLPermissionReturn *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__TSURLPermissionReturn), type);
	soap_out_xsd__anyURI(soap, "surl", -1, &a->surl, "");
	soap_out_PointerTosrm2__TReturnStatus(soap, "status", -1, &a->status, "");
	soap_out_PointerTosrm2__TPermissionMode(soap, "permission", -1, &a->permission, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__TSURLPermissionReturn * SOAP_FMAC4 soap_get_srm2__TSURLPermissionReturn(struct soap *soap, struct srm2__TSURLPermissionReturn *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__TSURLPermissionReturn(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TSURLPermissionReturn * SOAP_FMAC4 soap_in_srm2__TSURLPermissionReturn(struct soap *soap, const char *tag, struct srm2__TSURLPermissionReturn *a, const char *type)
{
	short soap_flag_surl = 1, soap_flag_status = 1, soap_flag_permission = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__TSURLPermissionReturn *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__TSURLPermissionReturn, sizeof(struct srm2__TSURLPermissionReturn), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__TSURLPermissionReturn(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_surl && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "surl", &a->surl, "xsd:anyURI"))
				{	soap_flag_surl--;
					continue;
				}
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "status", &a->status, "srm2:TReturnStatus"))
				{	soap_flag_status--;
					continue;
				}
			if (soap_flag_permission && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TPermissionMode(soap, "permission", &a->permission, "srm2:TPermissionMode"))
				{	soap_flag_permission--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_surl > 0 || soap_flag_status > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__TSURLPermissionReturn *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TSURLPermissionReturn, 0, sizeof(struct srm2__TSURLPermissionReturn), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__ArrayOfTRequestSummary(struct soap *soap, const struct srm2__ArrayOfTRequestSummary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->summaryArray)
	{	int i;
		for (i = 0; i < a->__sizesummaryArray; i++)
		{
			soap_serialize_PointerTosrm2__TRequestSummary(soap, a->summaryArray + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__ArrayOfTRequestSummary(struct soap *soap, struct srm2__ArrayOfTRequestSummary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizesummaryArray = 0;
	a->summaryArray = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__ArrayOfTRequestSummary(struct soap *soap, const struct srm2__ArrayOfTRequestSummary *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__ArrayOfTRequestSummary);
	if (soap_out_srm2__ArrayOfTRequestSummary(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__ArrayOfTRequestSummary(struct soap *soap, const char *tag, int id, const struct srm2__ArrayOfTRequestSummary *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__ArrayOfTRequestSummary), type);
	if (a->summaryArray)
	{	int i;
		for (i = 0; i < a->__sizesummaryArray; i++)
			soap_out_PointerTosrm2__TRequestSummary(soap, "summaryArray", -1, a->summaryArray + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__ArrayOfTRequestSummary * SOAP_FMAC4 soap_get_srm2__ArrayOfTRequestSummary(struct soap *soap, struct srm2__ArrayOfTRequestSummary *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__ArrayOfTRequestSummary(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfTRequestSummary * SOAP_FMAC4 soap_in_srm2__ArrayOfTRequestSummary(struct soap *soap, const char *tag, struct srm2__ArrayOfTRequestSummary *a, const char *type)
{
	short soap_flag_summaryArray = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__ArrayOfTRequestSummary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__ArrayOfTRequestSummary, sizeof(struct srm2__ArrayOfTRequestSummary), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__ArrayOfTRequestSummary(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_summaryArray && soap->error == SOAP_TAG_MISMATCH)
			{	struct srm2__TRequestSummary **p;
				soap_new_block(soap);
				for (a->__sizesummaryArray = 0; !soap_element_begin_in(soap, "summaryArray", 1); a->__sizesummaryArray++)
				{	p = (struct srm2__TRequestSummary **)soap_push_block(soap, sizeof(struct srm2__TRequestSummary *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_PointerTosrm2__TRequestSummary(soap, "summaryArray", p, "srm2:TRequestSummary"))
						break;
					soap_flag_summaryArray = 0;
				}
				a->summaryArray = (struct srm2__TRequestSummary **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_summaryArray && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfTRequestSummary *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfTRequestSummary, 0, sizeof(struct srm2__ArrayOfTRequestSummary), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__TRequestSummary(struct soap *soap, const struct srm2__TRequestSummary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->requestToken);
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->status);
	soap_serialize_PointerTosrm2__TRequestType(soap, &a->requestType);
	soap_serialize_PointerToint(soap, &a->totalNumFilesInRequest);
	soap_serialize_PointerToint(soap, &a->numOfCompletedFiles);
	soap_serialize_PointerToint(soap, &a->numOfWaitingFiles);
	soap_serialize_PointerToint(soap, &a->numOfFailedFiles);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__TRequestSummary(struct soap *soap, struct srm2__TRequestSummary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->requestToken);
	a->status = NULL;
	a->requestType = NULL;
	a->totalNumFilesInRequest = NULL;
	a->numOfCompletedFiles = NULL;
	a->numOfWaitingFiles = NULL;
	a->numOfFailedFiles = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__TRequestSummary(struct soap *soap, const struct srm2__TRequestSummary *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__TRequestSummary);
	if (soap_out_srm2__TRequestSummary(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__TRequestSummary(struct soap *soap, const char *tag, int id, const struct srm2__TRequestSummary *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__TRequestSummary), type);
	soap_out_string(soap, "requestToken", -1, &a->requestToken, "");
	soap_out_PointerTosrm2__TReturnStatus(soap, "status", -1, &a->status, "");
	soap_out_PointerTosrm2__TRequestType(soap, "requestType", -1, &a->requestType, "");
	soap_out_PointerToint(soap, "totalNumFilesInRequest", -1, &a->totalNumFilesInRequest, "");
	soap_out_PointerToint(soap, "numOfCompletedFiles", -1, &a->numOfCompletedFiles, "");
	soap_out_PointerToint(soap, "numOfWaitingFiles", -1, &a->numOfWaitingFiles, "");
	soap_out_PointerToint(soap, "numOfFailedFiles", -1, &a->numOfFailedFiles, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__TRequestSummary * SOAP_FMAC4 soap_get_srm2__TRequestSummary(struct soap *soap, struct srm2__TRequestSummary *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__TRequestSummary(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TRequestSummary * SOAP_FMAC4 soap_in_srm2__TRequestSummary(struct soap *soap, const char *tag, struct srm2__TRequestSummary *a, const char *type)
{
	short soap_flag_requestToken = 1, soap_flag_status = 1, soap_flag_requestType = 1, soap_flag_totalNumFilesInRequest = 1, soap_flag_numOfCompletedFiles = 1, soap_flag_numOfWaitingFiles = 1, soap_flag_numOfFailedFiles = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__TRequestSummary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__TRequestSummary, sizeof(struct srm2__TRequestSummary), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__TRequestSummary(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestToken", &a->requestToken, "xsd:string"))
				{	soap_flag_requestToken--;
					continue;
				}
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "status", &a->status, "srm2:TReturnStatus"))
				{	soap_flag_status--;
					continue;
				}
			if (soap_flag_requestType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TRequestType(soap, "requestType", &a->requestType, "srm2:TRequestType"))
				{	soap_flag_requestType--;
					continue;
				}
			if (soap_flag_totalNumFilesInRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "totalNumFilesInRequest", &a->totalNumFilesInRequest, "xsd:int"))
				{	soap_flag_totalNumFilesInRequest--;
					continue;
				}
			if (soap_flag_numOfCompletedFiles && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "numOfCompletedFiles", &a->numOfCompletedFiles, "xsd:int"))
				{	soap_flag_numOfCompletedFiles--;
					continue;
				}
			if (soap_flag_numOfWaitingFiles && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "numOfWaitingFiles", &a->numOfWaitingFiles, "xsd:int"))
				{	soap_flag_numOfWaitingFiles--;
					continue;
				}
			if (soap_flag_numOfFailedFiles && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "numOfFailedFiles", &a->numOfFailedFiles, "xsd:int"))
				{	soap_flag_numOfFailedFiles--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestToken > 0 || soap_flag_status > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__TRequestSummary *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TRequestSummary, 0, sizeof(struct srm2__TRequestSummary), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__ArrayOfTCopyRequestFileStatus(struct soap *soap, const struct srm2__ArrayOfTCopyRequestFileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->statusArray)
	{	int i;
		for (i = 0; i < a->__sizestatusArray; i++)
		{
			soap_serialize_PointerTosrm2__TCopyRequestFileStatus(soap, a->statusArray + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__ArrayOfTCopyRequestFileStatus(struct soap *soap, struct srm2__ArrayOfTCopyRequestFileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizestatusArray = 0;
	a->statusArray = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__ArrayOfTCopyRequestFileStatus(struct soap *soap, const struct srm2__ArrayOfTCopyRequestFileStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__ArrayOfTCopyRequestFileStatus);
	if (soap_out_srm2__ArrayOfTCopyRequestFileStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__ArrayOfTCopyRequestFileStatus(struct soap *soap, const char *tag, int id, const struct srm2__ArrayOfTCopyRequestFileStatus *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__ArrayOfTCopyRequestFileStatus), type);
	if (a->statusArray)
	{	int i;
		for (i = 0; i < a->__sizestatusArray; i++)
			soap_out_PointerTosrm2__TCopyRequestFileStatus(soap, "statusArray", -1, a->statusArray + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__ArrayOfTCopyRequestFileStatus * SOAP_FMAC4 soap_get_srm2__ArrayOfTCopyRequestFileStatus(struct soap *soap, struct srm2__ArrayOfTCopyRequestFileStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__ArrayOfTCopyRequestFileStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfTCopyRequestFileStatus * SOAP_FMAC4 soap_in_srm2__ArrayOfTCopyRequestFileStatus(struct soap *soap, const char *tag, struct srm2__ArrayOfTCopyRequestFileStatus *a, const char *type)
{
	short soap_flag_statusArray = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__ArrayOfTCopyRequestFileStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__ArrayOfTCopyRequestFileStatus, sizeof(struct srm2__ArrayOfTCopyRequestFileStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__ArrayOfTCopyRequestFileStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusArray && soap->error == SOAP_TAG_MISMATCH)
			{	struct srm2__TCopyRequestFileStatus **p;
				soap_new_block(soap);
				for (a->__sizestatusArray = 0; !soap_element_begin_in(soap, "statusArray", 1); a->__sizestatusArray++)
				{	p = (struct srm2__TCopyRequestFileStatus **)soap_push_block(soap, sizeof(struct srm2__TCopyRequestFileStatus *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_PointerTosrm2__TCopyRequestFileStatus(soap, "statusArray", p, "srm2:TCopyRequestFileStatus"))
						break;
					soap_flag_statusArray = 0;
				}
				a->statusArray = (struct srm2__TCopyRequestFileStatus **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_statusArray && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfTCopyRequestFileStatus *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfTCopyRequestFileStatus, 0, sizeof(struct srm2__ArrayOfTCopyRequestFileStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__TCopyRequestFileStatus(struct soap *soap, const struct srm2__TCopyRequestFileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->sourceSURL);
	soap_serialize_xsd__anyURI(soap, &a->targetSURL);
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->status);
	soap_serialize_PointerTounsignedLONG64(soap, &a->fileSize);
	soap_serialize_PointerToint(soap, &a->estimatedWaitTime);
	soap_serialize_PointerToint(soap, &a->remainingFileLifetime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__TCopyRequestFileStatus(struct soap *soap, struct srm2__TCopyRequestFileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->sourceSURL);
	soap_default_xsd__anyURI(soap, &a->targetSURL);
	a->status = NULL;
	a->fileSize = NULL;
	a->estimatedWaitTime = NULL;
	a->remainingFileLifetime = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__TCopyRequestFileStatus(struct soap *soap, const struct srm2__TCopyRequestFileStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__TCopyRequestFileStatus);
	if (soap_out_srm2__TCopyRequestFileStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__TCopyRequestFileStatus(struct soap *soap, const char *tag, int id, const struct srm2__TCopyRequestFileStatus *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__TCopyRequestFileStatus), type);
	soap_out_xsd__anyURI(soap, "sourceSURL", -1, &a->sourceSURL, "");
	soap_out_xsd__anyURI(soap, "targetSURL", -1, &a->targetSURL, "");
	soap_out_PointerTosrm2__TReturnStatus(soap, "status", -1, &a->status, "");
	soap_out_PointerTounsignedLONG64(soap, "fileSize", -1, &a->fileSize, "");
	soap_out_PointerToint(soap, "estimatedWaitTime", -1, &a->estimatedWaitTime, "");
	soap_out_PointerToint(soap, "remainingFileLifetime", -1, &a->remainingFileLifetime, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__TCopyRequestFileStatus * SOAP_FMAC4 soap_get_srm2__TCopyRequestFileStatus(struct soap *soap, struct srm2__TCopyRequestFileStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__TCopyRequestFileStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TCopyRequestFileStatus * SOAP_FMAC4 soap_in_srm2__TCopyRequestFileStatus(struct soap *soap, const char *tag, struct srm2__TCopyRequestFileStatus *a, const char *type)
{
	short soap_flag_sourceSURL = 1, soap_flag_targetSURL = 1, soap_flag_status = 1, soap_flag_fileSize = 1, soap_flag_estimatedWaitTime = 1, soap_flag_remainingFileLifetime = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__TCopyRequestFileStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__TCopyRequestFileStatus, sizeof(struct srm2__TCopyRequestFileStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__TCopyRequestFileStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sourceSURL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "sourceSURL", &a->sourceSURL, "xsd:anyURI"))
				{	soap_flag_sourceSURL--;
					continue;
				}
			if (soap_flag_targetSURL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "targetSURL", &a->targetSURL, "xsd:anyURI"))
				{	soap_flag_targetSURL--;
					continue;
				}
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "status", &a->status, "srm2:TReturnStatus"))
				{	soap_flag_status--;
					continue;
				}
			if (soap_flag_fileSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "fileSize", &a->fileSize, "xsd:unsignedLong"))
				{	soap_flag_fileSize--;
					continue;
				}
			if (soap_flag_estimatedWaitTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "estimatedWaitTime", &a->estimatedWaitTime, "xsd:int"))
				{	soap_flag_estimatedWaitTime--;
					continue;
				}
			if (soap_flag_remainingFileLifetime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "remainingFileLifetime", &a->remainingFileLifetime, "xsd:int"))
				{	soap_flag_remainingFileLifetime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sourceSURL > 0 || soap_flag_targetSURL > 0 || soap_flag_status > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__TCopyRequestFileStatus *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TCopyRequestFileStatus, 0, sizeof(struct srm2__TCopyRequestFileStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__ArrayOfTPutRequestFileStatus(struct soap *soap, const struct srm2__ArrayOfTPutRequestFileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->statusArray)
	{	int i;
		for (i = 0; i < a->__sizestatusArray; i++)
		{
			soap_serialize_PointerTosrm2__TPutRequestFileStatus(soap, a->statusArray + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__ArrayOfTPutRequestFileStatus(struct soap *soap, struct srm2__ArrayOfTPutRequestFileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizestatusArray = 0;
	a->statusArray = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__ArrayOfTPutRequestFileStatus(struct soap *soap, const struct srm2__ArrayOfTPutRequestFileStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__ArrayOfTPutRequestFileStatus);
	if (soap_out_srm2__ArrayOfTPutRequestFileStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__ArrayOfTPutRequestFileStatus(struct soap *soap, const char *tag, int id, const struct srm2__ArrayOfTPutRequestFileStatus *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__ArrayOfTPutRequestFileStatus), type);
	if (a->statusArray)
	{	int i;
		for (i = 0; i < a->__sizestatusArray; i++)
			soap_out_PointerTosrm2__TPutRequestFileStatus(soap, "statusArray", -1, a->statusArray + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__ArrayOfTPutRequestFileStatus * SOAP_FMAC4 soap_get_srm2__ArrayOfTPutRequestFileStatus(struct soap *soap, struct srm2__ArrayOfTPutRequestFileStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__ArrayOfTPutRequestFileStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfTPutRequestFileStatus * SOAP_FMAC4 soap_in_srm2__ArrayOfTPutRequestFileStatus(struct soap *soap, const char *tag, struct srm2__ArrayOfTPutRequestFileStatus *a, const char *type)
{
	short soap_flag_statusArray = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__ArrayOfTPutRequestFileStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__ArrayOfTPutRequestFileStatus, sizeof(struct srm2__ArrayOfTPutRequestFileStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__ArrayOfTPutRequestFileStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusArray && soap->error == SOAP_TAG_MISMATCH)
			{	struct srm2__TPutRequestFileStatus **p;
				soap_new_block(soap);
				for (a->__sizestatusArray = 0; !soap_element_begin_in(soap, "statusArray", 1); a->__sizestatusArray++)
				{	p = (struct srm2__TPutRequestFileStatus **)soap_push_block(soap, sizeof(struct srm2__TPutRequestFileStatus *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_PointerTosrm2__TPutRequestFileStatus(soap, "statusArray", p, "srm2:TPutRequestFileStatus"))
						break;
					soap_flag_statusArray = 0;
				}
				a->statusArray = (struct srm2__TPutRequestFileStatus **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_statusArray && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfTPutRequestFileStatus *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfTPutRequestFileStatus, 0, sizeof(struct srm2__ArrayOfTPutRequestFileStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__TPutRequestFileStatus(struct soap *soap, const struct srm2__TPutRequestFileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->SURL);
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->status);
	soap_serialize_PointerTounsignedLONG64(soap, &a->fileSize);
	soap_serialize_PointerToint(soap, &a->estimatedWaitTime);
	soap_serialize_PointerToint(soap, &a->remainingPinLifetime);
	soap_serialize_PointerToint(soap, &a->remainingFileLifetime);
	soap_serialize_xsd__anyURI(soap, &a->transferURL);
	soap_serialize_PointerTosrm2__ArrayOfTExtraInfo(soap, &a->transferProtocolInfo);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__TPutRequestFileStatus(struct soap *soap, struct srm2__TPutRequestFileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->SURL);
	a->status = NULL;
	a->fileSize = NULL;
	a->estimatedWaitTime = NULL;
	a->remainingPinLifetime = NULL;
	a->remainingFileLifetime = NULL;
	soap_default_xsd__anyURI(soap, &a->transferURL);
	a->transferProtocolInfo = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__TPutRequestFileStatus(struct soap *soap, const struct srm2__TPutRequestFileStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__TPutRequestFileStatus);
	if (soap_out_srm2__TPutRequestFileStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__TPutRequestFileStatus(struct soap *soap, const char *tag, int id, const struct srm2__TPutRequestFileStatus *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__TPutRequestFileStatus), type);
	soap_out_xsd__anyURI(soap, "SURL", -1, &a->SURL, "");
	soap_out_PointerTosrm2__TReturnStatus(soap, "status", -1, &a->status, "");
	soap_out_PointerTounsignedLONG64(soap, "fileSize", -1, &a->fileSize, "");
	soap_out_PointerToint(soap, "estimatedWaitTime", -1, &a->estimatedWaitTime, "");
	soap_out_PointerToint(soap, "remainingPinLifetime", -1, &a->remainingPinLifetime, "");
	soap_out_PointerToint(soap, "remainingFileLifetime", -1, &a->remainingFileLifetime, "");
	soap_out_xsd__anyURI(soap, "transferURL", -1, &a->transferURL, "");
	soap_out_PointerTosrm2__ArrayOfTExtraInfo(soap, "transferProtocolInfo", -1, &a->transferProtocolInfo, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__TPutRequestFileStatus * SOAP_FMAC4 soap_get_srm2__TPutRequestFileStatus(struct soap *soap, struct srm2__TPutRequestFileStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__TPutRequestFileStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TPutRequestFileStatus * SOAP_FMAC4 soap_in_srm2__TPutRequestFileStatus(struct soap *soap, const char *tag, struct srm2__TPutRequestFileStatus *a, const char *type)
{
	short soap_flag_SURL = 1, soap_flag_status = 1, soap_flag_fileSize = 1, soap_flag_estimatedWaitTime = 1, soap_flag_remainingPinLifetime = 1, soap_flag_remainingFileLifetime = 1, soap_flag_transferURL = 1, soap_flag_transferProtocolInfo = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__TPutRequestFileStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__TPutRequestFileStatus, sizeof(struct srm2__TPutRequestFileStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__TPutRequestFileStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SURL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "SURL", &a->SURL, "xsd:anyURI"))
				{	soap_flag_SURL--;
					continue;
				}
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "status", &a->status, "srm2:TReturnStatus"))
				{	soap_flag_status--;
					continue;
				}
			if (soap_flag_fileSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "fileSize", &a->fileSize, "xsd:unsignedLong"))
				{	soap_flag_fileSize--;
					continue;
				}
			if (soap_flag_estimatedWaitTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "estimatedWaitTime", &a->estimatedWaitTime, "xsd:int"))
				{	soap_flag_estimatedWaitTime--;
					continue;
				}
			if (soap_flag_remainingPinLifetime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "remainingPinLifetime", &a->remainingPinLifetime, "xsd:int"))
				{	soap_flag_remainingPinLifetime--;
					continue;
				}
			if (soap_flag_remainingFileLifetime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "remainingFileLifetime", &a->remainingFileLifetime, "xsd:int"))
				{	soap_flag_remainingFileLifetime--;
					continue;
				}
			if (soap_flag_transferURL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "transferURL", &a->transferURL, "xsd:anyURI"))
				{	soap_flag_transferURL--;
					continue;
				}
			if (soap_flag_transferProtocolInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTExtraInfo(soap, "transferProtocolInfo", &a->transferProtocolInfo, "srm2:ArrayOfTExtraInfo"))
				{	soap_flag_transferProtocolInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SURL > 0 || soap_flag_status > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__TPutRequestFileStatus *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TPutRequestFileStatus, 0, sizeof(struct srm2__TPutRequestFileStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__ArrayOfTBringOnlineRequestFileStatus(struct soap *soap, const struct srm2__ArrayOfTBringOnlineRequestFileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->statusArray)
	{	int i;
		for (i = 0; i < a->__sizestatusArray; i++)
		{
			soap_serialize_PointerTosrm2__TBringOnlineRequestFileStatus(soap, a->statusArray + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__ArrayOfTBringOnlineRequestFileStatus(struct soap *soap, struct srm2__ArrayOfTBringOnlineRequestFileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizestatusArray = 0;
	a->statusArray = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__ArrayOfTBringOnlineRequestFileStatus(struct soap *soap, const struct srm2__ArrayOfTBringOnlineRequestFileStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__ArrayOfTBringOnlineRequestFileStatus);
	if (soap_out_srm2__ArrayOfTBringOnlineRequestFileStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__ArrayOfTBringOnlineRequestFileStatus(struct soap *soap, const char *tag, int id, const struct srm2__ArrayOfTBringOnlineRequestFileStatus *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__ArrayOfTBringOnlineRequestFileStatus), type);
	if (a->statusArray)
	{	int i;
		for (i = 0; i < a->__sizestatusArray; i++)
			soap_out_PointerTosrm2__TBringOnlineRequestFileStatus(soap, "statusArray", -1, a->statusArray + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__ArrayOfTBringOnlineRequestFileStatus * SOAP_FMAC4 soap_get_srm2__ArrayOfTBringOnlineRequestFileStatus(struct soap *soap, struct srm2__ArrayOfTBringOnlineRequestFileStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__ArrayOfTBringOnlineRequestFileStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfTBringOnlineRequestFileStatus * SOAP_FMAC4 soap_in_srm2__ArrayOfTBringOnlineRequestFileStatus(struct soap *soap, const char *tag, struct srm2__ArrayOfTBringOnlineRequestFileStatus *a, const char *type)
{
	short soap_flag_statusArray = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__ArrayOfTBringOnlineRequestFileStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__ArrayOfTBringOnlineRequestFileStatus, sizeof(struct srm2__ArrayOfTBringOnlineRequestFileStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__ArrayOfTBringOnlineRequestFileStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusArray && soap->error == SOAP_TAG_MISMATCH)
			{	struct srm2__TBringOnlineRequestFileStatus **p;
				soap_new_block(soap);
				for (a->__sizestatusArray = 0; !soap_element_begin_in(soap, "statusArray", 1); a->__sizestatusArray++)
				{	p = (struct srm2__TBringOnlineRequestFileStatus **)soap_push_block(soap, sizeof(struct srm2__TBringOnlineRequestFileStatus *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_PointerTosrm2__TBringOnlineRequestFileStatus(soap, "statusArray", p, "srm2:TBringOnlineRequestFileStatus"))
						break;
					soap_flag_statusArray = 0;
				}
				a->statusArray = (struct srm2__TBringOnlineRequestFileStatus **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_statusArray && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfTBringOnlineRequestFileStatus *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfTBringOnlineRequestFileStatus, 0, sizeof(struct srm2__ArrayOfTBringOnlineRequestFileStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__TBringOnlineRequestFileStatus(struct soap *soap, const struct srm2__TBringOnlineRequestFileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->sourceSURL);
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->status);
	soap_serialize_PointerTounsignedLONG64(soap, &a->fileSize);
	soap_serialize_PointerToint(soap, &a->estimatedWaitTime);
	soap_serialize_PointerToint(soap, &a->remainingPinTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__TBringOnlineRequestFileStatus(struct soap *soap, struct srm2__TBringOnlineRequestFileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->sourceSURL);
	a->status = NULL;
	a->fileSize = NULL;
	a->estimatedWaitTime = NULL;
	a->remainingPinTime = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__TBringOnlineRequestFileStatus(struct soap *soap, const struct srm2__TBringOnlineRequestFileStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__TBringOnlineRequestFileStatus);
	if (soap_out_srm2__TBringOnlineRequestFileStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__TBringOnlineRequestFileStatus(struct soap *soap, const char *tag, int id, const struct srm2__TBringOnlineRequestFileStatus *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__TBringOnlineRequestFileStatus), type);
	soap_out_xsd__anyURI(soap, "sourceSURL", -1, &a->sourceSURL, "");
	soap_out_PointerTosrm2__TReturnStatus(soap, "status", -1, &a->status, "");
	soap_out_PointerTounsignedLONG64(soap, "fileSize", -1, &a->fileSize, "");
	soap_out_PointerToint(soap, "estimatedWaitTime", -1, &a->estimatedWaitTime, "");
	soap_out_PointerToint(soap, "remainingPinTime", -1, &a->remainingPinTime, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__TBringOnlineRequestFileStatus * SOAP_FMAC4 soap_get_srm2__TBringOnlineRequestFileStatus(struct soap *soap, struct srm2__TBringOnlineRequestFileStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__TBringOnlineRequestFileStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TBringOnlineRequestFileStatus * SOAP_FMAC4 soap_in_srm2__TBringOnlineRequestFileStatus(struct soap *soap, const char *tag, struct srm2__TBringOnlineRequestFileStatus *a, const char *type)
{
	short soap_flag_sourceSURL = 1, soap_flag_status = 1, soap_flag_fileSize = 1, soap_flag_estimatedWaitTime = 1, soap_flag_remainingPinTime = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__TBringOnlineRequestFileStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__TBringOnlineRequestFileStatus, sizeof(struct srm2__TBringOnlineRequestFileStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__TBringOnlineRequestFileStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sourceSURL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "sourceSURL", &a->sourceSURL, "xsd:anyURI"))
				{	soap_flag_sourceSURL--;
					continue;
				}
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "status", &a->status, "srm2:TReturnStatus"))
				{	soap_flag_status--;
					continue;
				}
			if (soap_flag_fileSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "fileSize", &a->fileSize, "xsd:unsignedLong"))
				{	soap_flag_fileSize--;
					continue;
				}
			if (soap_flag_estimatedWaitTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "estimatedWaitTime", &a->estimatedWaitTime, "xsd:int"))
				{	soap_flag_estimatedWaitTime--;
					continue;
				}
			if (soap_flag_remainingPinTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "remainingPinTime", &a->remainingPinTime, "xsd:int"))
				{	soap_flag_remainingPinTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sourceSURL > 0 || soap_flag_status > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__TBringOnlineRequestFileStatus *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TBringOnlineRequestFileStatus, 0, sizeof(struct srm2__TBringOnlineRequestFileStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__ArrayOfTGetRequestFileStatus(struct soap *soap, const struct srm2__ArrayOfTGetRequestFileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->statusArray)
	{	int i;
		for (i = 0; i < a->__sizestatusArray; i++)
		{
			soap_serialize_PointerTosrm2__TGetRequestFileStatus(soap, a->statusArray + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__ArrayOfTGetRequestFileStatus(struct soap *soap, struct srm2__ArrayOfTGetRequestFileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizestatusArray = 0;
	a->statusArray = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__ArrayOfTGetRequestFileStatus(struct soap *soap, const struct srm2__ArrayOfTGetRequestFileStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__ArrayOfTGetRequestFileStatus);
	if (soap_out_srm2__ArrayOfTGetRequestFileStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__ArrayOfTGetRequestFileStatus(struct soap *soap, const char *tag, int id, const struct srm2__ArrayOfTGetRequestFileStatus *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__ArrayOfTGetRequestFileStatus), type);
	if (a->statusArray)
	{	int i;
		for (i = 0; i < a->__sizestatusArray; i++)
			soap_out_PointerTosrm2__TGetRequestFileStatus(soap, "statusArray", -1, a->statusArray + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__ArrayOfTGetRequestFileStatus * SOAP_FMAC4 soap_get_srm2__ArrayOfTGetRequestFileStatus(struct soap *soap, struct srm2__ArrayOfTGetRequestFileStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__ArrayOfTGetRequestFileStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfTGetRequestFileStatus * SOAP_FMAC4 soap_in_srm2__ArrayOfTGetRequestFileStatus(struct soap *soap, const char *tag, struct srm2__ArrayOfTGetRequestFileStatus *a, const char *type)
{
	short soap_flag_statusArray = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__ArrayOfTGetRequestFileStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__ArrayOfTGetRequestFileStatus, sizeof(struct srm2__ArrayOfTGetRequestFileStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__ArrayOfTGetRequestFileStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusArray && soap->error == SOAP_TAG_MISMATCH)
			{	struct srm2__TGetRequestFileStatus **p;
				soap_new_block(soap);
				for (a->__sizestatusArray = 0; !soap_element_begin_in(soap, "statusArray", 1); a->__sizestatusArray++)
				{	p = (struct srm2__TGetRequestFileStatus **)soap_push_block(soap, sizeof(struct srm2__TGetRequestFileStatus *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_PointerTosrm2__TGetRequestFileStatus(soap, "statusArray", p, "srm2:TGetRequestFileStatus"))
						break;
					soap_flag_statusArray = 0;
				}
				a->statusArray = (struct srm2__TGetRequestFileStatus **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_statusArray && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfTGetRequestFileStatus *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfTGetRequestFileStatus, 0, sizeof(struct srm2__ArrayOfTGetRequestFileStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__TGetRequestFileStatus(struct soap *soap, const struct srm2__TGetRequestFileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->sourceSURL);
	soap_serialize_PointerTounsignedLONG64(soap, &a->fileSize);
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->status);
	soap_serialize_PointerToint(soap, &a->estimatedWaitTime);
	soap_serialize_PointerToint(soap, &a->remainingPinTime);
	soap_serialize_xsd__anyURI(soap, &a->transferURL);
	soap_serialize_PointerTosrm2__ArrayOfTExtraInfo(soap, &a->transferProtocolInfo);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__TGetRequestFileStatus(struct soap *soap, struct srm2__TGetRequestFileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->sourceSURL);
	a->fileSize = NULL;
	a->status = NULL;
	a->estimatedWaitTime = NULL;
	a->remainingPinTime = NULL;
	soap_default_xsd__anyURI(soap, &a->transferURL);
	a->transferProtocolInfo = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__TGetRequestFileStatus(struct soap *soap, const struct srm2__TGetRequestFileStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__TGetRequestFileStatus);
	if (soap_out_srm2__TGetRequestFileStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__TGetRequestFileStatus(struct soap *soap, const char *tag, int id, const struct srm2__TGetRequestFileStatus *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__TGetRequestFileStatus), type);
	soap_out_xsd__anyURI(soap, "sourceSURL", -1, &a->sourceSURL, "");
	soap_out_PointerTounsignedLONG64(soap, "fileSize", -1, &a->fileSize, "");
	soap_out_PointerTosrm2__TReturnStatus(soap, "status", -1, &a->status, "");
	soap_out_PointerToint(soap, "estimatedWaitTime", -1, &a->estimatedWaitTime, "");
	soap_out_PointerToint(soap, "remainingPinTime", -1, &a->remainingPinTime, "");
	soap_out_xsd__anyURI(soap, "transferURL", -1, &a->transferURL, "");
	soap_out_PointerTosrm2__ArrayOfTExtraInfo(soap, "transferProtocolInfo", -1, &a->transferProtocolInfo, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__TGetRequestFileStatus * SOAP_FMAC4 soap_get_srm2__TGetRequestFileStatus(struct soap *soap, struct srm2__TGetRequestFileStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__TGetRequestFileStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TGetRequestFileStatus * SOAP_FMAC4 soap_in_srm2__TGetRequestFileStatus(struct soap *soap, const char *tag, struct srm2__TGetRequestFileStatus *a, const char *type)
{
	short soap_flag_sourceSURL = 1, soap_flag_fileSize = 1, soap_flag_status = 1, soap_flag_estimatedWaitTime = 1, soap_flag_remainingPinTime = 1, soap_flag_transferURL = 1, soap_flag_transferProtocolInfo = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__TGetRequestFileStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__TGetRequestFileStatus, sizeof(struct srm2__TGetRequestFileStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__TGetRequestFileStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sourceSURL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "sourceSURL", &a->sourceSURL, "xsd:anyURI"))
				{	soap_flag_sourceSURL--;
					continue;
				}
			if (soap_flag_fileSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "fileSize", &a->fileSize, "xsd:unsignedLong"))
				{	soap_flag_fileSize--;
					continue;
				}
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "status", &a->status, "srm2:TReturnStatus"))
				{	soap_flag_status--;
					continue;
				}
			if (soap_flag_estimatedWaitTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "estimatedWaitTime", &a->estimatedWaitTime, "xsd:int"))
				{	soap_flag_estimatedWaitTime--;
					continue;
				}
			if (soap_flag_remainingPinTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "remainingPinTime", &a->remainingPinTime, "xsd:int"))
				{	soap_flag_remainingPinTime--;
					continue;
				}
			if (soap_flag_transferURL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "transferURL", &a->transferURL, "xsd:anyURI"))
				{	soap_flag_transferURL--;
					continue;
				}
			if (soap_flag_transferProtocolInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTExtraInfo(soap, "transferProtocolInfo", &a->transferProtocolInfo, "srm2:ArrayOfTExtraInfo"))
				{	soap_flag_transferProtocolInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sourceSURL > 0 || soap_flag_status > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__TGetRequestFileStatus *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TGetRequestFileStatus, 0, sizeof(struct srm2__TGetRequestFileStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__ArrayOfTCopyFileRequest(struct soap *soap, const struct srm2__ArrayOfTCopyFileRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->requestArray)
	{	int i;
		for (i = 0; i < a->__sizerequestArray; i++)
		{
			soap_serialize_PointerTosrm2__TCopyFileRequest(soap, a->requestArray + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__ArrayOfTCopyFileRequest(struct soap *soap, struct srm2__ArrayOfTCopyFileRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizerequestArray = 0;
	a->requestArray = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__ArrayOfTCopyFileRequest(struct soap *soap, const struct srm2__ArrayOfTCopyFileRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__ArrayOfTCopyFileRequest);
	if (soap_out_srm2__ArrayOfTCopyFileRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__ArrayOfTCopyFileRequest(struct soap *soap, const char *tag, int id, const struct srm2__ArrayOfTCopyFileRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__ArrayOfTCopyFileRequest), type);
	if (a->requestArray)
	{	int i;
		for (i = 0; i < a->__sizerequestArray; i++)
			soap_out_PointerTosrm2__TCopyFileRequest(soap, "requestArray", -1, a->requestArray + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__ArrayOfTCopyFileRequest * SOAP_FMAC4 soap_get_srm2__ArrayOfTCopyFileRequest(struct soap *soap, struct srm2__ArrayOfTCopyFileRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__ArrayOfTCopyFileRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfTCopyFileRequest * SOAP_FMAC4 soap_in_srm2__ArrayOfTCopyFileRequest(struct soap *soap, const char *tag, struct srm2__ArrayOfTCopyFileRequest *a, const char *type)
{
	short soap_flag_requestArray = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__ArrayOfTCopyFileRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__ArrayOfTCopyFileRequest, sizeof(struct srm2__ArrayOfTCopyFileRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__ArrayOfTCopyFileRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestArray && soap->error == SOAP_TAG_MISMATCH)
			{	struct srm2__TCopyFileRequest **p;
				soap_new_block(soap);
				for (a->__sizerequestArray = 0; !soap_element_begin_in(soap, "requestArray", 1); a->__sizerequestArray++)
				{	p = (struct srm2__TCopyFileRequest **)soap_push_block(soap, sizeof(struct srm2__TCopyFileRequest *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_PointerTosrm2__TCopyFileRequest(soap, "requestArray", p, "srm2:TCopyFileRequest"))
						break;
					soap_flag_requestArray = 0;
				}
				a->requestArray = (struct srm2__TCopyFileRequest **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_requestArray && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfTCopyFileRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfTCopyFileRequest, 0, sizeof(struct srm2__ArrayOfTCopyFileRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__TCopyFileRequest(struct soap *soap, const struct srm2__TCopyFileRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->sourceSURL);
	soap_serialize_xsd__anyURI(soap, &a->targetSURL);
	soap_serialize_PointerTosrm2__TDirOption(soap, &a->dirOption);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__TCopyFileRequest(struct soap *soap, struct srm2__TCopyFileRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->sourceSURL);
	soap_default_xsd__anyURI(soap, &a->targetSURL);
	a->dirOption = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__TCopyFileRequest(struct soap *soap, const struct srm2__TCopyFileRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__TCopyFileRequest);
	if (soap_out_srm2__TCopyFileRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__TCopyFileRequest(struct soap *soap, const char *tag, int id, const struct srm2__TCopyFileRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__TCopyFileRequest), type);
	soap_out_xsd__anyURI(soap, "sourceSURL", -1, &a->sourceSURL, "");
	soap_out_xsd__anyURI(soap, "targetSURL", -1, &a->targetSURL, "");
	soap_out_PointerTosrm2__TDirOption(soap, "dirOption", -1, &a->dirOption, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__TCopyFileRequest * SOAP_FMAC4 soap_get_srm2__TCopyFileRequest(struct soap *soap, struct srm2__TCopyFileRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__TCopyFileRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TCopyFileRequest * SOAP_FMAC4 soap_in_srm2__TCopyFileRequest(struct soap *soap, const char *tag, struct srm2__TCopyFileRequest *a, const char *type)
{
	short soap_flag_sourceSURL = 1, soap_flag_targetSURL = 1, soap_flag_dirOption = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__TCopyFileRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__TCopyFileRequest, sizeof(struct srm2__TCopyFileRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__TCopyFileRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sourceSURL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "sourceSURL", &a->sourceSURL, "xsd:anyURI"))
				{	soap_flag_sourceSURL--;
					continue;
				}
			if (soap_flag_targetSURL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "targetSURL", &a->targetSURL, "xsd:anyURI"))
				{	soap_flag_targetSURL--;
					continue;
				}
			if (soap_flag_dirOption && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TDirOption(soap, "dirOption", &a->dirOption, "srm2:TDirOption"))
				{	soap_flag_dirOption--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sourceSURL > 0 || soap_flag_targetSURL > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__TCopyFileRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TCopyFileRequest, 0, sizeof(struct srm2__TCopyFileRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__ArrayOfTPutFileRequest(struct soap *soap, const struct srm2__ArrayOfTPutFileRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->requestArray)
	{	int i;
		for (i = 0; i < a->__sizerequestArray; i++)
		{
			soap_serialize_PointerTosrm2__TPutFileRequest(soap, a->requestArray + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__ArrayOfTPutFileRequest(struct soap *soap, struct srm2__ArrayOfTPutFileRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizerequestArray = 0;
	a->requestArray = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__ArrayOfTPutFileRequest(struct soap *soap, const struct srm2__ArrayOfTPutFileRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__ArrayOfTPutFileRequest);
	if (soap_out_srm2__ArrayOfTPutFileRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__ArrayOfTPutFileRequest(struct soap *soap, const char *tag, int id, const struct srm2__ArrayOfTPutFileRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__ArrayOfTPutFileRequest), type);
	if (a->requestArray)
	{	int i;
		for (i = 0; i < a->__sizerequestArray; i++)
			soap_out_PointerTosrm2__TPutFileRequest(soap, "requestArray", -1, a->requestArray + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__ArrayOfTPutFileRequest * SOAP_FMAC4 soap_get_srm2__ArrayOfTPutFileRequest(struct soap *soap, struct srm2__ArrayOfTPutFileRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__ArrayOfTPutFileRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfTPutFileRequest * SOAP_FMAC4 soap_in_srm2__ArrayOfTPutFileRequest(struct soap *soap, const char *tag, struct srm2__ArrayOfTPutFileRequest *a, const char *type)
{
	short soap_flag_requestArray = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__ArrayOfTPutFileRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__ArrayOfTPutFileRequest, sizeof(struct srm2__ArrayOfTPutFileRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__ArrayOfTPutFileRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestArray && soap->error == SOAP_TAG_MISMATCH)
			{	struct srm2__TPutFileRequest **p;
				soap_new_block(soap);
				for (a->__sizerequestArray = 0; !soap_element_begin_in(soap, "requestArray", 1); a->__sizerequestArray++)
				{	p = (struct srm2__TPutFileRequest **)soap_push_block(soap, sizeof(struct srm2__TPutFileRequest *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_PointerTosrm2__TPutFileRequest(soap, "requestArray", p, "srm2:TPutFileRequest"))
						break;
					soap_flag_requestArray = 0;
				}
				a->requestArray = (struct srm2__TPutFileRequest **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_requestArray && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfTPutFileRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfTPutFileRequest, 0, sizeof(struct srm2__ArrayOfTPutFileRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__TPutFileRequest(struct soap *soap, const struct srm2__TPutFileRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->targetSURL);
	soap_serialize_PointerTounsignedLONG64(soap, &a->expectedFileSize);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__TPutFileRequest(struct soap *soap, struct srm2__TPutFileRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->targetSURL);
	a->expectedFileSize = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__TPutFileRequest(struct soap *soap, const struct srm2__TPutFileRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__TPutFileRequest);
	if (soap_out_srm2__TPutFileRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__TPutFileRequest(struct soap *soap, const char *tag, int id, const struct srm2__TPutFileRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__TPutFileRequest), type);
	soap_out_xsd__anyURI(soap, "targetSURL", -1, &a->targetSURL, "");
	soap_out_PointerTounsignedLONG64(soap, "expectedFileSize", -1, &a->expectedFileSize, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__TPutFileRequest * SOAP_FMAC4 soap_get_srm2__TPutFileRequest(struct soap *soap, struct srm2__TPutFileRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__TPutFileRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TPutFileRequest * SOAP_FMAC4 soap_in_srm2__TPutFileRequest(struct soap *soap, const char *tag, struct srm2__TPutFileRequest *a, const char *type)
{
	short soap_flag_targetSURL = 1, soap_flag_expectedFileSize = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__TPutFileRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__TPutFileRequest, sizeof(struct srm2__TPutFileRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__TPutFileRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_targetSURL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "targetSURL", &a->targetSURL, "xsd:anyURI"))
				{	soap_flag_targetSURL--;
					continue;
				}
			if (soap_flag_expectedFileSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "expectedFileSize", &a->expectedFileSize, "xsd:unsignedLong"))
				{	soap_flag_expectedFileSize--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__TPutFileRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TPutFileRequest, 0, sizeof(struct srm2__TPutFileRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__ArrayOfTGetFileRequest(struct soap *soap, const struct srm2__ArrayOfTGetFileRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->requestArray)
	{	int i;
		for (i = 0; i < a->__sizerequestArray; i++)
		{
			soap_serialize_PointerTosrm2__TGetFileRequest(soap, a->requestArray + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__ArrayOfTGetFileRequest(struct soap *soap, struct srm2__ArrayOfTGetFileRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizerequestArray = 0;
	a->requestArray = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__ArrayOfTGetFileRequest(struct soap *soap, const struct srm2__ArrayOfTGetFileRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__ArrayOfTGetFileRequest);
	if (soap_out_srm2__ArrayOfTGetFileRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__ArrayOfTGetFileRequest(struct soap *soap, const char *tag, int id, const struct srm2__ArrayOfTGetFileRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__ArrayOfTGetFileRequest), type);
	if (a->requestArray)
	{	int i;
		for (i = 0; i < a->__sizerequestArray; i++)
			soap_out_PointerTosrm2__TGetFileRequest(soap, "requestArray", -1, a->requestArray + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__ArrayOfTGetFileRequest * SOAP_FMAC4 soap_get_srm2__ArrayOfTGetFileRequest(struct soap *soap, struct srm2__ArrayOfTGetFileRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__ArrayOfTGetFileRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfTGetFileRequest * SOAP_FMAC4 soap_in_srm2__ArrayOfTGetFileRequest(struct soap *soap, const char *tag, struct srm2__ArrayOfTGetFileRequest *a, const char *type)
{
	short soap_flag_requestArray = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__ArrayOfTGetFileRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__ArrayOfTGetFileRequest, sizeof(struct srm2__ArrayOfTGetFileRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__ArrayOfTGetFileRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestArray && soap->error == SOAP_TAG_MISMATCH)
			{	struct srm2__TGetFileRequest **p;
				soap_new_block(soap);
				for (a->__sizerequestArray = 0; !soap_element_begin_in(soap, "requestArray", 1); a->__sizerequestArray++)
				{	p = (struct srm2__TGetFileRequest **)soap_push_block(soap, sizeof(struct srm2__TGetFileRequest *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_PointerTosrm2__TGetFileRequest(soap, "requestArray", p, "srm2:TGetFileRequest"))
						break;
					soap_flag_requestArray = 0;
				}
				a->requestArray = (struct srm2__TGetFileRequest **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_requestArray && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfTGetFileRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfTGetFileRequest, 0, sizeof(struct srm2__ArrayOfTGetFileRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__TGetFileRequest(struct soap *soap, const struct srm2__TGetFileRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->sourceSURL);
	soap_serialize_PointerTosrm2__TDirOption(soap, &a->dirOption);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__TGetFileRequest(struct soap *soap, struct srm2__TGetFileRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->sourceSURL);
	a->dirOption = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__TGetFileRequest(struct soap *soap, const struct srm2__TGetFileRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__TGetFileRequest);
	if (soap_out_srm2__TGetFileRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__TGetFileRequest(struct soap *soap, const char *tag, int id, const struct srm2__TGetFileRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__TGetFileRequest), type);
	soap_out_xsd__anyURI(soap, "sourceSURL", -1, &a->sourceSURL, "");
	soap_out_PointerTosrm2__TDirOption(soap, "dirOption", -1, &a->dirOption, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__TGetFileRequest * SOAP_FMAC4 soap_get_srm2__TGetFileRequest(struct soap *soap, struct srm2__TGetFileRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__TGetFileRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TGetFileRequest * SOAP_FMAC4 soap_in_srm2__TGetFileRequest(struct soap *soap, const char *tag, struct srm2__TGetFileRequest *a, const char *type)
{
	short soap_flag_sourceSURL = 1, soap_flag_dirOption = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__TGetFileRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__TGetFileRequest, sizeof(struct srm2__TGetFileRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__TGetFileRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sourceSURL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "sourceSURL", &a->sourceSURL, "xsd:anyURI"))
				{	soap_flag_sourceSURL--;
					continue;
				}
			if (soap_flag_dirOption && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TDirOption(soap, "dirOption", &a->dirOption, "srm2:TDirOption"))
				{	soap_flag_dirOption--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sourceSURL > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__TGetFileRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TGetFileRequest, 0, sizeof(struct srm2__TGetFileRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__TTransferParameters(struct soap *soap, const struct srm2__TTransferParameters *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__TAccessPattern(soap, &a->accessPattern);
	soap_serialize_PointerTosrm2__TConnectionType(soap, &a->connectionType);
	soap_serialize_PointerTosrm2__ArrayOfString(soap, &a->arrayOfClientNetworks);
	soap_serialize_PointerTosrm2__ArrayOfString(soap, &a->arrayOfTransferProtocols);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__TTransferParameters(struct soap *soap, struct srm2__TTransferParameters *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->accessPattern = NULL;
	a->connectionType = NULL;
	a->arrayOfClientNetworks = NULL;
	a->arrayOfTransferProtocols = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__TTransferParameters(struct soap *soap, const struct srm2__TTransferParameters *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__TTransferParameters);
	if (soap_out_srm2__TTransferParameters(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__TTransferParameters(struct soap *soap, const char *tag, int id, const struct srm2__TTransferParameters *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__TTransferParameters), type);
	soap_out_PointerTosrm2__TAccessPattern(soap, "accessPattern", -1, &a->accessPattern, "");
	soap_out_PointerTosrm2__TConnectionType(soap, "connectionType", -1, &a->connectionType, "");
	soap_out_PointerTosrm2__ArrayOfString(soap, "arrayOfClientNetworks", -1, &a->arrayOfClientNetworks, "");
	soap_out_PointerTosrm2__ArrayOfString(soap, "arrayOfTransferProtocols", -1, &a->arrayOfTransferProtocols, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__TTransferParameters * SOAP_FMAC4 soap_get_srm2__TTransferParameters(struct soap *soap, struct srm2__TTransferParameters *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__TTransferParameters(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TTransferParameters * SOAP_FMAC4 soap_in_srm2__TTransferParameters(struct soap *soap, const char *tag, struct srm2__TTransferParameters *a, const char *type)
{
	short soap_flag_accessPattern = 1, soap_flag_connectionType = 1, soap_flag_arrayOfClientNetworks = 1, soap_flag_arrayOfTransferProtocols = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__TTransferParameters *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__TTransferParameters, sizeof(struct srm2__TTransferParameters), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__TTransferParameters(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accessPattern && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TAccessPattern(soap, "accessPattern", &a->accessPattern, "srm2:TAccessPattern"))
				{	soap_flag_accessPattern--;
					continue;
				}
			if (soap_flag_connectionType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TConnectionType(soap, "connectionType", &a->connectionType, "srm2:TConnectionType"))
				{	soap_flag_connectionType--;
					continue;
				}
			if (soap_flag_arrayOfClientNetworks && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfString(soap, "arrayOfClientNetworks", &a->arrayOfClientNetworks, "srm2:ArrayOfString"))
				{	soap_flag_arrayOfClientNetworks--;
					continue;
				}
			if (soap_flag_arrayOfTransferProtocols && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfString(soap, "arrayOfTransferProtocols", &a->arrayOfTransferProtocols, "srm2:ArrayOfString"))
				{	soap_flag_arrayOfTransferProtocols--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__TTransferParameters *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TTransferParameters, 0, sizeof(struct srm2__TTransferParameters), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__ArrayOfAnyURI(struct soap *soap, const struct srm2__ArrayOfAnyURI *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->urlArray)
	{	int i;
		for (i = 0; i < a->__sizeurlArray; i++)
		{
			soap_serialize_xsd__anyURI(soap, a->urlArray + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__ArrayOfAnyURI(struct soap *soap, struct srm2__ArrayOfAnyURI *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeurlArray = 0;
	a->urlArray = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__ArrayOfAnyURI(struct soap *soap, const struct srm2__ArrayOfAnyURI *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__ArrayOfAnyURI);
	if (soap_out_srm2__ArrayOfAnyURI(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__ArrayOfAnyURI(struct soap *soap, const char *tag, int id, const struct srm2__ArrayOfAnyURI *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__ArrayOfAnyURI), type);
	if (a->urlArray)
	{	int i;
		for (i = 0; i < a->__sizeurlArray; i++)
			soap_out_xsd__anyURI(soap, "urlArray", -1, a->urlArray + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__ArrayOfAnyURI * SOAP_FMAC4 soap_get_srm2__ArrayOfAnyURI(struct soap *soap, struct srm2__ArrayOfAnyURI *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__ArrayOfAnyURI(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfAnyURI * SOAP_FMAC4 soap_in_srm2__ArrayOfAnyURI(struct soap *soap, const char *tag, struct srm2__ArrayOfAnyURI *a, const char *type)
{
	short soap_flag_urlArray = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__ArrayOfAnyURI *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__ArrayOfAnyURI, sizeof(struct srm2__ArrayOfAnyURI), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__ArrayOfAnyURI(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_urlArray && soap->error == SOAP_TAG_MISMATCH)
			{	char **p;
				soap_new_block(soap);
				for (a->__sizeurlArray = 0; !soap_element_begin_in(soap, "urlArray", 1); a->__sizeurlArray++)
				{	p = (char **)soap_push_block(soap, sizeof(char *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_xsd__anyURI(soap, "urlArray", p, "xsd:anyURI"))
						break;
					soap_flag_urlArray = 0;
				}
				a->urlArray = (char **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_urlArray && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfAnyURI *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfAnyURI, 0, sizeof(struct srm2__ArrayOfAnyURI), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__ArrayOfTExtraInfo(struct soap *soap, const struct srm2__ArrayOfTExtraInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->extraInfoArray)
	{	int i;
		for (i = 0; i < a->__sizeextraInfoArray; i++)
		{
			soap_serialize_PointerTosrm2__TExtraInfo(soap, a->extraInfoArray + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__ArrayOfTExtraInfo(struct soap *soap, struct srm2__ArrayOfTExtraInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeextraInfoArray = 0;
	a->extraInfoArray = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__ArrayOfTExtraInfo(struct soap *soap, const struct srm2__ArrayOfTExtraInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__ArrayOfTExtraInfo);
	if (soap_out_srm2__ArrayOfTExtraInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__ArrayOfTExtraInfo(struct soap *soap, const char *tag, int id, const struct srm2__ArrayOfTExtraInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__ArrayOfTExtraInfo), type);
	if (a->extraInfoArray)
	{	int i;
		for (i = 0; i < a->__sizeextraInfoArray; i++)
			soap_out_PointerTosrm2__TExtraInfo(soap, "extraInfoArray", -1, a->extraInfoArray + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__ArrayOfTExtraInfo * SOAP_FMAC4 soap_get_srm2__ArrayOfTExtraInfo(struct soap *soap, struct srm2__ArrayOfTExtraInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__ArrayOfTExtraInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfTExtraInfo * SOAP_FMAC4 soap_in_srm2__ArrayOfTExtraInfo(struct soap *soap, const char *tag, struct srm2__ArrayOfTExtraInfo *a, const char *type)
{
	short soap_flag_extraInfoArray = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__ArrayOfTExtraInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__ArrayOfTExtraInfo, sizeof(struct srm2__ArrayOfTExtraInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__ArrayOfTExtraInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_extraInfoArray && soap->error == SOAP_TAG_MISMATCH)
			{	struct srm2__TExtraInfo **p;
				soap_new_block(soap);
				for (a->__sizeextraInfoArray = 0; !soap_element_begin_in(soap, "extraInfoArray", 1); a->__sizeextraInfoArray++)
				{	p = (struct srm2__TExtraInfo **)soap_push_block(soap, sizeof(struct srm2__TExtraInfo *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_PointerTosrm2__TExtraInfo(soap, "extraInfoArray", p, "srm2:TExtraInfo"))
						break;
					soap_flag_extraInfoArray = 0;
				}
				a->extraInfoArray = (struct srm2__TExtraInfo **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_extraInfoArray && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfTExtraInfo *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfTExtraInfo, 0, sizeof(struct srm2__ArrayOfTExtraInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__TExtraInfo(struct soap *soap, const struct srm2__TExtraInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->key);
	soap_serialize_string(soap, &a->value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__TExtraInfo(struct soap *soap, struct srm2__TExtraInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->key);
	soap_default_string(soap, &a->value);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__TExtraInfo(struct soap *soap, const struct srm2__TExtraInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__TExtraInfo);
	if (soap_out_srm2__TExtraInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__TExtraInfo(struct soap *soap, const char *tag, int id, const struct srm2__TExtraInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__TExtraInfo), type);
	soap_out_string(soap, "key", -1, &a->key, "");
	soap_out_string(soap, "value", -1, &a->value, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__TExtraInfo * SOAP_FMAC4 soap_get_srm2__TExtraInfo(struct soap *soap, struct srm2__TExtraInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__TExtraInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TExtraInfo * SOAP_FMAC4 soap_in_srm2__TExtraInfo(struct soap *soap, const char *tag, struct srm2__TExtraInfo *a, const char *type)
{
	short soap_flag_key = 1, soap_flag_value = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__TExtraInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__TExtraInfo, sizeof(struct srm2__TExtraInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__TExtraInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_key && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "key", &a->key, "xsd:string"))
				{	soap_flag_key--;
					continue;
				}
			if (soap_flag_value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "value", &a->value, "xsd:string"))
				{	soap_flag_value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_key > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__TExtraInfo *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TExtraInfo, 0, sizeof(struct srm2__TExtraInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__TDirOption(struct soap *soap, const struct srm2__TDirOption *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->isSourceADirectory, SOAP_TYPE_xsd__boolean);
	soap_serialize_PointerToxsd__boolean(soap, &a->allLevelRecursive);
	soap_serialize_PointerToint(soap, &a->numOfLevels);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__TDirOption(struct soap *soap, struct srm2__TDirOption *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->isSourceADirectory);
	a->allLevelRecursive = NULL;
	a->numOfLevels = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__TDirOption(struct soap *soap, const struct srm2__TDirOption *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__TDirOption);
	if (soap_out_srm2__TDirOption(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__TDirOption(struct soap *soap, const char *tag, int id, const struct srm2__TDirOption *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__TDirOption), type);
	soap_out_xsd__boolean(soap, "isSourceADirectory", -1, &a->isSourceADirectory, "");
	soap_out_PointerToxsd__boolean(soap, "allLevelRecursive", -1, &a->allLevelRecursive, "");
	soap_out_PointerToint(soap, "numOfLevels", -1, &a->numOfLevels, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__TDirOption * SOAP_FMAC4 soap_get_srm2__TDirOption(struct soap *soap, struct srm2__TDirOption *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__TDirOption(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TDirOption * SOAP_FMAC4 soap_in_srm2__TDirOption(struct soap *soap, const char *tag, struct srm2__TDirOption *a, const char *type)
{
	short soap_flag_isSourceADirectory = 1, soap_flag_allLevelRecursive = 1, soap_flag_numOfLevels = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__TDirOption *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__TDirOption, sizeof(struct srm2__TDirOption), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__TDirOption(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_isSourceADirectory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "isSourceADirectory", &a->isSourceADirectory, "xsd:boolean"))
				{	soap_flag_isSourceADirectory--;
					continue;
				}
			if (soap_flag_allLevelRecursive && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "allLevelRecursive", &a->allLevelRecursive, "xsd:boolean"))
				{	soap_flag_allLevelRecursive--;
					continue;
				}
			if (soap_flag_numOfLevels && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "numOfLevels", &a->numOfLevels, "xsd:int"))
				{	soap_flag_numOfLevels--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_isSourceADirectory > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__TDirOption *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TDirOption, 0, sizeof(struct srm2__TDirOption), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__ArrayOfTMetaDataSpace(struct soap *soap, const struct srm2__ArrayOfTMetaDataSpace *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->spaceDataArray)
	{	int i;
		for (i = 0; i < a->__sizespaceDataArray; i++)
		{
			soap_serialize_PointerTosrm2__TMetaDataSpace(soap, a->spaceDataArray + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__ArrayOfTMetaDataSpace(struct soap *soap, struct srm2__ArrayOfTMetaDataSpace *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizespaceDataArray = 0;
	a->spaceDataArray = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__ArrayOfTMetaDataSpace(struct soap *soap, const struct srm2__ArrayOfTMetaDataSpace *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__ArrayOfTMetaDataSpace);
	if (soap_out_srm2__ArrayOfTMetaDataSpace(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__ArrayOfTMetaDataSpace(struct soap *soap, const char *tag, int id, const struct srm2__ArrayOfTMetaDataSpace *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__ArrayOfTMetaDataSpace), type);
	if (a->spaceDataArray)
	{	int i;
		for (i = 0; i < a->__sizespaceDataArray; i++)
			soap_out_PointerTosrm2__TMetaDataSpace(soap, "spaceDataArray", -1, a->spaceDataArray + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__ArrayOfTMetaDataSpace * SOAP_FMAC4 soap_get_srm2__ArrayOfTMetaDataSpace(struct soap *soap, struct srm2__ArrayOfTMetaDataSpace *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__ArrayOfTMetaDataSpace(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfTMetaDataSpace * SOAP_FMAC4 soap_in_srm2__ArrayOfTMetaDataSpace(struct soap *soap, const char *tag, struct srm2__ArrayOfTMetaDataSpace *a, const char *type)
{
	short soap_flag_spaceDataArray = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__ArrayOfTMetaDataSpace *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__ArrayOfTMetaDataSpace, sizeof(struct srm2__ArrayOfTMetaDataSpace), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__ArrayOfTMetaDataSpace(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_spaceDataArray && soap->error == SOAP_TAG_MISMATCH)
			{	struct srm2__TMetaDataSpace **p;
				soap_new_block(soap);
				for (a->__sizespaceDataArray = 0; !soap_element_begin_in(soap, "spaceDataArray", 1); a->__sizespaceDataArray++)
				{	p = (struct srm2__TMetaDataSpace **)soap_push_block(soap, sizeof(struct srm2__TMetaDataSpace *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_PointerTosrm2__TMetaDataSpace(soap, "spaceDataArray", p, "srm2:TMetaDataSpace"))
						break;
					soap_flag_spaceDataArray = 0;
				}
				a->spaceDataArray = (struct srm2__TMetaDataSpace **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_spaceDataArray && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfTMetaDataSpace *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfTMetaDataSpace, 0, sizeof(struct srm2__ArrayOfTMetaDataSpace), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__TMetaDataSpace(struct soap *soap, const struct srm2__TMetaDataSpace *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->spaceToken);
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->status);
	soap_serialize_PointerTosrm2__TRetentionPolicyInfo(soap, &a->retentionPolicyInfo);
	soap_serialize_string(soap, &a->owner);
	soap_serialize_PointerTounsignedLONG64(soap, &a->totalSize);
	soap_serialize_PointerTounsignedLONG64(soap, &a->guaranteedSize);
	soap_serialize_PointerTounsignedLONG64(soap, &a->unusedSize);
	soap_serialize_PointerToint(soap, &a->lifetimeAssigned);
	soap_serialize_PointerToint(soap, &a->lifetimeLeft);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__TMetaDataSpace(struct soap *soap, struct srm2__TMetaDataSpace *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->spaceToken);
	a->status = NULL;
	a->retentionPolicyInfo = NULL;
	soap_default_string(soap, &a->owner);
	a->totalSize = NULL;
	a->guaranteedSize = NULL;
	a->unusedSize = NULL;
	a->lifetimeAssigned = NULL;
	a->lifetimeLeft = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__TMetaDataSpace(struct soap *soap, const struct srm2__TMetaDataSpace *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__TMetaDataSpace);
	if (soap_out_srm2__TMetaDataSpace(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__TMetaDataSpace(struct soap *soap, const char *tag, int id, const struct srm2__TMetaDataSpace *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__TMetaDataSpace), type);
	soap_out_string(soap, "spaceToken", -1, &a->spaceToken, "");
	soap_out_PointerTosrm2__TReturnStatus(soap, "status", -1, &a->status, "");
	soap_out_PointerTosrm2__TRetentionPolicyInfo(soap, "retentionPolicyInfo", -1, &a->retentionPolicyInfo, "");
	soap_out_string(soap, "owner", -1, &a->owner, "");
	soap_out_PointerTounsignedLONG64(soap, "totalSize", -1, &a->totalSize, "");
	soap_out_PointerTounsignedLONG64(soap, "guaranteedSize", -1, &a->guaranteedSize, "");
	soap_out_PointerTounsignedLONG64(soap, "unusedSize", -1, &a->unusedSize, "");
	soap_out_PointerToint(soap, "lifetimeAssigned", -1, &a->lifetimeAssigned, "");
	soap_out_PointerToint(soap, "lifetimeLeft", -1, &a->lifetimeLeft, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__TMetaDataSpace * SOAP_FMAC4 soap_get_srm2__TMetaDataSpace(struct soap *soap, struct srm2__TMetaDataSpace *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__TMetaDataSpace(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TMetaDataSpace * SOAP_FMAC4 soap_in_srm2__TMetaDataSpace(struct soap *soap, const char *tag, struct srm2__TMetaDataSpace *a, const char *type)
{
	short soap_flag_spaceToken = 1, soap_flag_status = 1, soap_flag_retentionPolicyInfo = 1, soap_flag_owner = 1, soap_flag_totalSize = 1, soap_flag_guaranteedSize = 1, soap_flag_unusedSize = 1, soap_flag_lifetimeAssigned = 1, soap_flag_lifetimeLeft = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__TMetaDataSpace *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__TMetaDataSpace, sizeof(struct srm2__TMetaDataSpace), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__TMetaDataSpace(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_spaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "spaceToken", &a->spaceToken, "xsd:string"))
				{	soap_flag_spaceToken--;
					continue;
				}
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "status", &a->status, "srm2:TReturnStatus"))
				{	soap_flag_status--;
					continue;
				}
			if (soap_flag_retentionPolicyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TRetentionPolicyInfo(soap, "retentionPolicyInfo", &a->retentionPolicyInfo, "srm2:TRetentionPolicyInfo"))
				{	soap_flag_retentionPolicyInfo--;
					continue;
				}
			if (soap_flag_owner && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "owner", &a->owner, "xsd:string"))
				{	soap_flag_owner--;
					continue;
				}
			if (soap_flag_totalSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "totalSize", &a->totalSize, "xsd:unsignedLong"))
				{	soap_flag_totalSize--;
					continue;
				}
			if (soap_flag_guaranteedSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "guaranteedSize", &a->guaranteedSize, "xsd:unsignedLong"))
				{	soap_flag_guaranteedSize--;
					continue;
				}
			if (soap_flag_unusedSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "unusedSize", &a->unusedSize, "xsd:unsignedLong"))
				{	soap_flag_unusedSize--;
					continue;
				}
			if (soap_flag_lifetimeAssigned && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "lifetimeAssigned", &a->lifetimeAssigned, "xsd:int"))
				{	soap_flag_lifetimeAssigned--;
					continue;
				}
			if (soap_flag_lifetimeLeft && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "lifetimeLeft", &a->lifetimeLeft, "xsd:int"))
				{	soap_flag_lifetimeLeft--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_spaceToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__TMetaDataSpace *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TMetaDataSpace, 0, sizeof(struct srm2__TMetaDataSpace), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__ArrayOfTMetaDataPathDetail(struct soap *soap, const struct srm2__ArrayOfTMetaDataPathDetail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->pathDetailArray)
	{	int i;
		for (i = 0; i < a->__sizepathDetailArray; i++)
		{
			soap_serialize_PointerTosrm2__TMetaDataPathDetail(soap, a->pathDetailArray + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__ArrayOfTMetaDataPathDetail(struct soap *soap, struct srm2__ArrayOfTMetaDataPathDetail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizepathDetailArray = 0;
	a->pathDetailArray = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__ArrayOfTMetaDataPathDetail(struct soap *soap, const struct srm2__ArrayOfTMetaDataPathDetail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__ArrayOfTMetaDataPathDetail);
	if (soap_out_srm2__ArrayOfTMetaDataPathDetail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__ArrayOfTMetaDataPathDetail(struct soap *soap, const char *tag, int id, const struct srm2__ArrayOfTMetaDataPathDetail *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__ArrayOfTMetaDataPathDetail), type);
	if (a->pathDetailArray)
	{	int i;
		for (i = 0; i < a->__sizepathDetailArray; i++)
			soap_out_PointerTosrm2__TMetaDataPathDetail(soap, "pathDetailArray", -1, a->pathDetailArray + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__ArrayOfTMetaDataPathDetail * SOAP_FMAC4 soap_get_srm2__ArrayOfTMetaDataPathDetail(struct soap *soap, struct srm2__ArrayOfTMetaDataPathDetail *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__ArrayOfTMetaDataPathDetail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfTMetaDataPathDetail * SOAP_FMAC4 soap_in_srm2__ArrayOfTMetaDataPathDetail(struct soap *soap, const char *tag, struct srm2__ArrayOfTMetaDataPathDetail *a, const char *type)
{
	short soap_flag_pathDetailArray = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__ArrayOfTMetaDataPathDetail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__ArrayOfTMetaDataPathDetail, sizeof(struct srm2__ArrayOfTMetaDataPathDetail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__ArrayOfTMetaDataPathDetail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pathDetailArray && soap->error == SOAP_TAG_MISMATCH)
			{	struct srm2__TMetaDataPathDetail **p;
				soap_new_block(soap);
				for (a->__sizepathDetailArray = 0; !soap_element_begin_in(soap, "pathDetailArray", 1); a->__sizepathDetailArray++)
				{	p = (struct srm2__TMetaDataPathDetail **)soap_push_block(soap, sizeof(struct srm2__TMetaDataPathDetail *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_PointerTosrm2__TMetaDataPathDetail(soap, "pathDetailArray", p, "srm2:TMetaDataPathDetail"))
						break;
					soap_flag_pathDetailArray = 0;
				}
				a->pathDetailArray = (struct srm2__TMetaDataPathDetail **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_pathDetailArray && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfTMetaDataPathDetail *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfTMetaDataPathDetail, 0, sizeof(struct srm2__ArrayOfTMetaDataPathDetail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__TMetaDataPathDetail(struct soap *soap, const struct srm2__TMetaDataPathDetail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->path);
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->status);
	soap_serialize_PointerTounsignedLONG64(soap, &a->size);
	soap_serialize_string(soap, &a->createdAtTime);
	soap_serialize_string(soap, &a->lastModificationTime);
	soap_serialize_PointerTosrm2__TFileStorageType(soap, &a->fileStorageType);
	soap_serialize_PointerTosrm2__TRetentionPolicyInfo(soap, &a->retentionPolicyInfo);
	soap_serialize_PointerTosrm2__TFileLocality(soap, &a->fileLocality);
	soap_serialize_PointerTosrm2__ArrayOfString(soap, &a->arrayOfSpaceTokens);
	soap_serialize_PointerTosrm2__TFileType(soap, &a->type);
	soap_serialize_PointerToint(soap, &a->lifetimeAssigned);
	soap_serialize_PointerToint(soap, &a->lifetimeLeft);
	soap_serialize_PointerTosrm2__TUserPermission(soap, &a->ownerPermission);
	soap_serialize_PointerTosrm2__TGroupPermission(soap, &a->groupPermission);
	soap_serialize_PointerTosrm2__TPermissionMode(soap, &a->otherPermission);
	soap_serialize_string(soap, &a->checkSumType);
	soap_serialize_string(soap, &a->checkSumValue);
	soap_serialize_PointerTosrm2__ArrayOfTMetaDataPathDetail(soap, &a->arrayOfSubPaths);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__TMetaDataPathDetail(struct soap *soap, struct srm2__TMetaDataPathDetail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->path);
	a->status = NULL;
	a->size = NULL;
	soap_default_string(soap, &a->createdAtTime);
	soap_default_string(soap, &a->lastModificationTime);
	a->fileStorageType = NULL;
	a->retentionPolicyInfo = NULL;
	a->fileLocality = NULL;
	a->arrayOfSpaceTokens = NULL;
	a->type = NULL;
	a->lifetimeAssigned = NULL;
	a->lifetimeLeft = NULL;
	a->ownerPermission = NULL;
	a->groupPermission = NULL;
	a->otherPermission = NULL;
	soap_default_string(soap, &a->checkSumType);
	soap_default_string(soap, &a->checkSumValue);
	a->arrayOfSubPaths = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__TMetaDataPathDetail(struct soap *soap, const struct srm2__TMetaDataPathDetail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__TMetaDataPathDetail);
	if (soap_out_srm2__TMetaDataPathDetail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__TMetaDataPathDetail(struct soap *soap, const char *tag, int id, const struct srm2__TMetaDataPathDetail *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__TMetaDataPathDetail), type);
	soap_out_string(soap, "path", -1, &a->path, "");
	soap_out_PointerTosrm2__TReturnStatus(soap, "status", -1, &a->status, "");
	soap_out_PointerTounsignedLONG64(soap, "size", -1, &a->size, "");
	soap_out_string(soap, "createdAtTime", -1, &a->createdAtTime, "");
	soap_out_string(soap, "lastModificationTime", -1, &a->lastModificationTime, "");
	soap_out_PointerTosrm2__TFileStorageType(soap, "fileStorageType", -1, &a->fileStorageType, "");
	soap_out_PointerTosrm2__TRetentionPolicyInfo(soap, "retentionPolicyInfo", -1, &a->retentionPolicyInfo, "");
	soap_out_PointerTosrm2__TFileLocality(soap, "fileLocality", -1, &a->fileLocality, "");
	soap_out_PointerTosrm2__ArrayOfString(soap, "arrayOfSpaceTokens", -1, &a->arrayOfSpaceTokens, "");
	soap_out_PointerTosrm2__TFileType(soap, "type", -1, &a->type, "");
	soap_out_PointerToint(soap, "lifetimeAssigned", -1, &a->lifetimeAssigned, "");
	soap_out_PointerToint(soap, "lifetimeLeft", -1, &a->lifetimeLeft, "");
	soap_out_PointerTosrm2__TUserPermission(soap, "ownerPermission", -1, &a->ownerPermission, "");
	soap_out_PointerTosrm2__TGroupPermission(soap, "groupPermission", -1, &a->groupPermission, "");
	soap_out_PointerTosrm2__TPermissionMode(soap, "otherPermission", -1, &a->otherPermission, "");
	soap_out_string(soap, "checkSumType", -1, &a->checkSumType, "");
	soap_out_string(soap, "checkSumValue", -1, &a->checkSumValue, "");
	soap_out_PointerTosrm2__ArrayOfTMetaDataPathDetail(soap, "arrayOfSubPaths", -1, &a->arrayOfSubPaths, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__TMetaDataPathDetail * SOAP_FMAC4 soap_get_srm2__TMetaDataPathDetail(struct soap *soap, struct srm2__TMetaDataPathDetail *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__TMetaDataPathDetail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TMetaDataPathDetail * SOAP_FMAC4 soap_in_srm2__TMetaDataPathDetail(struct soap *soap, const char *tag, struct srm2__TMetaDataPathDetail *a, const char *type)
{
	short soap_flag_path = 1, soap_flag_status = 1, soap_flag_size = 1, soap_flag_createdAtTime = 1, soap_flag_lastModificationTime = 1, soap_flag_fileStorageType = 1, soap_flag_retentionPolicyInfo = 1, soap_flag_fileLocality = 1, soap_flag_arrayOfSpaceTokens = 1, soap_flag_type = 1, soap_flag_lifetimeAssigned = 1, soap_flag_lifetimeLeft = 1, soap_flag_ownerPermission = 1, soap_flag_groupPermission = 1, soap_flag_otherPermission = 1, soap_flag_checkSumType = 1, soap_flag_checkSumValue = 1, soap_flag_arrayOfSubPaths = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__TMetaDataPathDetail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__TMetaDataPathDetail, sizeof(struct srm2__TMetaDataPathDetail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__TMetaDataPathDetail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_path && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "path", &a->path, "xsd:string"))
				{	soap_flag_path--;
					continue;
				}
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "status", &a->status, "srm2:TReturnStatus"))
				{	soap_flag_status--;
					continue;
				}
			if (soap_flag_size && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "size", &a->size, "xsd:unsignedLong"))
				{	soap_flag_size--;
					continue;
				}
			if (soap_flag_createdAtTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "createdAtTime", &a->createdAtTime, "xsd:string"))
				{	soap_flag_createdAtTime--;
					continue;
				}
			if (soap_flag_lastModificationTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "lastModificationTime", &a->lastModificationTime, "xsd:string"))
				{	soap_flag_lastModificationTime--;
					continue;
				}
			if (soap_flag_fileStorageType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TFileStorageType(soap, "fileStorageType", &a->fileStorageType, "srm2:TFileStorageType"))
				{	soap_flag_fileStorageType--;
					continue;
				}
			if (soap_flag_retentionPolicyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TRetentionPolicyInfo(soap, "retentionPolicyInfo", &a->retentionPolicyInfo, "srm2:TRetentionPolicyInfo"))
				{	soap_flag_retentionPolicyInfo--;
					continue;
				}
			if (soap_flag_fileLocality && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TFileLocality(soap, "fileLocality", &a->fileLocality, "srm2:TFileLocality"))
				{	soap_flag_fileLocality--;
					continue;
				}
			if (soap_flag_arrayOfSpaceTokens && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfString(soap, "arrayOfSpaceTokens", &a->arrayOfSpaceTokens, "srm2:ArrayOfString"))
				{	soap_flag_arrayOfSpaceTokens--;
					continue;
				}
			if (soap_flag_type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TFileType(soap, "type", &a->type, "srm2:TFileType"))
				{	soap_flag_type--;
					continue;
				}
			if (soap_flag_lifetimeAssigned && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "lifetimeAssigned", &a->lifetimeAssigned, "xsd:int"))
				{	soap_flag_lifetimeAssigned--;
					continue;
				}
			if (soap_flag_lifetimeLeft && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "lifetimeLeft", &a->lifetimeLeft, "xsd:int"))
				{	soap_flag_lifetimeLeft--;
					continue;
				}
			if (soap_flag_ownerPermission && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TUserPermission(soap, "ownerPermission", &a->ownerPermission, "srm2:TUserPermission"))
				{	soap_flag_ownerPermission--;
					continue;
				}
			if (soap_flag_groupPermission && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TGroupPermission(soap, "groupPermission", &a->groupPermission, "srm2:TGroupPermission"))
				{	soap_flag_groupPermission--;
					continue;
				}
			if (soap_flag_otherPermission && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TPermissionMode(soap, "otherPermission", &a->otherPermission, "srm2:TPermissionMode"))
				{	soap_flag_otherPermission--;
					continue;
				}
			if (soap_flag_checkSumType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "checkSumType", &a->checkSumType, "xsd:string"))
				{	soap_flag_checkSumType--;
					continue;
				}
			if (soap_flag_checkSumValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "checkSumValue", &a->checkSumValue, "xsd:string"))
				{	soap_flag_checkSumValue--;
					continue;
				}
			if (soap_flag_arrayOfSubPaths && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__ArrayOfTMetaDataPathDetail(soap, "arrayOfSubPaths", &a->arrayOfSubPaths, "srm2:ArrayOfTMetaDataPathDetail"))
				{	soap_flag_arrayOfSubPaths--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_path > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__TMetaDataPathDetail *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TMetaDataPathDetail, 0, sizeof(struct srm2__TMetaDataPathDetail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__ArrayOfTSURLLifetimeReturnStatus(struct soap *soap, const struct srm2__ArrayOfTSURLLifetimeReturnStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->statusArray)
	{	int i;
		for (i = 0; i < a->__sizestatusArray; i++)
		{
			soap_serialize_PointerTosrm2__TSURLLifetimeReturnStatus(soap, a->statusArray + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__ArrayOfTSURLLifetimeReturnStatus(struct soap *soap, struct srm2__ArrayOfTSURLLifetimeReturnStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizestatusArray = 0;
	a->statusArray = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__ArrayOfTSURLLifetimeReturnStatus(struct soap *soap, const struct srm2__ArrayOfTSURLLifetimeReturnStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__ArrayOfTSURLLifetimeReturnStatus);
	if (soap_out_srm2__ArrayOfTSURLLifetimeReturnStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__ArrayOfTSURLLifetimeReturnStatus(struct soap *soap, const char *tag, int id, const struct srm2__ArrayOfTSURLLifetimeReturnStatus *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__ArrayOfTSURLLifetimeReturnStatus), type);
	if (a->statusArray)
	{	int i;
		for (i = 0; i < a->__sizestatusArray; i++)
			soap_out_PointerTosrm2__TSURLLifetimeReturnStatus(soap, "statusArray", -1, a->statusArray + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__ArrayOfTSURLLifetimeReturnStatus * SOAP_FMAC4 soap_get_srm2__ArrayOfTSURLLifetimeReturnStatus(struct soap *soap, struct srm2__ArrayOfTSURLLifetimeReturnStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__ArrayOfTSURLLifetimeReturnStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfTSURLLifetimeReturnStatus * SOAP_FMAC4 soap_in_srm2__ArrayOfTSURLLifetimeReturnStatus(struct soap *soap, const char *tag, struct srm2__ArrayOfTSURLLifetimeReturnStatus *a, const char *type)
{
	short soap_flag_statusArray = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__ArrayOfTSURLLifetimeReturnStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__ArrayOfTSURLLifetimeReturnStatus, sizeof(struct srm2__ArrayOfTSURLLifetimeReturnStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__ArrayOfTSURLLifetimeReturnStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusArray && soap->error == SOAP_TAG_MISMATCH)
			{	struct srm2__TSURLLifetimeReturnStatus **p;
				soap_new_block(soap);
				for (a->__sizestatusArray = 0; !soap_element_begin_in(soap, "statusArray", 1); a->__sizestatusArray++)
				{	p = (struct srm2__TSURLLifetimeReturnStatus **)soap_push_block(soap, sizeof(struct srm2__TSURLLifetimeReturnStatus *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_PointerTosrm2__TSURLLifetimeReturnStatus(soap, "statusArray", p, "srm2:TSURLLifetimeReturnStatus"))
						break;
					soap_flag_statusArray = 0;
				}
				a->statusArray = (struct srm2__TSURLLifetimeReturnStatus **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_statusArray && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfTSURLLifetimeReturnStatus *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfTSURLLifetimeReturnStatus, 0, sizeof(struct srm2__ArrayOfTSURLLifetimeReturnStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__TSURLLifetimeReturnStatus(struct soap *soap, const struct srm2__TSURLLifetimeReturnStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->surl);
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->status);
	soap_serialize_PointerToint(soap, &a->fileLifetime);
	soap_serialize_PointerToint(soap, &a->pinLifetime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__TSURLLifetimeReturnStatus(struct soap *soap, struct srm2__TSURLLifetimeReturnStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->surl);
	a->status = NULL;
	a->fileLifetime = NULL;
	a->pinLifetime = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__TSURLLifetimeReturnStatus(struct soap *soap, const struct srm2__TSURLLifetimeReturnStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__TSURLLifetimeReturnStatus);
	if (soap_out_srm2__TSURLLifetimeReturnStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__TSURLLifetimeReturnStatus(struct soap *soap, const char *tag, int id, const struct srm2__TSURLLifetimeReturnStatus *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__TSURLLifetimeReturnStatus), type);
	soap_out_xsd__anyURI(soap, "surl", -1, &a->surl, "");
	soap_out_PointerTosrm2__TReturnStatus(soap, "status", -1, &a->status, "");
	soap_out_PointerToint(soap, "fileLifetime", -1, &a->fileLifetime, "");
	soap_out_PointerToint(soap, "pinLifetime", -1, &a->pinLifetime, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__TSURLLifetimeReturnStatus * SOAP_FMAC4 soap_get_srm2__TSURLLifetimeReturnStatus(struct soap *soap, struct srm2__TSURLLifetimeReturnStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__TSURLLifetimeReturnStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TSURLLifetimeReturnStatus * SOAP_FMAC4 soap_in_srm2__TSURLLifetimeReturnStatus(struct soap *soap, const char *tag, struct srm2__TSURLLifetimeReturnStatus *a, const char *type)
{
	short soap_flag_surl = 1, soap_flag_status = 1, soap_flag_fileLifetime = 1, soap_flag_pinLifetime = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__TSURLLifetimeReturnStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__TSURLLifetimeReturnStatus, sizeof(struct srm2__TSURLLifetimeReturnStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__TSURLLifetimeReturnStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_surl && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "surl", &a->surl, "xsd:anyURI"))
				{	soap_flag_surl--;
					continue;
				}
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "status", &a->status, "srm2:TReturnStatus"))
				{	soap_flag_status--;
					continue;
				}
			if (soap_flag_fileLifetime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "fileLifetime", &a->fileLifetime, "xsd:int"))
				{	soap_flag_fileLifetime--;
					continue;
				}
			if (soap_flag_pinLifetime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "pinLifetime", &a->pinLifetime, "xsd:int"))
				{	soap_flag_pinLifetime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_surl > 0 || soap_flag_status > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__TSURLLifetimeReturnStatus *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TSURLLifetimeReturnStatus, 0, sizeof(struct srm2__TSURLLifetimeReturnStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__ArrayOfTSURLReturnStatus(struct soap *soap, const struct srm2__ArrayOfTSURLReturnStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->statusArray)
	{	int i;
		for (i = 0; i < a->__sizestatusArray; i++)
		{
			soap_serialize_PointerTosrm2__TSURLReturnStatus(soap, a->statusArray + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__ArrayOfTSURLReturnStatus(struct soap *soap, struct srm2__ArrayOfTSURLReturnStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizestatusArray = 0;
	a->statusArray = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__ArrayOfTSURLReturnStatus(struct soap *soap, const struct srm2__ArrayOfTSURLReturnStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__ArrayOfTSURLReturnStatus);
	if (soap_out_srm2__ArrayOfTSURLReturnStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__ArrayOfTSURLReturnStatus(struct soap *soap, const char *tag, int id, const struct srm2__ArrayOfTSURLReturnStatus *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__ArrayOfTSURLReturnStatus), type);
	if (a->statusArray)
	{	int i;
		for (i = 0; i < a->__sizestatusArray; i++)
			soap_out_PointerTosrm2__TSURLReturnStatus(soap, "statusArray", -1, a->statusArray + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__ArrayOfTSURLReturnStatus * SOAP_FMAC4 soap_get_srm2__ArrayOfTSURLReturnStatus(struct soap *soap, struct srm2__ArrayOfTSURLReturnStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__ArrayOfTSURLReturnStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfTSURLReturnStatus * SOAP_FMAC4 soap_in_srm2__ArrayOfTSURLReturnStatus(struct soap *soap, const char *tag, struct srm2__ArrayOfTSURLReturnStatus *a, const char *type)
{
	short soap_flag_statusArray = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__ArrayOfTSURLReturnStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__ArrayOfTSURLReturnStatus, sizeof(struct srm2__ArrayOfTSURLReturnStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__ArrayOfTSURLReturnStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusArray && soap->error == SOAP_TAG_MISMATCH)
			{	struct srm2__TSURLReturnStatus **p;
				soap_new_block(soap);
				for (a->__sizestatusArray = 0; !soap_element_begin_in(soap, "statusArray", 1); a->__sizestatusArray++)
				{	p = (struct srm2__TSURLReturnStatus **)soap_push_block(soap, sizeof(struct srm2__TSURLReturnStatus *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_PointerTosrm2__TSURLReturnStatus(soap, "statusArray", p, "srm2:TSURLReturnStatus"))
						break;
					soap_flag_statusArray = 0;
				}
				a->statusArray = (struct srm2__TSURLReturnStatus **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_statusArray && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfTSURLReturnStatus *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfTSURLReturnStatus, 0, sizeof(struct srm2__ArrayOfTSURLReturnStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__TSURLReturnStatus(struct soap *soap, const struct srm2__TSURLReturnStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->surl);
	soap_serialize_PointerTosrm2__TReturnStatus(soap, &a->status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__TSURLReturnStatus(struct soap *soap, struct srm2__TSURLReturnStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->surl);
	a->status = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__TSURLReturnStatus(struct soap *soap, const struct srm2__TSURLReturnStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__TSURLReturnStatus);
	if (soap_out_srm2__TSURLReturnStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__TSURLReturnStatus(struct soap *soap, const char *tag, int id, const struct srm2__TSURLReturnStatus *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__TSURLReturnStatus), type);
	soap_out_xsd__anyURI(soap, "surl", -1, &a->surl, "");
	soap_out_PointerTosrm2__TReturnStatus(soap, "status", -1, &a->status, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__TSURLReturnStatus * SOAP_FMAC4 soap_get_srm2__TSURLReturnStatus(struct soap *soap, struct srm2__TSURLReturnStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__TSURLReturnStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TSURLReturnStatus * SOAP_FMAC4 soap_in_srm2__TSURLReturnStatus(struct soap *soap, const char *tag, struct srm2__TSURLReturnStatus *a, const char *type)
{
	short soap_flag_surl = 1, soap_flag_status = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__TSURLReturnStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__TSURLReturnStatus, sizeof(struct srm2__TSURLReturnStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__TSURLReturnStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_surl && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "surl", &a->surl, "xsd:anyURI"))
				{	soap_flag_surl--;
					continue;
				}
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TReturnStatus(soap, "status", &a->status, "srm2:TReturnStatus"))
				{	soap_flag_status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_surl > 0 || soap_flag_status > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__TSURLReturnStatus *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TSURLReturnStatus, 0, sizeof(struct srm2__TSURLReturnStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__TReturnStatus(struct soap *soap, const struct srm2__TReturnStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->explanation);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__TReturnStatus(struct soap *soap, struct srm2__TReturnStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_srm2__TStatusCode(soap, &a->statusCode);
	soap_default_string(soap, &a->explanation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__TReturnStatus(struct soap *soap, const struct srm2__TReturnStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__TReturnStatus);
	if (soap_out_srm2__TReturnStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__TReturnStatus(struct soap *soap, const char *tag, int id, const struct srm2__TReturnStatus *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__TReturnStatus), type);
	soap_out_srm2__TStatusCode(soap, "statusCode", -1, &a->statusCode, "");
	soap_out_string(soap, "explanation", -1, &a->explanation, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__TReturnStatus * SOAP_FMAC4 soap_get_srm2__TReturnStatus(struct soap *soap, struct srm2__TReturnStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__TReturnStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TReturnStatus * SOAP_FMAC4 soap_in_srm2__TReturnStatus(struct soap *soap, const char *tag, struct srm2__TReturnStatus *a, const char *type)
{
	short soap_flag_statusCode = 1, soap_flag_explanation = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__TReturnStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__TReturnStatus, sizeof(struct srm2__TReturnStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__TReturnStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_srm2__TStatusCode(soap, "statusCode", &a->statusCode, "srm2:TStatusCode"))
				{	soap_flag_statusCode--;
					continue;
				}
			if (soap_flag_explanation && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "explanation", &a->explanation, "xsd:string"))
				{	soap_flag_explanation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_statusCode > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__TReturnStatus *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TReturnStatus, 0, sizeof(struct srm2__TReturnStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__ArrayOfString(struct soap *soap, const struct srm2__ArrayOfString *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->stringArray)
	{	int i;
		for (i = 0; i < a->__sizestringArray; i++)
		{
			soap_serialize_string(soap, a->stringArray + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__ArrayOfString(struct soap *soap, struct srm2__ArrayOfString *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizestringArray = 0;
	a->stringArray = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__ArrayOfString(struct soap *soap, const struct srm2__ArrayOfString *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__ArrayOfString);
	if (soap_out_srm2__ArrayOfString(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__ArrayOfString(struct soap *soap, const char *tag, int id, const struct srm2__ArrayOfString *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__ArrayOfString), type);
	if (a->stringArray)
	{	int i;
		for (i = 0; i < a->__sizestringArray; i++)
			soap_out_string(soap, "stringArray", -1, a->stringArray + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__ArrayOfString * SOAP_FMAC4 soap_get_srm2__ArrayOfString(struct soap *soap, struct srm2__ArrayOfString *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__ArrayOfString(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfString * SOAP_FMAC4 soap_in_srm2__ArrayOfString(struct soap *soap, const char *tag, struct srm2__ArrayOfString *a, const char *type)
{
	short soap_flag_stringArray = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__ArrayOfString *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__ArrayOfString, sizeof(struct srm2__ArrayOfString), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__ArrayOfString(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_stringArray && soap->error == SOAP_TAG_MISMATCH)
			{	char **p;
				soap_new_block(soap);
				for (a->__sizestringArray = 0; !soap_element_begin_in(soap, "stringArray", 1); a->__sizestringArray++)
				{	p = (char **)soap_push_block(soap, sizeof(char *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_string(soap, "stringArray", p, "xsd:string"))
						break;
					soap_flag_stringArray = 0;
				}
				a->stringArray = (char **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_stringArray && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfString *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfString, 0, sizeof(struct srm2__ArrayOfString), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__ArrayOfUnsignedLong(struct soap *soap, const struct srm2__ArrayOfUnsignedLong *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->unsignedLongArray)
	{	int i;
		for (i = 0; i < a->__sizeunsignedLongArray; i++)
		{
			soap_embedded(soap, a->unsignedLongArray + i, SOAP_TYPE_unsignedLONG64);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__ArrayOfUnsignedLong(struct soap *soap, struct srm2__ArrayOfUnsignedLong *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeunsignedLongArray = 0;
	a->unsignedLongArray = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__ArrayOfUnsignedLong(struct soap *soap, const struct srm2__ArrayOfUnsignedLong *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__ArrayOfUnsignedLong);
	if (soap_out_srm2__ArrayOfUnsignedLong(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__ArrayOfUnsignedLong(struct soap *soap, const char *tag, int id, const struct srm2__ArrayOfUnsignedLong *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__ArrayOfUnsignedLong), type);
	if (a->unsignedLongArray)
	{	int i;
		for (i = 0; i < a->__sizeunsignedLongArray; i++)
			soap_out_unsignedLONG64(soap, "unsignedLongArray", -1, a->unsignedLongArray + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__ArrayOfUnsignedLong * SOAP_FMAC4 soap_get_srm2__ArrayOfUnsignedLong(struct soap *soap, struct srm2__ArrayOfUnsignedLong *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__ArrayOfUnsignedLong(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfUnsignedLong * SOAP_FMAC4 soap_in_srm2__ArrayOfUnsignedLong(struct soap *soap, const char *tag, struct srm2__ArrayOfUnsignedLong *a, const char *type)
{
	short soap_flag_unsignedLongArray = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__ArrayOfUnsignedLong *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__ArrayOfUnsignedLong, sizeof(struct srm2__ArrayOfUnsignedLong), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__ArrayOfUnsignedLong(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_unsignedLongArray && soap->error == SOAP_TAG_MISMATCH)
			{	ULONG64 *p;
				soap_new_block(soap);
				for (a->__sizeunsignedLongArray = 0; !soap_element_begin_in(soap, "unsignedLongArray", 1); a->__sizeunsignedLongArray++)
				{	p = (ULONG64 *)soap_push_block(soap, sizeof(ULONG64));
					soap_default_unsignedLONG64(soap, p);
					soap_revert(soap);
					if (!soap_in_unsignedLONG64(soap, "unsignedLongArray", p, "xsd:unsignedLong"))
						break;
					soap_flag_unsignedLongArray = 0;
				}
				a->unsignedLongArray = (ULONG64 *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_unsignedLongArray && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfUnsignedLong *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfUnsignedLong, 0, sizeof(struct srm2__ArrayOfUnsignedLong), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__ArrayOfTGroupPermission(struct soap *soap, const struct srm2__ArrayOfTGroupPermission *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->groupPermissionArray)
	{	int i;
		for (i = 0; i < a->__sizegroupPermissionArray; i++)
		{
			soap_serialize_PointerTosrm2__TGroupPermission(soap, a->groupPermissionArray + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__ArrayOfTGroupPermission(struct soap *soap, struct srm2__ArrayOfTGroupPermission *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizegroupPermissionArray = 0;
	a->groupPermissionArray = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__ArrayOfTGroupPermission(struct soap *soap, const struct srm2__ArrayOfTGroupPermission *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__ArrayOfTGroupPermission);
	if (soap_out_srm2__ArrayOfTGroupPermission(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__ArrayOfTGroupPermission(struct soap *soap, const char *tag, int id, const struct srm2__ArrayOfTGroupPermission *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__ArrayOfTGroupPermission), type);
	if (a->groupPermissionArray)
	{	int i;
		for (i = 0; i < a->__sizegroupPermissionArray; i++)
			soap_out_PointerTosrm2__TGroupPermission(soap, "groupPermissionArray", -1, a->groupPermissionArray + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__ArrayOfTGroupPermission * SOAP_FMAC4 soap_get_srm2__ArrayOfTGroupPermission(struct soap *soap, struct srm2__ArrayOfTGroupPermission *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__ArrayOfTGroupPermission(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfTGroupPermission * SOAP_FMAC4 soap_in_srm2__ArrayOfTGroupPermission(struct soap *soap, const char *tag, struct srm2__ArrayOfTGroupPermission *a, const char *type)
{
	short soap_flag_groupPermissionArray = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__ArrayOfTGroupPermission *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__ArrayOfTGroupPermission, sizeof(struct srm2__ArrayOfTGroupPermission), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__ArrayOfTGroupPermission(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_groupPermissionArray && soap->error == SOAP_TAG_MISMATCH)
			{	struct srm2__TGroupPermission **p;
				soap_new_block(soap);
				for (a->__sizegroupPermissionArray = 0; !soap_element_begin_in(soap, "groupPermissionArray", 1); a->__sizegroupPermissionArray++)
				{	p = (struct srm2__TGroupPermission **)soap_push_block(soap, sizeof(struct srm2__TGroupPermission *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_PointerTosrm2__TGroupPermission(soap, "groupPermissionArray", p, "srm2:TGroupPermission"))
						break;
					soap_flag_groupPermissionArray = 0;
				}
				a->groupPermissionArray = (struct srm2__TGroupPermission **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_groupPermissionArray && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfTGroupPermission *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfTGroupPermission, 0, sizeof(struct srm2__ArrayOfTGroupPermission), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__TGroupPermission(struct soap *soap, const struct srm2__TGroupPermission *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->groupID);
	soap_embedded(soap, &a->mode, SOAP_TYPE_srm2__TPermissionMode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__TGroupPermission(struct soap *soap, struct srm2__TGroupPermission *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->groupID);
	soap_default_srm2__TPermissionMode(soap, &a->mode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__TGroupPermission(struct soap *soap, const struct srm2__TGroupPermission *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__TGroupPermission);
	if (soap_out_srm2__TGroupPermission(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__TGroupPermission(struct soap *soap, const char *tag, int id, const struct srm2__TGroupPermission *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__TGroupPermission), type);
	soap_out_string(soap, "groupID", -1, &a->groupID, "");
	soap_out_srm2__TPermissionMode(soap, "mode", -1, &a->mode, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__TGroupPermission * SOAP_FMAC4 soap_get_srm2__TGroupPermission(struct soap *soap, struct srm2__TGroupPermission *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__TGroupPermission(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TGroupPermission * SOAP_FMAC4 soap_in_srm2__TGroupPermission(struct soap *soap, const char *tag, struct srm2__TGroupPermission *a, const char *type)
{
	short soap_flag_groupID = 1, soap_flag_mode = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__TGroupPermission *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__TGroupPermission, sizeof(struct srm2__TGroupPermission), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__TGroupPermission(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_groupID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "groupID", &a->groupID, "xsd:string"))
				{	soap_flag_groupID--;
					continue;
				}
			if (soap_flag_mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_srm2__TPermissionMode(soap, "mode", &a->mode, "srm2:TPermissionMode"))
				{	soap_flag_mode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_groupID > 0 || soap_flag_mode > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__TGroupPermission *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TGroupPermission, 0, sizeof(struct srm2__TGroupPermission), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__ArrayOfTUserPermission(struct soap *soap, const struct srm2__ArrayOfTUserPermission *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->userPermissionArray)
	{	int i;
		for (i = 0; i < a->__sizeuserPermissionArray; i++)
		{
			soap_serialize_PointerTosrm2__TUserPermission(soap, a->userPermissionArray + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__ArrayOfTUserPermission(struct soap *soap, struct srm2__ArrayOfTUserPermission *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeuserPermissionArray = 0;
	a->userPermissionArray = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__ArrayOfTUserPermission(struct soap *soap, const struct srm2__ArrayOfTUserPermission *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__ArrayOfTUserPermission);
	if (soap_out_srm2__ArrayOfTUserPermission(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__ArrayOfTUserPermission(struct soap *soap, const char *tag, int id, const struct srm2__ArrayOfTUserPermission *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__ArrayOfTUserPermission), type);
	if (a->userPermissionArray)
	{	int i;
		for (i = 0; i < a->__sizeuserPermissionArray; i++)
			soap_out_PointerTosrm2__TUserPermission(soap, "userPermissionArray", -1, a->userPermissionArray + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__ArrayOfTUserPermission * SOAP_FMAC4 soap_get_srm2__ArrayOfTUserPermission(struct soap *soap, struct srm2__ArrayOfTUserPermission *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__ArrayOfTUserPermission(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfTUserPermission * SOAP_FMAC4 soap_in_srm2__ArrayOfTUserPermission(struct soap *soap, const char *tag, struct srm2__ArrayOfTUserPermission *a, const char *type)
{
	short soap_flag_userPermissionArray = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__ArrayOfTUserPermission *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__ArrayOfTUserPermission, sizeof(struct srm2__ArrayOfTUserPermission), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__ArrayOfTUserPermission(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userPermissionArray && soap->error == SOAP_TAG_MISMATCH)
			{	struct srm2__TUserPermission **p;
				soap_new_block(soap);
				for (a->__sizeuserPermissionArray = 0; !soap_element_begin_in(soap, "userPermissionArray", 1); a->__sizeuserPermissionArray++)
				{	p = (struct srm2__TUserPermission **)soap_push_block(soap, sizeof(struct srm2__TUserPermission *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_PointerTosrm2__TUserPermission(soap, "userPermissionArray", p, "srm2:TUserPermission"))
						break;
					soap_flag_userPermissionArray = 0;
				}
				a->userPermissionArray = (struct srm2__TUserPermission **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_userPermissionArray && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfTUserPermission *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfTUserPermission, 0, sizeof(struct srm2__ArrayOfTUserPermission), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__TUserPermission(struct soap *soap, const struct srm2__TUserPermission *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->userID);
	soap_embedded(soap, &a->mode, SOAP_TYPE_srm2__TPermissionMode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__TUserPermission(struct soap *soap, struct srm2__TUserPermission *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->userID);
	soap_default_srm2__TPermissionMode(soap, &a->mode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__TUserPermission(struct soap *soap, const struct srm2__TUserPermission *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__TUserPermission);
	if (soap_out_srm2__TUserPermission(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__TUserPermission(struct soap *soap, const char *tag, int id, const struct srm2__TUserPermission *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__TUserPermission), type);
	soap_out_string(soap, "userID", -1, &a->userID, "");
	soap_out_srm2__TPermissionMode(soap, "mode", -1, &a->mode, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__TUserPermission * SOAP_FMAC4 soap_get_srm2__TUserPermission(struct soap *soap, struct srm2__TUserPermission *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__TUserPermission(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TUserPermission * SOAP_FMAC4 soap_in_srm2__TUserPermission(struct soap *soap, const char *tag, struct srm2__TUserPermission *a, const char *type)
{
	short soap_flag_userID = 1, soap_flag_mode = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__TUserPermission *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__TUserPermission, sizeof(struct srm2__TUserPermission), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__TUserPermission(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userID", &a->userID, "xsd:string"))
				{	soap_flag_userID--;
					continue;
				}
			if (soap_flag_mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_srm2__TPermissionMode(soap, "mode", &a->mode, "srm2:TPermissionMode"))
				{	soap_flag_mode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_userID > 0 || soap_flag_mode > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__TUserPermission *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TUserPermission, 0, sizeof(struct srm2__TUserPermission), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_srm2__TRetentionPolicyInfo(struct soap *soap, const struct srm2__TRetentionPolicyInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosrm2__TAccessLatency(soap, &a->accessLatency);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_srm2__TRetentionPolicyInfo(struct soap *soap, struct srm2__TRetentionPolicyInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_srm2__TRetentionPolicy(soap, &a->retentionPolicy);
	a->accessLatency = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_srm2__TRetentionPolicyInfo(struct soap *soap, const struct srm2__TRetentionPolicyInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_srm2__TRetentionPolicyInfo);
	if (soap_out_srm2__TRetentionPolicyInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_srm2__TRetentionPolicyInfo(struct soap *soap, const char *tag, int id, const struct srm2__TRetentionPolicyInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_srm2__TRetentionPolicyInfo), type);
	soap_out_srm2__TRetentionPolicy(soap, "retentionPolicy", -1, &a->retentionPolicy, "");
	soap_out_PointerTosrm2__TAccessLatency(soap, "accessLatency", -1, &a->accessLatency, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct srm2__TRetentionPolicyInfo * SOAP_FMAC4 soap_get_srm2__TRetentionPolicyInfo(struct soap *soap, struct srm2__TRetentionPolicyInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_srm2__TRetentionPolicyInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TRetentionPolicyInfo * SOAP_FMAC4 soap_in_srm2__TRetentionPolicyInfo(struct soap *soap, const char *tag, struct srm2__TRetentionPolicyInfo *a, const char *type)
{
	short soap_flag_retentionPolicy = 1, soap_flag_accessLatency = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct srm2__TRetentionPolicyInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_srm2__TRetentionPolicyInfo, sizeof(struct srm2__TRetentionPolicyInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_srm2__TRetentionPolicyInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_retentionPolicy && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_srm2__TRetentionPolicy(soap, "retentionPolicy", &a->retentionPolicy, "srm2:TRetentionPolicy"))
				{	soap_flag_retentionPolicy--;
					continue;
				}
			if (soap_flag_accessLatency && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosrm2__TAccessLatency(soap, "accessLatency", &a->accessLatency, "srm2:TAccessLatency"))
				{	soap_flag_accessLatency--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_retentionPolicy > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct srm2__TRetentionPolicyInfo *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TRetentionPolicyInfo, 0, sizeof(struct srm2__TRetentionPolicyInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmPingResponse_(struct soap *soap, struct srm2__srmPingResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmPingResponse_))
		soap_serialize_srm2__srmPingResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmPingResponse_(struct soap *soap, struct srm2__srmPingResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmPingResponse_);
	if (soap_out_PointerTosrm2__srmPingResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmPingResponse_(struct soap *soap, const char *tag, int id, struct srm2__srmPingResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmPingResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmPingResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmPingResponse_ ** SOAP_FMAC4 soap_get_PointerTosrm2__srmPingResponse_(struct soap *soap, struct srm2__srmPingResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmPingResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmPingResponse_ ** SOAP_FMAC4 soap_in_PointerTosrm2__srmPingResponse_(struct soap *soap, const char *tag, struct srm2__srmPingResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmPingResponse_ **)soap_malloc(soap, sizeof(struct srm2__srmPingResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmPingResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmPingResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmPingResponse_, sizeof(struct srm2__srmPingResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmPingRequest(struct soap *soap, struct srm2__srmPingRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmPingRequest))
		soap_serialize_srm2__srmPingRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmPingRequest(struct soap *soap, struct srm2__srmPingRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmPingRequest);
	if (soap_out_PointerTosrm2__srmPingRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmPingRequest(struct soap *soap, const char *tag, int id, struct srm2__srmPingRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmPingRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmPingRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmPingRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__srmPingRequest(struct soap *soap, struct srm2__srmPingRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmPingRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmPingRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__srmPingRequest(struct soap *soap, const char *tag, struct srm2__srmPingRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmPingRequest **)soap_malloc(soap, sizeof(struct srm2__srmPingRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmPingRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmPingRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmPingRequest, sizeof(struct srm2__srmPingRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmPingResponse(struct soap *soap, struct srm2__srmPingResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmPingResponse))
		soap_serialize_srm2__srmPingResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmPingResponse(struct soap *soap, struct srm2__srmPingResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmPingResponse);
	if (soap_out_PointerTosrm2__srmPingResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmPingResponse(struct soap *soap, const char *tag, int id, struct srm2__srmPingResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmPingResponse);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmPingResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmPingResponse ** SOAP_FMAC4 soap_get_PointerTosrm2__srmPingResponse(struct soap *soap, struct srm2__srmPingResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmPingResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmPingResponse ** SOAP_FMAC4 soap_in_PointerTosrm2__srmPingResponse(struct soap *soap, const char *tag, struct srm2__srmPingResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmPingResponse **)soap_malloc(soap, sizeof(struct srm2__srmPingResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmPingResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmPingResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmPingResponse, sizeof(struct srm2__srmPingResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmGetTransferProtocolsResponse_(struct soap *soap, struct srm2__srmGetTransferProtocolsResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmGetTransferProtocolsResponse_))
		soap_serialize_srm2__srmGetTransferProtocolsResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmGetTransferProtocolsResponse_(struct soap *soap, struct srm2__srmGetTransferProtocolsResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmGetTransferProtocolsResponse_);
	if (soap_out_PointerTosrm2__srmGetTransferProtocolsResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmGetTransferProtocolsResponse_(struct soap *soap, const char *tag, int id, struct srm2__srmGetTransferProtocolsResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmGetTransferProtocolsResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmGetTransferProtocolsResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmGetTransferProtocolsResponse_ ** SOAP_FMAC4 soap_get_PointerTosrm2__srmGetTransferProtocolsResponse_(struct soap *soap, struct srm2__srmGetTransferProtocolsResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmGetTransferProtocolsResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetTransferProtocolsResponse_ ** SOAP_FMAC4 soap_in_PointerTosrm2__srmGetTransferProtocolsResponse_(struct soap *soap, const char *tag, struct srm2__srmGetTransferProtocolsResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmGetTransferProtocolsResponse_ **)soap_malloc(soap, sizeof(struct srm2__srmGetTransferProtocolsResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmGetTransferProtocolsResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetTransferProtocolsResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetTransferProtocolsResponse_, sizeof(struct srm2__srmGetTransferProtocolsResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmGetTransferProtocolsRequest(struct soap *soap, struct srm2__srmGetTransferProtocolsRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmGetTransferProtocolsRequest))
		soap_serialize_srm2__srmGetTransferProtocolsRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmGetTransferProtocolsRequest(struct soap *soap, struct srm2__srmGetTransferProtocolsRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmGetTransferProtocolsRequest);
	if (soap_out_PointerTosrm2__srmGetTransferProtocolsRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmGetTransferProtocolsRequest(struct soap *soap, const char *tag, int id, struct srm2__srmGetTransferProtocolsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmGetTransferProtocolsRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmGetTransferProtocolsRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmGetTransferProtocolsRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__srmGetTransferProtocolsRequest(struct soap *soap, struct srm2__srmGetTransferProtocolsRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmGetTransferProtocolsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetTransferProtocolsRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__srmGetTransferProtocolsRequest(struct soap *soap, const char *tag, struct srm2__srmGetTransferProtocolsRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmGetTransferProtocolsRequest **)soap_malloc(soap, sizeof(struct srm2__srmGetTransferProtocolsRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmGetTransferProtocolsRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetTransferProtocolsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetTransferProtocolsRequest, sizeof(struct srm2__srmGetTransferProtocolsRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmGetTransferProtocolsResponse(struct soap *soap, struct srm2__srmGetTransferProtocolsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmGetTransferProtocolsResponse))
		soap_serialize_srm2__srmGetTransferProtocolsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmGetTransferProtocolsResponse(struct soap *soap, struct srm2__srmGetTransferProtocolsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmGetTransferProtocolsResponse);
	if (soap_out_PointerTosrm2__srmGetTransferProtocolsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmGetTransferProtocolsResponse(struct soap *soap, const char *tag, int id, struct srm2__srmGetTransferProtocolsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmGetTransferProtocolsResponse);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmGetTransferProtocolsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmGetTransferProtocolsResponse ** SOAP_FMAC4 soap_get_PointerTosrm2__srmGetTransferProtocolsResponse(struct soap *soap, struct srm2__srmGetTransferProtocolsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmGetTransferProtocolsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetTransferProtocolsResponse ** SOAP_FMAC4 soap_in_PointerTosrm2__srmGetTransferProtocolsResponse(struct soap *soap, const char *tag, struct srm2__srmGetTransferProtocolsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmGetTransferProtocolsResponse **)soap_malloc(soap, sizeof(struct srm2__srmGetTransferProtocolsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmGetTransferProtocolsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetTransferProtocolsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetTransferProtocolsResponse, sizeof(struct srm2__srmGetTransferProtocolsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmGetRequestTokensResponse_(struct soap *soap, struct srm2__srmGetRequestTokensResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmGetRequestTokensResponse_))
		soap_serialize_srm2__srmGetRequestTokensResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmGetRequestTokensResponse_(struct soap *soap, struct srm2__srmGetRequestTokensResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmGetRequestTokensResponse_);
	if (soap_out_PointerTosrm2__srmGetRequestTokensResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmGetRequestTokensResponse_(struct soap *soap, const char *tag, int id, struct srm2__srmGetRequestTokensResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmGetRequestTokensResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmGetRequestTokensResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmGetRequestTokensResponse_ ** SOAP_FMAC4 soap_get_PointerTosrm2__srmGetRequestTokensResponse_(struct soap *soap, struct srm2__srmGetRequestTokensResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmGetRequestTokensResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetRequestTokensResponse_ ** SOAP_FMAC4 soap_in_PointerTosrm2__srmGetRequestTokensResponse_(struct soap *soap, const char *tag, struct srm2__srmGetRequestTokensResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmGetRequestTokensResponse_ **)soap_malloc(soap, sizeof(struct srm2__srmGetRequestTokensResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmGetRequestTokensResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetRequestTokensResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetRequestTokensResponse_, sizeof(struct srm2__srmGetRequestTokensResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmGetRequestTokensRequest(struct soap *soap, struct srm2__srmGetRequestTokensRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmGetRequestTokensRequest))
		soap_serialize_srm2__srmGetRequestTokensRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmGetRequestTokensRequest(struct soap *soap, struct srm2__srmGetRequestTokensRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmGetRequestTokensRequest);
	if (soap_out_PointerTosrm2__srmGetRequestTokensRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmGetRequestTokensRequest(struct soap *soap, const char *tag, int id, struct srm2__srmGetRequestTokensRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmGetRequestTokensRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmGetRequestTokensRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmGetRequestTokensRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__srmGetRequestTokensRequest(struct soap *soap, struct srm2__srmGetRequestTokensRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmGetRequestTokensRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetRequestTokensRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__srmGetRequestTokensRequest(struct soap *soap, const char *tag, struct srm2__srmGetRequestTokensRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmGetRequestTokensRequest **)soap_malloc(soap, sizeof(struct srm2__srmGetRequestTokensRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmGetRequestTokensRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetRequestTokensRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetRequestTokensRequest, sizeof(struct srm2__srmGetRequestTokensRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmGetRequestTokensResponse(struct soap *soap, struct srm2__srmGetRequestTokensResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmGetRequestTokensResponse))
		soap_serialize_srm2__srmGetRequestTokensResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmGetRequestTokensResponse(struct soap *soap, struct srm2__srmGetRequestTokensResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmGetRequestTokensResponse);
	if (soap_out_PointerTosrm2__srmGetRequestTokensResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmGetRequestTokensResponse(struct soap *soap, const char *tag, int id, struct srm2__srmGetRequestTokensResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmGetRequestTokensResponse);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmGetRequestTokensResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmGetRequestTokensResponse ** SOAP_FMAC4 soap_get_PointerTosrm2__srmGetRequestTokensResponse(struct soap *soap, struct srm2__srmGetRequestTokensResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmGetRequestTokensResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetRequestTokensResponse ** SOAP_FMAC4 soap_in_PointerTosrm2__srmGetRequestTokensResponse(struct soap *soap, const char *tag, struct srm2__srmGetRequestTokensResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmGetRequestTokensResponse **)soap_malloc(soap, sizeof(struct srm2__srmGetRequestTokensResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmGetRequestTokensResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetRequestTokensResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetRequestTokensResponse, sizeof(struct srm2__srmGetRequestTokensResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmExtendFileLifeTimeResponse_(struct soap *soap, struct srm2__srmExtendFileLifeTimeResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmExtendFileLifeTimeResponse_))
		soap_serialize_srm2__srmExtendFileLifeTimeResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmExtendFileLifeTimeResponse_(struct soap *soap, struct srm2__srmExtendFileLifeTimeResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmExtendFileLifeTimeResponse_);
	if (soap_out_PointerTosrm2__srmExtendFileLifeTimeResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmExtendFileLifeTimeResponse_(struct soap *soap, const char *tag, int id, struct srm2__srmExtendFileLifeTimeResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmExtendFileLifeTimeResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmExtendFileLifeTimeResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmExtendFileLifeTimeResponse_ ** SOAP_FMAC4 soap_get_PointerTosrm2__srmExtendFileLifeTimeResponse_(struct soap *soap, struct srm2__srmExtendFileLifeTimeResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmExtendFileLifeTimeResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmExtendFileLifeTimeResponse_ ** SOAP_FMAC4 soap_in_PointerTosrm2__srmExtendFileLifeTimeResponse_(struct soap *soap, const char *tag, struct srm2__srmExtendFileLifeTimeResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmExtendFileLifeTimeResponse_ **)soap_malloc(soap, sizeof(struct srm2__srmExtendFileLifeTimeResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmExtendFileLifeTimeResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmExtendFileLifeTimeResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmExtendFileLifeTimeResponse_, sizeof(struct srm2__srmExtendFileLifeTimeResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmExtendFileLifeTimeRequest(struct soap *soap, struct srm2__srmExtendFileLifeTimeRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmExtendFileLifeTimeRequest))
		soap_serialize_srm2__srmExtendFileLifeTimeRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmExtendFileLifeTimeRequest(struct soap *soap, struct srm2__srmExtendFileLifeTimeRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmExtendFileLifeTimeRequest);
	if (soap_out_PointerTosrm2__srmExtendFileLifeTimeRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmExtendFileLifeTimeRequest(struct soap *soap, const char *tag, int id, struct srm2__srmExtendFileLifeTimeRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmExtendFileLifeTimeRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmExtendFileLifeTimeRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmExtendFileLifeTimeRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__srmExtendFileLifeTimeRequest(struct soap *soap, struct srm2__srmExtendFileLifeTimeRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmExtendFileLifeTimeRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmExtendFileLifeTimeRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__srmExtendFileLifeTimeRequest(struct soap *soap, const char *tag, struct srm2__srmExtendFileLifeTimeRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmExtendFileLifeTimeRequest **)soap_malloc(soap, sizeof(struct srm2__srmExtendFileLifeTimeRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmExtendFileLifeTimeRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmExtendFileLifeTimeRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmExtendFileLifeTimeRequest, sizeof(struct srm2__srmExtendFileLifeTimeRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmExtendFileLifeTimeResponse(struct soap *soap, struct srm2__srmExtendFileLifeTimeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmExtendFileLifeTimeResponse))
		soap_serialize_srm2__srmExtendFileLifeTimeResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmExtendFileLifeTimeResponse(struct soap *soap, struct srm2__srmExtendFileLifeTimeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmExtendFileLifeTimeResponse);
	if (soap_out_PointerTosrm2__srmExtendFileLifeTimeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmExtendFileLifeTimeResponse(struct soap *soap, const char *tag, int id, struct srm2__srmExtendFileLifeTimeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmExtendFileLifeTimeResponse);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmExtendFileLifeTimeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmExtendFileLifeTimeResponse ** SOAP_FMAC4 soap_get_PointerTosrm2__srmExtendFileLifeTimeResponse(struct soap *soap, struct srm2__srmExtendFileLifeTimeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmExtendFileLifeTimeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmExtendFileLifeTimeResponse ** SOAP_FMAC4 soap_in_PointerTosrm2__srmExtendFileLifeTimeResponse(struct soap *soap, const char *tag, struct srm2__srmExtendFileLifeTimeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmExtendFileLifeTimeResponse **)soap_malloc(soap, sizeof(struct srm2__srmExtendFileLifeTimeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmExtendFileLifeTimeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmExtendFileLifeTimeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmExtendFileLifeTimeResponse, sizeof(struct srm2__srmExtendFileLifeTimeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmGetRequestSummaryResponse_(struct soap *soap, struct srm2__srmGetRequestSummaryResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmGetRequestSummaryResponse_))
		soap_serialize_srm2__srmGetRequestSummaryResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmGetRequestSummaryResponse_(struct soap *soap, struct srm2__srmGetRequestSummaryResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmGetRequestSummaryResponse_);
	if (soap_out_PointerTosrm2__srmGetRequestSummaryResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmGetRequestSummaryResponse_(struct soap *soap, const char *tag, int id, struct srm2__srmGetRequestSummaryResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmGetRequestSummaryResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmGetRequestSummaryResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmGetRequestSummaryResponse_ ** SOAP_FMAC4 soap_get_PointerTosrm2__srmGetRequestSummaryResponse_(struct soap *soap, struct srm2__srmGetRequestSummaryResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmGetRequestSummaryResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetRequestSummaryResponse_ ** SOAP_FMAC4 soap_in_PointerTosrm2__srmGetRequestSummaryResponse_(struct soap *soap, const char *tag, struct srm2__srmGetRequestSummaryResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmGetRequestSummaryResponse_ **)soap_malloc(soap, sizeof(struct srm2__srmGetRequestSummaryResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmGetRequestSummaryResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetRequestSummaryResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetRequestSummaryResponse_, sizeof(struct srm2__srmGetRequestSummaryResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmGetRequestSummaryRequest(struct soap *soap, struct srm2__srmGetRequestSummaryRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmGetRequestSummaryRequest))
		soap_serialize_srm2__srmGetRequestSummaryRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmGetRequestSummaryRequest(struct soap *soap, struct srm2__srmGetRequestSummaryRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmGetRequestSummaryRequest);
	if (soap_out_PointerTosrm2__srmGetRequestSummaryRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmGetRequestSummaryRequest(struct soap *soap, const char *tag, int id, struct srm2__srmGetRequestSummaryRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmGetRequestSummaryRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmGetRequestSummaryRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmGetRequestSummaryRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__srmGetRequestSummaryRequest(struct soap *soap, struct srm2__srmGetRequestSummaryRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmGetRequestSummaryRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetRequestSummaryRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__srmGetRequestSummaryRequest(struct soap *soap, const char *tag, struct srm2__srmGetRequestSummaryRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmGetRequestSummaryRequest **)soap_malloc(soap, sizeof(struct srm2__srmGetRequestSummaryRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmGetRequestSummaryRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetRequestSummaryRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetRequestSummaryRequest, sizeof(struct srm2__srmGetRequestSummaryRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmGetRequestSummaryResponse(struct soap *soap, struct srm2__srmGetRequestSummaryResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmGetRequestSummaryResponse))
		soap_serialize_srm2__srmGetRequestSummaryResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmGetRequestSummaryResponse(struct soap *soap, struct srm2__srmGetRequestSummaryResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmGetRequestSummaryResponse);
	if (soap_out_PointerTosrm2__srmGetRequestSummaryResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmGetRequestSummaryResponse(struct soap *soap, const char *tag, int id, struct srm2__srmGetRequestSummaryResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmGetRequestSummaryResponse);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmGetRequestSummaryResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmGetRequestSummaryResponse ** SOAP_FMAC4 soap_get_PointerTosrm2__srmGetRequestSummaryResponse(struct soap *soap, struct srm2__srmGetRequestSummaryResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmGetRequestSummaryResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetRequestSummaryResponse ** SOAP_FMAC4 soap_in_PointerTosrm2__srmGetRequestSummaryResponse(struct soap *soap, const char *tag, struct srm2__srmGetRequestSummaryResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmGetRequestSummaryResponse **)soap_malloc(soap, sizeof(struct srm2__srmGetRequestSummaryResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmGetRequestSummaryResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetRequestSummaryResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetRequestSummaryResponse, sizeof(struct srm2__srmGetRequestSummaryResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmResumeRequestResponse_(struct soap *soap, struct srm2__srmResumeRequestResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmResumeRequestResponse_))
		soap_serialize_srm2__srmResumeRequestResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmResumeRequestResponse_(struct soap *soap, struct srm2__srmResumeRequestResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmResumeRequestResponse_);
	if (soap_out_PointerTosrm2__srmResumeRequestResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmResumeRequestResponse_(struct soap *soap, const char *tag, int id, struct srm2__srmResumeRequestResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmResumeRequestResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmResumeRequestResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmResumeRequestResponse_ ** SOAP_FMAC4 soap_get_PointerTosrm2__srmResumeRequestResponse_(struct soap *soap, struct srm2__srmResumeRequestResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmResumeRequestResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmResumeRequestResponse_ ** SOAP_FMAC4 soap_in_PointerTosrm2__srmResumeRequestResponse_(struct soap *soap, const char *tag, struct srm2__srmResumeRequestResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmResumeRequestResponse_ **)soap_malloc(soap, sizeof(struct srm2__srmResumeRequestResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmResumeRequestResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmResumeRequestResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmResumeRequestResponse_, sizeof(struct srm2__srmResumeRequestResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmResumeRequestRequest(struct soap *soap, struct srm2__srmResumeRequestRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmResumeRequestRequest))
		soap_serialize_srm2__srmResumeRequestRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmResumeRequestRequest(struct soap *soap, struct srm2__srmResumeRequestRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmResumeRequestRequest);
	if (soap_out_PointerTosrm2__srmResumeRequestRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmResumeRequestRequest(struct soap *soap, const char *tag, int id, struct srm2__srmResumeRequestRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmResumeRequestRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmResumeRequestRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmResumeRequestRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__srmResumeRequestRequest(struct soap *soap, struct srm2__srmResumeRequestRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmResumeRequestRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmResumeRequestRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__srmResumeRequestRequest(struct soap *soap, const char *tag, struct srm2__srmResumeRequestRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmResumeRequestRequest **)soap_malloc(soap, sizeof(struct srm2__srmResumeRequestRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmResumeRequestRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmResumeRequestRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmResumeRequestRequest, sizeof(struct srm2__srmResumeRequestRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmResumeRequestResponse(struct soap *soap, struct srm2__srmResumeRequestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmResumeRequestResponse))
		soap_serialize_srm2__srmResumeRequestResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmResumeRequestResponse(struct soap *soap, struct srm2__srmResumeRequestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmResumeRequestResponse);
	if (soap_out_PointerTosrm2__srmResumeRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmResumeRequestResponse(struct soap *soap, const char *tag, int id, struct srm2__srmResumeRequestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmResumeRequestResponse);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmResumeRequestResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmResumeRequestResponse ** SOAP_FMAC4 soap_get_PointerTosrm2__srmResumeRequestResponse(struct soap *soap, struct srm2__srmResumeRequestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmResumeRequestResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmResumeRequestResponse ** SOAP_FMAC4 soap_in_PointerTosrm2__srmResumeRequestResponse(struct soap *soap, const char *tag, struct srm2__srmResumeRequestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmResumeRequestResponse **)soap_malloc(soap, sizeof(struct srm2__srmResumeRequestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmResumeRequestResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmResumeRequestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmResumeRequestResponse, sizeof(struct srm2__srmResumeRequestResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmSuspendRequestResponse_(struct soap *soap, struct srm2__srmSuspendRequestResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmSuspendRequestResponse_))
		soap_serialize_srm2__srmSuspendRequestResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmSuspendRequestResponse_(struct soap *soap, struct srm2__srmSuspendRequestResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmSuspendRequestResponse_);
	if (soap_out_PointerTosrm2__srmSuspendRequestResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmSuspendRequestResponse_(struct soap *soap, const char *tag, int id, struct srm2__srmSuspendRequestResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmSuspendRequestResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmSuspendRequestResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmSuspendRequestResponse_ ** SOAP_FMAC4 soap_get_PointerTosrm2__srmSuspendRequestResponse_(struct soap *soap, struct srm2__srmSuspendRequestResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmSuspendRequestResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmSuspendRequestResponse_ ** SOAP_FMAC4 soap_in_PointerTosrm2__srmSuspendRequestResponse_(struct soap *soap, const char *tag, struct srm2__srmSuspendRequestResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmSuspendRequestResponse_ **)soap_malloc(soap, sizeof(struct srm2__srmSuspendRequestResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmSuspendRequestResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmSuspendRequestResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmSuspendRequestResponse_, sizeof(struct srm2__srmSuspendRequestResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmSuspendRequestRequest(struct soap *soap, struct srm2__srmSuspendRequestRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmSuspendRequestRequest))
		soap_serialize_srm2__srmSuspendRequestRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmSuspendRequestRequest(struct soap *soap, struct srm2__srmSuspendRequestRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmSuspendRequestRequest);
	if (soap_out_PointerTosrm2__srmSuspendRequestRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmSuspendRequestRequest(struct soap *soap, const char *tag, int id, struct srm2__srmSuspendRequestRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmSuspendRequestRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmSuspendRequestRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmSuspendRequestRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__srmSuspendRequestRequest(struct soap *soap, struct srm2__srmSuspendRequestRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmSuspendRequestRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmSuspendRequestRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__srmSuspendRequestRequest(struct soap *soap, const char *tag, struct srm2__srmSuspendRequestRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmSuspendRequestRequest **)soap_malloc(soap, sizeof(struct srm2__srmSuspendRequestRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmSuspendRequestRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmSuspendRequestRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmSuspendRequestRequest, sizeof(struct srm2__srmSuspendRequestRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmSuspendRequestResponse(struct soap *soap, struct srm2__srmSuspendRequestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmSuspendRequestResponse))
		soap_serialize_srm2__srmSuspendRequestResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmSuspendRequestResponse(struct soap *soap, struct srm2__srmSuspendRequestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmSuspendRequestResponse);
	if (soap_out_PointerTosrm2__srmSuspendRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmSuspendRequestResponse(struct soap *soap, const char *tag, int id, struct srm2__srmSuspendRequestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmSuspendRequestResponse);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmSuspendRequestResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmSuspendRequestResponse ** SOAP_FMAC4 soap_get_PointerTosrm2__srmSuspendRequestResponse(struct soap *soap, struct srm2__srmSuspendRequestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmSuspendRequestResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmSuspendRequestResponse ** SOAP_FMAC4 soap_in_PointerTosrm2__srmSuspendRequestResponse(struct soap *soap, const char *tag, struct srm2__srmSuspendRequestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmSuspendRequestResponse **)soap_malloc(soap, sizeof(struct srm2__srmSuspendRequestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmSuspendRequestResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmSuspendRequestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmSuspendRequestResponse, sizeof(struct srm2__srmSuspendRequestResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmAbortFilesResponse_(struct soap *soap, struct srm2__srmAbortFilesResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmAbortFilesResponse_))
		soap_serialize_srm2__srmAbortFilesResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmAbortFilesResponse_(struct soap *soap, struct srm2__srmAbortFilesResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmAbortFilesResponse_);
	if (soap_out_PointerTosrm2__srmAbortFilesResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmAbortFilesResponse_(struct soap *soap, const char *tag, int id, struct srm2__srmAbortFilesResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmAbortFilesResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmAbortFilesResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmAbortFilesResponse_ ** SOAP_FMAC4 soap_get_PointerTosrm2__srmAbortFilesResponse_(struct soap *soap, struct srm2__srmAbortFilesResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmAbortFilesResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmAbortFilesResponse_ ** SOAP_FMAC4 soap_in_PointerTosrm2__srmAbortFilesResponse_(struct soap *soap, const char *tag, struct srm2__srmAbortFilesResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmAbortFilesResponse_ **)soap_malloc(soap, sizeof(struct srm2__srmAbortFilesResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmAbortFilesResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmAbortFilesResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmAbortFilesResponse_, sizeof(struct srm2__srmAbortFilesResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmAbortFilesRequest(struct soap *soap, struct srm2__srmAbortFilesRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmAbortFilesRequest))
		soap_serialize_srm2__srmAbortFilesRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmAbortFilesRequest(struct soap *soap, struct srm2__srmAbortFilesRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmAbortFilesRequest);
	if (soap_out_PointerTosrm2__srmAbortFilesRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmAbortFilesRequest(struct soap *soap, const char *tag, int id, struct srm2__srmAbortFilesRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmAbortFilesRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmAbortFilesRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmAbortFilesRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__srmAbortFilesRequest(struct soap *soap, struct srm2__srmAbortFilesRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmAbortFilesRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmAbortFilesRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__srmAbortFilesRequest(struct soap *soap, const char *tag, struct srm2__srmAbortFilesRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmAbortFilesRequest **)soap_malloc(soap, sizeof(struct srm2__srmAbortFilesRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmAbortFilesRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmAbortFilesRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmAbortFilesRequest, sizeof(struct srm2__srmAbortFilesRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmAbortFilesResponse(struct soap *soap, struct srm2__srmAbortFilesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmAbortFilesResponse))
		soap_serialize_srm2__srmAbortFilesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmAbortFilesResponse(struct soap *soap, struct srm2__srmAbortFilesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmAbortFilesResponse);
	if (soap_out_PointerTosrm2__srmAbortFilesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmAbortFilesResponse(struct soap *soap, const char *tag, int id, struct srm2__srmAbortFilesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmAbortFilesResponse);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmAbortFilesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmAbortFilesResponse ** SOAP_FMAC4 soap_get_PointerTosrm2__srmAbortFilesResponse(struct soap *soap, struct srm2__srmAbortFilesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmAbortFilesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmAbortFilesResponse ** SOAP_FMAC4 soap_in_PointerTosrm2__srmAbortFilesResponse(struct soap *soap, const char *tag, struct srm2__srmAbortFilesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmAbortFilesResponse **)soap_malloc(soap, sizeof(struct srm2__srmAbortFilesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmAbortFilesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmAbortFilesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmAbortFilesResponse, sizeof(struct srm2__srmAbortFilesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmAbortRequestResponse_(struct soap *soap, struct srm2__srmAbortRequestResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmAbortRequestResponse_))
		soap_serialize_srm2__srmAbortRequestResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmAbortRequestResponse_(struct soap *soap, struct srm2__srmAbortRequestResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmAbortRequestResponse_);
	if (soap_out_PointerTosrm2__srmAbortRequestResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmAbortRequestResponse_(struct soap *soap, const char *tag, int id, struct srm2__srmAbortRequestResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmAbortRequestResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmAbortRequestResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmAbortRequestResponse_ ** SOAP_FMAC4 soap_get_PointerTosrm2__srmAbortRequestResponse_(struct soap *soap, struct srm2__srmAbortRequestResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmAbortRequestResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmAbortRequestResponse_ ** SOAP_FMAC4 soap_in_PointerTosrm2__srmAbortRequestResponse_(struct soap *soap, const char *tag, struct srm2__srmAbortRequestResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmAbortRequestResponse_ **)soap_malloc(soap, sizeof(struct srm2__srmAbortRequestResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmAbortRequestResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmAbortRequestResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmAbortRequestResponse_, sizeof(struct srm2__srmAbortRequestResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmAbortRequestRequest(struct soap *soap, struct srm2__srmAbortRequestRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmAbortRequestRequest))
		soap_serialize_srm2__srmAbortRequestRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmAbortRequestRequest(struct soap *soap, struct srm2__srmAbortRequestRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmAbortRequestRequest);
	if (soap_out_PointerTosrm2__srmAbortRequestRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmAbortRequestRequest(struct soap *soap, const char *tag, int id, struct srm2__srmAbortRequestRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmAbortRequestRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmAbortRequestRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmAbortRequestRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__srmAbortRequestRequest(struct soap *soap, struct srm2__srmAbortRequestRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmAbortRequestRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmAbortRequestRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__srmAbortRequestRequest(struct soap *soap, const char *tag, struct srm2__srmAbortRequestRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmAbortRequestRequest **)soap_malloc(soap, sizeof(struct srm2__srmAbortRequestRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmAbortRequestRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmAbortRequestRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmAbortRequestRequest, sizeof(struct srm2__srmAbortRequestRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmAbortRequestResponse(struct soap *soap, struct srm2__srmAbortRequestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmAbortRequestResponse))
		soap_serialize_srm2__srmAbortRequestResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmAbortRequestResponse(struct soap *soap, struct srm2__srmAbortRequestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmAbortRequestResponse);
	if (soap_out_PointerTosrm2__srmAbortRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmAbortRequestResponse(struct soap *soap, const char *tag, int id, struct srm2__srmAbortRequestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmAbortRequestResponse);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmAbortRequestResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmAbortRequestResponse ** SOAP_FMAC4 soap_get_PointerTosrm2__srmAbortRequestResponse(struct soap *soap, struct srm2__srmAbortRequestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmAbortRequestResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmAbortRequestResponse ** SOAP_FMAC4 soap_in_PointerTosrm2__srmAbortRequestResponse(struct soap *soap, const char *tag, struct srm2__srmAbortRequestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmAbortRequestResponse **)soap_malloc(soap, sizeof(struct srm2__srmAbortRequestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmAbortRequestResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmAbortRequestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmAbortRequestResponse, sizeof(struct srm2__srmAbortRequestResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmPutDoneResponse_(struct soap *soap, struct srm2__srmPutDoneResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmPutDoneResponse_))
		soap_serialize_srm2__srmPutDoneResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmPutDoneResponse_(struct soap *soap, struct srm2__srmPutDoneResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmPutDoneResponse_);
	if (soap_out_PointerTosrm2__srmPutDoneResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmPutDoneResponse_(struct soap *soap, const char *tag, int id, struct srm2__srmPutDoneResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmPutDoneResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmPutDoneResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmPutDoneResponse_ ** SOAP_FMAC4 soap_get_PointerTosrm2__srmPutDoneResponse_(struct soap *soap, struct srm2__srmPutDoneResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmPutDoneResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmPutDoneResponse_ ** SOAP_FMAC4 soap_in_PointerTosrm2__srmPutDoneResponse_(struct soap *soap, const char *tag, struct srm2__srmPutDoneResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmPutDoneResponse_ **)soap_malloc(soap, sizeof(struct srm2__srmPutDoneResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmPutDoneResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmPutDoneResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmPutDoneResponse_, sizeof(struct srm2__srmPutDoneResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmPutDoneRequest(struct soap *soap, struct srm2__srmPutDoneRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmPutDoneRequest))
		soap_serialize_srm2__srmPutDoneRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmPutDoneRequest(struct soap *soap, struct srm2__srmPutDoneRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmPutDoneRequest);
	if (soap_out_PointerTosrm2__srmPutDoneRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmPutDoneRequest(struct soap *soap, const char *tag, int id, struct srm2__srmPutDoneRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmPutDoneRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmPutDoneRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmPutDoneRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__srmPutDoneRequest(struct soap *soap, struct srm2__srmPutDoneRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmPutDoneRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmPutDoneRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__srmPutDoneRequest(struct soap *soap, const char *tag, struct srm2__srmPutDoneRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmPutDoneRequest **)soap_malloc(soap, sizeof(struct srm2__srmPutDoneRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmPutDoneRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmPutDoneRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmPutDoneRequest, sizeof(struct srm2__srmPutDoneRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmPutDoneResponse(struct soap *soap, struct srm2__srmPutDoneResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmPutDoneResponse))
		soap_serialize_srm2__srmPutDoneResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmPutDoneResponse(struct soap *soap, struct srm2__srmPutDoneResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmPutDoneResponse);
	if (soap_out_PointerTosrm2__srmPutDoneResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmPutDoneResponse(struct soap *soap, const char *tag, int id, struct srm2__srmPutDoneResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmPutDoneResponse);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmPutDoneResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmPutDoneResponse ** SOAP_FMAC4 soap_get_PointerTosrm2__srmPutDoneResponse(struct soap *soap, struct srm2__srmPutDoneResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmPutDoneResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmPutDoneResponse ** SOAP_FMAC4 soap_in_PointerTosrm2__srmPutDoneResponse(struct soap *soap, const char *tag, struct srm2__srmPutDoneResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmPutDoneResponse **)soap_malloc(soap, sizeof(struct srm2__srmPutDoneResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmPutDoneResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmPutDoneResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmPutDoneResponse, sizeof(struct srm2__srmPutDoneResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmReleaseFilesResponse_(struct soap *soap, struct srm2__srmReleaseFilesResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmReleaseFilesResponse_))
		soap_serialize_srm2__srmReleaseFilesResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmReleaseFilesResponse_(struct soap *soap, struct srm2__srmReleaseFilesResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmReleaseFilesResponse_);
	if (soap_out_PointerTosrm2__srmReleaseFilesResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmReleaseFilesResponse_(struct soap *soap, const char *tag, int id, struct srm2__srmReleaseFilesResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmReleaseFilesResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmReleaseFilesResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmReleaseFilesResponse_ ** SOAP_FMAC4 soap_get_PointerTosrm2__srmReleaseFilesResponse_(struct soap *soap, struct srm2__srmReleaseFilesResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmReleaseFilesResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmReleaseFilesResponse_ ** SOAP_FMAC4 soap_in_PointerTosrm2__srmReleaseFilesResponse_(struct soap *soap, const char *tag, struct srm2__srmReleaseFilesResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmReleaseFilesResponse_ **)soap_malloc(soap, sizeof(struct srm2__srmReleaseFilesResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmReleaseFilesResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmReleaseFilesResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmReleaseFilesResponse_, sizeof(struct srm2__srmReleaseFilesResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmReleaseFilesRequest(struct soap *soap, struct srm2__srmReleaseFilesRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmReleaseFilesRequest))
		soap_serialize_srm2__srmReleaseFilesRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmReleaseFilesRequest(struct soap *soap, struct srm2__srmReleaseFilesRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmReleaseFilesRequest);
	if (soap_out_PointerTosrm2__srmReleaseFilesRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmReleaseFilesRequest(struct soap *soap, const char *tag, int id, struct srm2__srmReleaseFilesRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmReleaseFilesRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmReleaseFilesRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmReleaseFilesRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__srmReleaseFilesRequest(struct soap *soap, struct srm2__srmReleaseFilesRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmReleaseFilesRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmReleaseFilesRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__srmReleaseFilesRequest(struct soap *soap, const char *tag, struct srm2__srmReleaseFilesRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmReleaseFilesRequest **)soap_malloc(soap, sizeof(struct srm2__srmReleaseFilesRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmReleaseFilesRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmReleaseFilesRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmReleaseFilesRequest, sizeof(struct srm2__srmReleaseFilesRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmReleaseFilesResponse(struct soap *soap, struct srm2__srmReleaseFilesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmReleaseFilesResponse))
		soap_serialize_srm2__srmReleaseFilesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmReleaseFilesResponse(struct soap *soap, struct srm2__srmReleaseFilesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmReleaseFilesResponse);
	if (soap_out_PointerTosrm2__srmReleaseFilesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmReleaseFilesResponse(struct soap *soap, const char *tag, int id, struct srm2__srmReleaseFilesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmReleaseFilesResponse);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmReleaseFilesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmReleaseFilesResponse ** SOAP_FMAC4 soap_get_PointerTosrm2__srmReleaseFilesResponse(struct soap *soap, struct srm2__srmReleaseFilesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmReleaseFilesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmReleaseFilesResponse ** SOAP_FMAC4 soap_in_PointerTosrm2__srmReleaseFilesResponse(struct soap *soap, const char *tag, struct srm2__srmReleaseFilesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmReleaseFilesResponse **)soap_malloc(soap, sizeof(struct srm2__srmReleaseFilesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmReleaseFilesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmReleaseFilesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmReleaseFilesResponse, sizeof(struct srm2__srmReleaseFilesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmStatusOfCopyRequestResponse_(struct soap *soap, struct srm2__srmStatusOfCopyRequestResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmStatusOfCopyRequestResponse_))
		soap_serialize_srm2__srmStatusOfCopyRequestResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmStatusOfCopyRequestResponse_(struct soap *soap, struct srm2__srmStatusOfCopyRequestResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmStatusOfCopyRequestResponse_);
	if (soap_out_PointerTosrm2__srmStatusOfCopyRequestResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmStatusOfCopyRequestResponse_(struct soap *soap, const char *tag, int id, struct srm2__srmStatusOfCopyRequestResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmStatusOfCopyRequestResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmStatusOfCopyRequestResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmStatusOfCopyRequestResponse_ ** SOAP_FMAC4 soap_get_PointerTosrm2__srmStatusOfCopyRequestResponse_(struct soap *soap, struct srm2__srmStatusOfCopyRequestResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmStatusOfCopyRequestResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfCopyRequestResponse_ ** SOAP_FMAC4 soap_in_PointerTosrm2__srmStatusOfCopyRequestResponse_(struct soap *soap, const char *tag, struct srm2__srmStatusOfCopyRequestResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmStatusOfCopyRequestResponse_ **)soap_malloc(soap, sizeof(struct srm2__srmStatusOfCopyRequestResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmStatusOfCopyRequestResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfCopyRequestResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfCopyRequestResponse_, sizeof(struct srm2__srmStatusOfCopyRequestResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmStatusOfCopyRequestRequest(struct soap *soap, struct srm2__srmStatusOfCopyRequestRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmStatusOfCopyRequestRequest))
		soap_serialize_srm2__srmStatusOfCopyRequestRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmStatusOfCopyRequestRequest(struct soap *soap, struct srm2__srmStatusOfCopyRequestRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmStatusOfCopyRequestRequest);
	if (soap_out_PointerTosrm2__srmStatusOfCopyRequestRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmStatusOfCopyRequestRequest(struct soap *soap, const char *tag, int id, struct srm2__srmStatusOfCopyRequestRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmStatusOfCopyRequestRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmStatusOfCopyRequestRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmStatusOfCopyRequestRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__srmStatusOfCopyRequestRequest(struct soap *soap, struct srm2__srmStatusOfCopyRequestRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmStatusOfCopyRequestRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfCopyRequestRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__srmStatusOfCopyRequestRequest(struct soap *soap, const char *tag, struct srm2__srmStatusOfCopyRequestRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmStatusOfCopyRequestRequest **)soap_malloc(soap, sizeof(struct srm2__srmStatusOfCopyRequestRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmStatusOfCopyRequestRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfCopyRequestRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfCopyRequestRequest, sizeof(struct srm2__srmStatusOfCopyRequestRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmStatusOfCopyRequestResponse(struct soap *soap, struct srm2__srmStatusOfCopyRequestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmStatusOfCopyRequestResponse))
		soap_serialize_srm2__srmStatusOfCopyRequestResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmStatusOfCopyRequestResponse(struct soap *soap, struct srm2__srmStatusOfCopyRequestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmStatusOfCopyRequestResponse);
	if (soap_out_PointerTosrm2__srmStatusOfCopyRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmStatusOfCopyRequestResponse(struct soap *soap, const char *tag, int id, struct srm2__srmStatusOfCopyRequestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmStatusOfCopyRequestResponse);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmStatusOfCopyRequestResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmStatusOfCopyRequestResponse ** SOAP_FMAC4 soap_get_PointerTosrm2__srmStatusOfCopyRequestResponse(struct soap *soap, struct srm2__srmStatusOfCopyRequestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmStatusOfCopyRequestResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfCopyRequestResponse ** SOAP_FMAC4 soap_in_PointerTosrm2__srmStatusOfCopyRequestResponse(struct soap *soap, const char *tag, struct srm2__srmStatusOfCopyRequestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmStatusOfCopyRequestResponse **)soap_malloc(soap, sizeof(struct srm2__srmStatusOfCopyRequestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmStatusOfCopyRequestResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfCopyRequestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfCopyRequestResponse, sizeof(struct srm2__srmStatusOfCopyRequestResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmCopyResponse_(struct soap *soap, struct srm2__srmCopyResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmCopyResponse_))
		soap_serialize_srm2__srmCopyResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmCopyResponse_(struct soap *soap, struct srm2__srmCopyResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmCopyResponse_);
	if (soap_out_PointerTosrm2__srmCopyResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmCopyResponse_(struct soap *soap, const char *tag, int id, struct srm2__srmCopyResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmCopyResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmCopyResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmCopyResponse_ ** SOAP_FMAC4 soap_get_PointerTosrm2__srmCopyResponse_(struct soap *soap, struct srm2__srmCopyResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmCopyResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmCopyResponse_ ** SOAP_FMAC4 soap_in_PointerTosrm2__srmCopyResponse_(struct soap *soap, const char *tag, struct srm2__srmCopyResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmCopyResponse_ **)soap_malloc(soap, sizeof(struct srm2__srmCopyResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmCopyResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmCopyResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmCopyResponse_, sizeof(struct srm2__srmCopyResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmCopyRequest(struct soap *soap, struct srm2__srmCopyRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmCopyRequest))
		soap_serialize_srm2__srmCopyRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmCopyRequest(struct soap *soap, struct srm2__srmCopyRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmCopyRequest);
	if (soap_out_PointerTosrm2__srmCopyRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmCopyRequest(struct soap *soap, const char *tag, int id, struct srm2__srmCopyRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmCopyRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmCopyRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmCopyRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__srmCopyRequest(struct soap *soap, struct srm2__srmCopyRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmCopyRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmCopyRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__srmCopyRequest(struct soap *soap, const char *tag, struct srm2__srmCopyRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmCopyRequest **)soap_malloc(soap, sizeof(struct srm2__srmCopyRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmCopyRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmCopyRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmCopyRequest, sizeof(struct srm2__srmCopyRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmCopyResponse(struct soap *soap, struct srm2__srmCopyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmCopyResponse))
		soap_serialize_srm2__srmCopyResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmCopyResponse(struct soap *soap, struct srm2__srmCopyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmCopyResponse);
	if (soap_out_PointerTosrm2__srmCopyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmCopyResponse(struct soap *soap, const char *tag, int id, struct srm2__srmCopyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmCopyResponse);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmCopyResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmCopyResponse ** SOAP_FMAC4 soap_get_PointerTosrm2__srmCopyResponse(struct soap *soap, struct srm2__srmCopyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmCopyResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmCopyResponse ** SOAP_FMAC4 soap_in_PointerTosrm2__srmCopyResponse(struct soap *soap, const char *tag, struct srm2__srmCopyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmCopyResponse **)soap_malloc(soap, sizeof(struct srm2__srmCopyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmCopyResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmCopyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmCopyResponse, sizeof(struct srm2__srmCopyResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmStatusOfPutRequestResponse_(struct soap *soap, struct srm2__srmStatusOfPutRequestResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmStatusOfPutRequestResponse_))
		soap_serialize_srm2__srmStatusOfPutRequestResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmStatusOfPutRequestResponse_(struct soap *soap, struct srm2__srmStatusOfPutRequestResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmStatusOfPutRequestResponse_);
	if (soap_out_PointerTosrm2__srmStatusOfPutRequestResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmStatusOfPutRequestResponse_(struct soap *soap, const char *tag, int id, struct srm2__srmStatusOfPutRequestResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmStatusOfPutRequestResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmStatusOfPutRequestResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmStatusOfPutRequestResponse_ ** SOAP_FMAC4 soap_get_PointerTosrm2__srmStatusOfPutRequestResponse_(struct soap *soap, struct srm2__srmStatusOfPutRequestResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmStatusOfPutRequestResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfPutRequestResponse_ ** SOAP_FMAC4 soap_in_PointerTosrm2__srmStatusOfPutRequestResponse_(struct soap *soap, const char *tag, struct srm2__srmStatusOfPutRequestResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmStatusOfPutRequestResponse_ **)soap_malloc(soap, sizeof(struct srm2__srmStatusOfPutRequestResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmStatusOfPutRequestResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfPutRequestResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfPutRequestResponse_, sizeof(struct srm2__srmStatusOfPutRequestResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmStatusOfPutRequestRequest(struct soap *soap, struct srm2__srmStatusOfPutRequestRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmStatusOfPutRequestRequest))
		soap_serialize_srm2__srmStatusOfPutRequestRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmStatusOfPutRequestRequest(struct soap *soap, struct srm2__srmStatusOfPutRequestRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmStatusOfPutRequestRequest);
	if (soap_out_PointerTosrm2__srmStatusOfPutRequestRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmStatusOfPutRequestRequest(struct soap *soap, const char *tag, int id, struct srm2__srmStatusOfPutRequestRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmStatusOfPutRequestRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmStatusOfPutRequestRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmStatusOfPutRequestRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__srmStatusOfPutRequestRequest(struct soap *soap, struct srm2__srmStatusOfPutRequestRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmStatusOfPutRequestRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfPutRequestRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__srmStatusOfPutRequestRequest(struct soap *soap, const char *tag, struct srm2__srmStatusOfPutRequestRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmStatusOfPutRequestRequest **)soap_malloc(soap, sizeof(struct srm2__srmStatusOfPutRequestRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmStatusOfPutRequestRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfPutRequestRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfPutRequestRequest, sizeof(struct srm2__srmStatusOfPutRequestRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmStatusOfPutRequestResponse(struct soap *soap, struct srm2__srmStatusOfPutRequestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmStatusOfPutRequestResponse))
		soap_serialize_srm2__srmStatusOfPutRequestResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmStatusOfPutRequestResponse(struct soap *soap, struct srm2__srmStatusOfPutRequestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmStatusOfPutRequestResponse);
	if (soap_out_PointerTosrm2__srmStatusOfPutRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmStatusOfPutRequestResponse(struct soap *soap, const char *tag, int id, struct srm2__srmStatusOfPutRequestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmStatusOfPutRequestResponse);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmStatusOfPutRequestResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmStatusOfPutRequestResponse ** SOAP_FMAC4 soap_get_PointerTosrm2__srmStatusOfPutRequestResponse(struct soap *soap, struct srm2__srmStatusOfPutRequestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmStatusOfPutRequestResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfPutRequestResponse ** SOAP_FMAC4 soap_in_PointerTosrm2__srmStatusOfPutRequestResponse(struct soap *soap, const char *tag, struct srm2__srmStatusOfPutRequestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmStatusOfPutRequestResponse **)soap_malloc(soap, sizeof(struct srm2__srmStatusOfPutRequestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmStatusOfPutRequestResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfPutRequestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfPutRequestResponse, sizeof(struct srm2__srmStatusOfPutRequestResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmPrepareToPutResponse_(struct soap *soap, struct srm2__srmPrepareToPutResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmPrepareToPutResponse_))
		soap_serialize_srm2__srmPrepareToPutResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmPrepareToPutResponse_(struct soap *soap, struct srm2__srmPrepareToPutResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmPrepareToPutResponse_);
	if (soap_out_PointerTosrm2__srmPrepareToPutResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmPrepareToPutResponse_(struct soap *soap, const char *tag, int id, struct srm2__srmPrepareToPutResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmPrepareToPutResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmPrepareToPutResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmPrepareToPutResponse_ ** SOAP_FMAC4 soap_get_PointerTosrm2__srmPrepareToPutResponse_(struct soap *soap, struct srm2__srmPrepareToPutResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmPrepareToPutResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmPrepareToPutResponse_ ** SOAP_FMAC4 soap_in_PointerTosrm2__srmPrepareToPutResponse_(struct soap *soap, const char *tag, struct srm2__srmPrepareToPutResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmPrepareToPutResponse_ **)soap_malloc(soap, sizeof(struct srm2__srmPrepareToPutResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmPrepareToPutResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmPrepareToPutResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmPrepareToPutResponse_, sizeof(struct srm2__srmPrepareToPutResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmPrepareToPutRequest(struct soap *soap, struct srm2__srmPrepareToPutRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmPrepareToPutRequest))
		soap_serialize_srm2__srmPrepareToPutRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmPrepareToPutRequest(struct soap *soap, struct srm2__srmPrepareToPutRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmPrepareToPutRequest);
	if (soap_out_PointerTosrm2__srmPrepareToPutRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmPrepareToPutRequest(struct soap *soap, const char *tag, int id, struct srm2__srmPrepareToPutRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmPrepareToPutRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmPrepareToPutRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmPrepareToPutRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__srmPrepareToPutRequest(struct soap *soap, struct srm2__srmPrepareToPutRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmPrepareToPutRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmPrepareToPutRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__srmPrepareToPutRequest(struct soap *soap, const char *tag, struct srm2__srmPrepareToPutRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmPrepareToPutRequest **)soap_malloc(soap, sizeof(struct srm2__srmPrepareToPutRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmPrepareToPutRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmPrepareToPutRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmPrepareToPutRequest, sizeof(struct srm2__srmPrepareToPutRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmPrepareToPutResponse(struct soap *soap, struct srm2__srmPrepareToPutResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmPrepareToPutResponse))
		soap_serialize_srm2__srmPrepareToPutResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmPrepareToPutResponse(struct soap *soap, struct srm2__srmPrepareToPutResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmPrepareToPutResponse);
	if (soap_out_PointerTosrm2__srmPrepareToPutResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmPrepareToPutResponse(struct soap *soap, const char *tag, int id, struct srm2__srmPrepareToPutResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmPrepareToPutResponse);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmPrepareToPutResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmPrepareToPutResponse ** SOAP_FMAC4 soap_get_PointerTosrm2__srmPrepareToPutResponse(struct soap *soap, struct srm2__srmPrepareToPutResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmPrepareToPutResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmPrepareToPutResponse ** SOAP_FMAC4 soap_in_PointerTosrm2__srmPrepareToPutResponse(struct soap *soap, const char *tag, struct srm2__srmPrepareToPutResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmPrepareToPutResponse **)soap_malloc(soap, sizeof(struct srm2__srmPrepareToPutResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmPrepareToPutResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmPrepareToPutResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmPrepareToPutResponse, sizeof(struct srm2__srmPrepareToPutResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmStatusOfBringOnlineRequestResponse_(struct soap *soap, struct srm2__srmStatusOfBringOnlineRequestResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmStatusOfBringOnlineRequestResponse_))
		soap_serialize_srm2__srmStatusOfBringOnlineRequestResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmStatusOfBringOnlineRequestResponse_(struct soap *soap, struct srm2__srmStatusOfBringOnlineRequestResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmStatusOfBringOnlineRequestResponse_);
	if (soap_out_PointerTosrm2__srmStatusOfBringOnlineRequestResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmStatusOfBringOnlineRequestResponse_(struct soap *soap, const char *tag, int id, struct srm2__srmStatusOfBringOnlineRequestResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmStatusOfBringOnlineRequestResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmStatusOfBringOnlineRequestResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmStatusOfBringOnlineRequestResponse_ ** SOAP_FMAC4 soap_get_PointerTosrm2__srmStatusOfBringOnlineRequestResponse_(struct soap *soap, struct srm2__srmStatusOfBringOnlineRequestResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmStatusOfBringOnlineRequestResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfBringOnlineRequestResponse_ ** SOAP_FMAC4 soap_in_PointerTosrm2__srmStatusOfBringOnlineRequestResponse_(struct soap *soap, const char *tag, struct srm2__srmStatusOfBringOnlineRequestResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmStatusOfBringOnlineRequestResponse_ **)soap_malloc(soap, sizeof(struct srm2__srmStatusOfBringOnlineRequestResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmStatusOfBringOnlineRequestResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfBringOnlineRequestResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfBringOnlineRequestResponse_, sizeof(struct srm2__srmStatusOfBringOnlineRequestResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmStatusOfBringOnlineRequestRequest(struct soap *soap, struct srm2__srmStatusOfBringOnlineRequestRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmStatusOfBringOnlineRequestRequest))
		soap_serialize_srm2__srmStatusOfBringOnlineRequestRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmStatusOfBringOnlineRequestRequest(struct soap *soap, struct srm2__srmStatusOfBringOnlineRequestRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmStatusOfBringOnlineRequestRequest);
	if (soap_out_PointerTosrm2__srmStatusOfBringOnlineRequestRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmStatusOfBringOnlineRequestRequest(struct soap *soap, const char *tag, int id, struct srm2__srmStatusOfBringOnlineRequestRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmStatusOfBringOnlineRequestRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmStatusOfBringOnlineRequestRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmStatusOfBringOnlineRequestRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__srmStatusOfBringOnlineRequestRequest(struct soap *soap, struct srm2__srmStatusOfBringOnlineRequestRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmStatusOfBringOnlineRequestRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfBringOnlineRequestRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__srmStatusOfBringOnlineRequestRequest(struct soap *soap, const char *tag, struct srm2__srmStatusOfBringOnlineRequestRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmStatusOfBringOnlineRequestRequest **)soap_malloc(soap, sizeof(struct srm2__srmStatusOfBringOnlineRequestRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmStatusOfBringOnlineRequestRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfBringOnlineRequestRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfBringOnlineRequestRequest, sizeof(struct srm2__srmStatusOfBringOnlineRequestRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmStatusOfBringOnlineRequestResponse(struct soap *soap, struct srm2__srmStatusOfBringOnlineRequestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmStatusOfBringOnlineRequestResponse))
		soap_serialize_srm2__srmStatusOfBringOnlineRequestResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmStatusOfBringOnlineRequestResponse(struct soap *soap, struct srm2__srmStatusOfBringOnlineRequestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmStatusOfBringOnlineRequestResponse);
	if (soap_out_PointerTosrm2__srmStatusOfBringOnlineRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmStatusOfBringOnlineRequestResponse(struct soap *soap, const char *tag, int id, struct srm2__srmStatusOfBringOnlineRequestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmStatusOfBringOnlineRequestResponse);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmStatusOfBringOnlineRequestResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmStatusOfBringOnlineRequestResponse ** SOAP_FMAC4 soap_get_PointerTosrm2__srmStatusOfBringOnlineRequestResponse(struct soap *soap, struct srm2__srmStatusOfBringOnlineRequestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmStatusOfBringOnlineRequestResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfBringOnlineRequestResponse ** SOAP_FMAC4 soap_in_PointerTosrm2__srmStatusOfBringOnlineRequestResponse(struct soap *soap, const char *tag, struct srm2__srmStatusOfBringOnlineRequestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmStatusOfBringOnlineRequestResponse **)soap_malloc(soap, sizeof(struct srm2__srmStatusOfBringOnlineRequestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmStatusOfBringOnlineRequestResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfBringOnlineRequestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfBringOnlineRequestResponse, sizeof(struct srm2__srmStatusOfBringOnlineRequestResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmBringOnlineResponse_(struct soap *soap, struct srm2__srmBringOnlineResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmBringOnlineResponse_))
		soap_serialize_srm2__srmBringOnlineResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmBringOnlineResponse_(struct soap *soap, struct srm2__srmBringOnlineResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmBringOnlineResponse_);
	if (soap_out_PointerTosrm2__srmBringOnlineResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmBringOnlineResponse_(struct soap *soap, const char *tag, int id, struct srm2__srmBringOnlineResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmBringOnlineResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmBringOnlineResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmBringOnlineResponse_ ** SOAP_FMAC4 soap_get_PointerTosrm2__srmBringOnlineResponse_(struct soap *soap, struct srm2__srmBringOnlineResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmBringOnlineResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmBringOnlineResponse_ ** SOAP_FMAC4 soap_in_PointerTosrm2__srmBringOnlineResponse_(struct soap *soap, const char *tag, struct srm2__srmBringOnlineResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmBringOnlineResponse_ **)soap_malloc(soap, sizeof(struct srm2__srmBringOnlineResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmBringOnlineResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmBringOnlineResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmBringOnlineResponse_, sizeof(struct srm2__srmBringOnlineResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmBringOnlineRequest(struct soap *soap, struct srm2__srmBringOnlineRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmBringOnlineRequest))
		soap_serialize_srm2__srmBringOnlineRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmBringOnlineRequest(struct soap *soap, struct srm2__srmBringOnlineRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmBringOnlineRequest);
	if (soap_out_PointerTosrm2__srmBringOnlineRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmBringOnlineRequest(struct soap *soap, const char *tag, int id, struct srm2__srmBringOnlineRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmBringOnlineRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmBringOnlineRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmBringOnlineRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__srmBringOnlineRequest(struct soap *soap, struct srm2__srmBringOnlineRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmBringOnlineRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmBringOnlineRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__srmBringOnlineRequest(struct soap *soap, const char *tag, struct srm2__srmBringOnlineRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmBringOnlineRequest **)soap_malloc(soap, sizeof(struct srm2__srmBringOnlineRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmBringOnlineRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmBringOnlineRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmBringOnlineRequest, sizeof(struct srm2__srmBringOnlineRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmBringOnlineResponse(struct soap *soap, struct srm2__srmBringOnlineResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmBringOnlineResponse))
		soap_serialize_srm2__srmBringOnlineResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmBringOnlineResponse(struct soap *soap, struct srm2__srmBringOnlineResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmBringOnlineResponse);
	if (soap_out_PointerTosrm2__srmBringOnlineResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmBringOnlineResponse(struct soap *soap, const char *tag, int id, struct srm2__srmBringOnlineResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmBringOnlineResponse);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmBringOnlineResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmBringOnlineResponse ** SOAP_FMAC4 soap_get_PointerTosrm2__srmBringOnlineResponse(struct soap *soap, struct srm2__srmBringOnlineResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmBringOnlineResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmBringOnlineResponse ** SOAP_FMAC4 soap_in_PointerTosrm2__srmBringOnlineResponse(struct soap *soap, const char *tag, struct srm2__srmBringOnlineResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmBringOnlineResponse **)soap_malloc(soap, sizeof(struct srm2__srmBringOnlineResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmBringOnlineResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmBringOnlineResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmBringOnlineResponse, sizeof(struct srm2__srmBringOnlineResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmStatusOfGetRequestResponse_(struct soap *soap, struct srm2__srmStatusOfGetRequestResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmStatusOfGetRequestResponse_))
		soap_serialize_srm2__srmStatusOfGetRequestResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmStatusOfGetRequestResponse_(struct soap *soap, struct srm2__srmStatusOfGetRequestResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmStatusOfGetRequestResponse_);
	if (soap_out_PointerTosrm2__srmStatusOfGetRequestResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmStatusOfGetRequestResponse_(struct soap *soap, const char *tag, int id, struct srm2__srmStatusOfGetRequestResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmStatusOfGetRequestResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmStatusOfGetRequestResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmStatusOfGetRequestResponse_ ** SOAP_FMAC4 soap_get_PointerTosrm2__srmStatusOfGetRequestResponse_(struct soap *soap, struct srm2__srmStatusOfGetRequestResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmStatusOfGetRequestResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfGetRequestResponse_ ** SOAP_FMAC4 soap_in_PointerTosrm2__srmStatusOfGetRequestResponse_(struct soap *soap, const char *tag, struct srm2__srmStatusOfGetRequestResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmStatusOfGetRequestResponse_ **)soap_malloc(soap, sizeof(struct srm2__srmStatusOfGetRequestResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmStatusOfGetRequestResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfGetRequestResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfGetRequestResponse_, sizeof(struct srm2__srmStatusOfGetRequestResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmStatusOfGetRequestRequest(struct soap *soap, struct srm2__srmStatusOfGetRequestRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmStatusOfGetRequestRequest))
		soap_serialize_srm2__srmStatusOfGetRequestRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmStatusOfGetRequestRequest(struct soap *soap, struct srm2__srmStatusOfGetRequestRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmStatusOfGetRequestRequest);
	if (soap_out_PointerTosrm2__srmStatusOfGetRequestRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmStatusOfGetRequestRequest(struct soap *soap, const char *tag, int id, struct srm2__srmStatusOfGetRequestRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmStatusOfGetRequestRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmStatusOfGetRequestRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmStatusOfGetRequestRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__srmStatusOfGetRequestRequest(struct soap *soap, struct srm2__srmStatusOfGetRequestRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmStatusOfGetRequestRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfGetRequestRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__srmStatusOfGetRequestRequest(struct soap *soap, const char *tag, struct srm2__srmStatusOfGetRequestRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmStatusOfGetRequestRequest **)soap_malloc(soap, sizeof(struct srm2__srmStatusOfGetRequestRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmStatusOfGetRequestRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfGetRequestRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfGetRequestRequest, sizeof(struct srm2__srmStatusOfGetRequestRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmStatusOfGetRequestResponse(struct soap *soap, struct srm2__srmStatusOfGetRequestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmStatusOfGetRequestResponse))
		soap_serialize_srm2__srmStatusOfGetRequestResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmStatusOfGetRequestResponse(struct soap *soap, struct srm2__srmStatusOfGetRequestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmStatusOfGetRequestResponse);
	if (soap_out_PointerTosrm2__srmStatusOfGetRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmStatusOfGetRequestResponse(struct soap *soap, const char *tag, int id, struct srm2__srmStatusOfGetRequestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmStatusOfGetRequestResponse);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmStatusOfGetRequestResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmStatusOfGetRequestResponse ** SOAP_FMAC4 soap_get_PointerTosrm2__srmStatusOfGetRequestResponse(struct soap *soap, struct srm2__srmStatusOfGetRequestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmStatusOfGetRequestResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfGetRequestResponse ** SOAP_FMAC4 soap_in_PointerTosrm2__srmStatusOfGetRequestResponse(struct soap *soap, const char *tag, struct srm2__srmStatusOfGetRequestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmStatusOfGetRequestResponse **)soap_malloc(soap, sizeof(struct srm2__srmStatusOfGetRequestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmStatusOfGetRequestResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfGetRequestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfGetRequestResponse, sizeof(struct srm2__srmStatusOfGetRequestResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmPrepareToGetResponse_(struct soap *soap, struct srm2__srmPrepareToGetResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmPrepareToGetResponse_))
		soap_serialize_srm2__srmPrepareToGetResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmPrepareToGetResponse_(struct soap *soap, struct srm2__srmPrepareToGetResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmPrepareToGetResponse_);
	if (soap_out_PointerTosrm2__srmPrepareToGetResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmPrepareToGetResponse_(struct soap *soap, const char *tag, int id, struct srm2__srmPrepareToGetResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmPrepareToGetResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmPrepareToGetResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmPrepareToGetResponse_ ** SOAP_FMAC4 soap_get_PointerTosrm2__srmPrepareToGetResponse_(struct soap *soap, struct srm2__srmPrepareToGetResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmPrepareToGetResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmPrepareToGetResponse_ ** SOAP_FMAC4 soap_in_PointerTosrm2__srmPrepareToGetResponse_(struct soap *soap, const char *tag, struct srm2__srmPrepareToGetResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmPrepareToGetResponse_ **)soap_malloc(soap, sizeof(struct srm2__srmPrepareToGetResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmPrepareToGetResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmPrepareToGetResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmPrepareToGetResponse_, sizeof(struct srm2__srmPrepareToGetResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmPrepareToGetRequest(struct soap *soap, struct srm2__srmPrepareToGetRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmPrepareToGetRequest))
		soap_serialize_srm2__srmPrepareToGetRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmPrepareToGetRequest(struct soap *soap, struct srm2__srmPrepareToGetRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmPrepareToGetRequest);
	if (soap_out_PointerTosrm2__srmPrepareToGetRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmPrepareToGetRequest(struct soap *soap, const char *tag, int id, struct srm2__srmPrepareToGetRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmPrepareToGetRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmPrepareToGetRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmPrepareToGetRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__srmPrepareToGetRequest(struct soap *soap, struct srm2__srmPrepareToGetRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmPrepareToGetRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmPrepareToGetRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__srmPrepareToGetRequest(struct soap *soap, const char *tag, struct srm2__srmPrepareToGetRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmPrepareToGetRequest **)soap_malloc(soap, sizeof(struct srm2__srmPrepareToGetRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmPrepareToGetRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmPrepareToGetRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmPrepareToGetRequest, sizeof(struct srm2__srmPrepareToGetRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmPrepareToGetResponse(struct soap *soap, struct srm2__srmPrepareToGetResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmPrepareToGetResponse))
		soap_serialize_srm2__srmPrepareToGetResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmPrepareToGetResponse(struct soap *soap, struct srm2__srmPrepareToGetResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmPrepareToGetResponse);
	if (soap_out_PointerTosrm2__srmPrepareToGetResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmPrepareToGetResponse(struct soap *soap, const char *tag, int id, struct srm2__srmPrepareToGetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmPrepareToGetResponse);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmPrepareToGetResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmPrepareToGetResponse ** SOAP_FMAC4 soap_get_PointerTosrm2__srmPrepareToGetResponse(struct soap *soap, struct srm2__srmPrepareToGetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmPrepareToGetResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmPrepareToGetResponse ** SOAP_FMAC4 soap_in_PointerTosrm2__srmPrepareToGetResponse(struct soap *soap, const char *tag, struct srm2__srmPrepareToGetResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmPrepareToGetResponse **)soap_malloc(soap, sizeof(struct srm2__srmPrepareToGetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmPrepareToGetResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmPrepareToGetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmPrepareToGetResponse, sizeof(struct srm2__srmPrepareToGetResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmMvResponse_(struct soap *soap, struct srm2__srmMvResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmMvResponse_))
		soap_serialize_srm2__srmMvResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmMvResponse_(struct soap *soap, struct srm2__srmMvResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmMvResponse_);
	if (soap_out_PointerTosrm2__srmMvResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmMvResponse_(struct soap *soap, const char *tag, int id, struct srm2__srmMvResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmMvResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmMvResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmMvResponse_ ** SOAP_FMAC4 soap_get_PointerTosrm2__srmMvResponse_(struct soap *soap, struct srm2__srmMvResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmMvResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmMvResponse_ ** SOAP_FMAC4 soap_in_PointerTosrm2__srmMvResponse_(struct soap *soap, const char *tag, struct srm2__srmMvResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmMvResponse_ **)soap_malloc(soap, sizeof(struct srm2__srmMvResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmMvResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmMvResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmMvResponse_, sizeof(struct srm2__srmMvResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmMvRequest(struct soap *soap, struct srm2__srmMvRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmMvRequest))
		soap_serialize_srm2__srmMvRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmMvRequest(struct soap *soap, struct srm2__srmMvRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmMvRequest);
	if (soap_out_PointerTosrm2__srmMvRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmMvRequest(struct soap *soap, const char *tag, int id, struct srm2__srmMvRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmMvRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmMvRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmMvRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__srmMvRequest(struct soap *soap, struct srm2__srmMvRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmMvRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmMvRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__srmMvRequest(struct soap *soap, const char *tag, struct srm2__srmMvRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmMvRequest **)soap_malloc(soap, sizeof(struct srm2__srmMvRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmMvRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmMvRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmMvRequest, sizeof(struct srm2__srmMvRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmMvResponse(struct soap *soap, struct srm2__srmMvResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmMvResponse))
		soap_serialize_srm2__srmMvResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmMvResponse(struct soap *soap, struct srm2__srmMvResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmMvResponse);
	if (soap_out_PointerTosrm2__srmMvResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmMvResponse(struct soap *soap, const char *tag, int id, struct srm2__srmMvResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmMvResponse);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmMvResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmMvResponse ** SOAP_FMAC4 soap_get_PointerTosrm2__srmMvResponse(struct soap *soap, struct srm2__srmMvResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmMvResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmMvResponse ** SOAP_FMAC4 soap_in_PointerTosrm2__srmMvResponse(struct soap *soap, const char *tag, struct srm2__srmMvResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmMvResponse **)soap_malloc(soap, sizeof(struct srm2__srmMvResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmMvResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmMvResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmMvResponse, sizeof(struct srm2__srmMvResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmStatusOfLsRequestResponse_(struct soap *soap, struct srm2__srmStatusOfLsRequestResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmStatusOfLsRequestResponse_))
		soap_serialize_srm2__srmStatusOfLsRequestResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmStatusOfLsRequestResponse_(struct soap *soap, struct srm2__srmStatusOfLsRequestResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmStatusOfLsRequestResponse_);
	if (soap_out_PointerTosrm2__srmStatusOfLsRequestResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmStatusOfLsRequestResponse_(struct soap *soap, const char *tag, int id, struct srm2__srmStatusOfLsRequestResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmStatusOfLsRequestResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmStatusOfLsRequestResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmStatusOfLsRequestResponse_ ** SOAP_FMAC4 soap_get_PointerTosrm2__srmStatusOfLsRequestResponse_(struct soap *soap, struct srm2__srmStatusOfLsRequestResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmStatusOfLsRequestResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfLsRequestResponse_ ** SOAP_FMAC4 soap_in_PointerTosrm2__srmStatusOfLsRequestResponse_(struct soap *soap, const char *tag, struct srm2__srmStatusOfLsRequestResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmStatusOfLsRequestResponse_ **)soap_malloc(soap, sizeof(struct srm2__srmStatusOfLsRequestResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmStatusOfLsRequestResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfLsRequestResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfLsRequestResponse_, sizeof(struct srm2__srmStatusOfLsRequestResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmStatusOfLsRequestRequest(struct soap *soap, struct srm2__srmStatusOfLsRequestRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmStatusOfLsRequestRequest))
		soap_serialize_srm2__srmStatusOfLsRequestRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmStatusOfLsRequestRequest(struct soap *soap, struct srm2__srmStatusOfLsRequestRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmStatusOfLsRequestRequest);
	if (soap_out_PointerTosrm2__srmStatusOfLsRequestRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmStatusOfLsRequestRequest(struct soap *soap, const char *tag, int id, struct srm2__srmStatusOfLsRequestRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmStatusOfLsRequestRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmStatusOfLsRequestRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmStatusOfLsRequestRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__srmStatusOfLsRequestRequest(struct soap *soap, struct srm2__srmStatusOfLsRequestRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmStatusOfLsRequestRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfLsRequestRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__srmStatusOfLsRequestRequest(struct soap *soap, const char *tag, struct srm2__srmStatusOfLsRequestRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmStatusOfLsRequestRequest **)soap_malloc(soap, sizeof(struct srm2__srmStatusOfLsRequestRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmStatusOfLsRequestRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfLsRequestRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfLsRequestRequest, sizeof(struct srm2__srmStatusOfLsRequestRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmStatusOfLsRequestResponse(struct soap *soap, struct srm2__srmStatusOfLsRequestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmStatusOfLsRequestResponse))
		soap_serialize_srm2__srmStatusOfLsRequestResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmStatusOfLsRequestResponse(struct soap *soap, struct srm2__srmStatusOfLsRequestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmStatusOfLsRequestResponse);
	if (soap_out_PointerTosrm2__srmStatusOfLsRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmStatusOfLsRequestResponse(struct soap *soap, const char *tag, int id, struct srm2__srmStatusOfLsRequestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmStatusOfLsRequestResponse);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmStatusOfLsRequestResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmStatusOfLsRequestResponse ** SOAP_FMAC4 soap_get_PointerTosrm2__srmStatusOfLsRequestResponse(struct soap *soap, struct srm2__srmStatusOfLsRequestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmStatusOfLsRequestResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfLsRequestResponse ** SOAP_FMAC4 soap_in_PointerTosrm2__srmStatusOfLsRequestResponse(struct soap *soap, const char *tag, struct srm2__srmStatusOfLsRequestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmStatusOfLsRequestResponse **)soap_malloc(soap, sizeof(struct srm2__srmStatusOfLsRequestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmStatusOfLsRequestResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfLsRequestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfLsRequestResponse, sizeof(struct srm2__srmStatusOfLsRequestResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmLsResponse_(struct soap *soap, struct srm2__srmLsResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmLsResponse_))
		soap_serialize_srm2__srmLsResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmLsResponse_(struct soap *soap, struct srm2__srmLsResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmLsResponse_);
	if (soap_out_PointerTosrm2__srmLsResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmLsResponse_(struct soap *soap, const char *tag, int id, struct srm2__srmLsResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmLsResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmLsResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmLsResponse_ ** SOAP_FMAC4 soap_get_PointerTosrm2__srmLsResponse_(struct soap *soap, struct srm2__srmLsResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmLsResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmLsResponse_ ** SOAP_FMAC4 soap_in_PointerTosrm2__srmLsResponse_(struct soap *soap, const char *tag, struct srm2__srmLsResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmLsResponse_ **)soap_malloc(soap, sizeof(struct srm2__srmLsResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmLsResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmLsResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmLsResponse_, sizeof(struct srm2__srmLsResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmLsRequest(struct soap *soap, struct srm2__srmLsRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmLsRequest))
		soap_serialize_srm2__srmLsRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmLsRequest(struct soap *soap, struct srm2__srmLsRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmLsRequest);
	if (soap_out_PointerTosrm2__srmLsRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmLsRequest(struct soap *soap, const char *tag, int id, struct srm2__srmLsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmLsRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmLsRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmLsRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__srmLsRequest(struct soap *soap, struct srm2__srmLsRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmLsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmLsRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__srmLsRequest(struct soap *soap, const char *tag, struct srm2__srmLsRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmLsRequest **)soap_malloc(soap, sizeof(struct srm2__srmLsRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmLsRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmLsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmLsRequest, sizeof(struct srm2__srmLsRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmLsResponse(struct soap *soap, struct srm2__srmLsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmLsResponse))
		soap_serialize_srm2__srmLsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmLsResponse(struct soap *soap, struct srm2__srmLsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmLsResponse);
	if (soap_out_PointerTosrm2__srmLsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmLsResponse(struct soap *soap, const char *tag, int id, struct srm2__srmLsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmLsResponse);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmLsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmLsResponse ** SOAP_FMAC4 soap_get_PointerTosrm2__srmLsResponse(struct soap *soap, struct srm2__srmLsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmLsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmLsResponse ** SOAP_FMAC4 soap_in_PointerTosrm2__srmLsResponse(struct soap *soap, const char *tag, struct srm2__srmLsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmLsResponse **)soap_malloc(soap, sizeof(struct srm2__srmLsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmLsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmLsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmLsResponse, sizeof(struct srm2__srmLsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmRmResponse_(struct soap *soap, struct srm2__srmRmResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmRmResponse_))
		soap_serialize_srm2__srmRmResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmRmResponse_(struct soap *soap, struct srm2__srmRmResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmRmResponse_);
	if (soap_out_PointerTosrm2__srmRmResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmRmResponse_(struct soap *soap, const char *tag, int id, struct srm2__srmRmResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmRmResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmRmResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmRmResponse_ ** SOAP_FMAC4 soap_get_PointerTosrm2__srmRmResponse_(struct soap *soap, struct srm2__srmRmResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmRmResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmRmResponse_ ** SOAP_FMAC4 soap_in_PointerTosrm2__srmRmResponse_(struct soap *soap, const char *tag, struct srm2__srmRmResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmRmResponse_ **)soap_malloc(soap, sizeof(struct srm2__srmRmResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmRmResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmRmResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmRmResponse_, sizeof(struct srm2__srmRmResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmRmRequest(struct soap *soap, struct srm2__srmRmRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmRmRequest))
		soap_serialize_srm2__srmRmRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmRmRequest(struct soap *soap, struct srm2__srmRmRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmRmRequest);
	if (soap_out_PointerTosrm2__srmRmRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmRmRequest(struct soap *soap, const char *tag, int id, struct srm2__srmRmRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmRmRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmRmRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmRmRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__srmRmRequest(struct soap *soap, struct srm2__srmRmRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmRmRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmRmRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__srmRmRequest(struct soap *soap, const char *tag, struct srm2__srmRmRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmRmRequest **)soap_malloc(soap, sizeof(struct srm2__srmRmRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmRmRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmRmRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmRmRequest, sizeof(struct srm2__srmRmRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmRmResponse(struct soap *soap, struct srm2__srmRmResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmRmResponse))
		soap_serialize_srm2__srmRmResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmRmResponse(struct soap *soap, struct srm2__srmRmResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmRmResponse);
	if (soap_out_PointerTosrm2__srmRmResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmRmResponse(struct soap *soap, const char *tag, int id, struct srm2__srmRmResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmRmResponse);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmRmResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmRmResponse ** SOAP_FMAC4 soap_get_PointerTosrm2__srmRmResponse(struct soap *soap, struct srm2__srmRmResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmRmResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmRmResponse ** SOAP_FMAC4 soap_in_PointerTosrm2__srmRmResponse(struct soap *soap, const char *tag, struct srm2__srmRmResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmRmResponse **)soap_malloc(soap, sizeof(struct srm2__srmRmResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmRmResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmRmResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmRmResponse, sizeof(struct srm2__srmRmResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmRmdirResponse_(struct soap *soap, struct srm2__srmRmdirResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmRmdirResponse_))
		soap_serialize_srm2__srmRmdirResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmRmdirResponse_(struct soap *soap, struct srm2__srmRmdirResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmRmdirResponse_);
	if (soap_out_PointerTosrm2__srmRmdirResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmRmdirResponse_(struct soap *soap, const char *tag, int id, struct srm2__srmRmdirResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmRmdirResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmRmdirResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmRmdirResponse_ ** SOAP_FMAC4 soap_get_PointerTosrm2__srmRmdirResponse_(struct soap *soap, struct srm2__srmRmdirResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmRmdirResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmRmdirResponse_ ** SOAP_FMAC4 soap_in_PointerTosrm2__srmRmdirResponse_(struct soap *soap, const char *tag, struct srm2__srmRmdirResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmRmdirResponse_ **)soap_malloc(soap, sizeof(struct srm2__srmRmdirResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmRmdirResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmRmdirResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmRmdirResponse_, sizeof(struct srm2__srmRmdirResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmRmdirRequest(struct soap *soap, struct srm2__srmRmdirRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmRmdirRequest))
		soap_serialize_srm2__srmRmdirRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmRmdirRequest(struct soap *soap, struct srm2__srmRmdirRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmRmdirRequest);
	if (soap_out_PointerTosrm2__srmRmdirRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmRmdirRequest(struct soap *soap, const char *tag, int id, struct srm2__srmRmdirRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmRmdirRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmRmdirRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmRmdirRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__srmRmdirRequest(struct soap *soap, struct srm2__srmRmdirRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmRmdirRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmRmdirRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__srmRmdirRequest(struct soap *soap, const char *tag, struct srm2__srmRmdirRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmRmdirRequest **)soap_malloc(soap, sizeof(struct srm2__srmRmdirRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmRmdirRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmRmdirRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmRmdirRequest, sizeof(struct srm2__srmRmdirRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmRmdirResponse(struct soap *soap, struct srm2__srmRmdirResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmRmdirResponse))
		soap_serialize_srm2__srmRmdirResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmRmdirResponse(struct soap *soap, struct srm2__srmRmdirResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmRmdirResponse);
	if (soap_out_PointerTosrm2__srmRmdirResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmRmdirResponse(struct soap *soap, const char *tag, int id, struct srm2__srmRmdirResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmRmdirResponse);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmRmdirResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmRmdirResponse ** SOAP_FMAC4 soap_get_PointerTosrm2__srmRmdirResponse(struct soap *soap, struct srm2__srmRmdirResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmRmdirResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmRmdirResponse ** SOAP_FMAC4 soap_in_PointerTosrm2__srmRmdirResponse(struct soap *soap, const char *tag, struct srm2__srmRmdirResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmRmdirResponse **)soap_malloc(soap, sizeof(struct srm2__srmRmdirResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmRmdirResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmRmdirResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmRmdirResponse, sizeof(struct srm2__srmRmdirResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmMkdirResponse_(struct soap *soap, struct srm2__srmMkdirResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmMkdirResponse_))
		soap_serialize_srm2__srmMkdirResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmMkdirResponse_(struct soap *soap, struct srm2__srmMkdirResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmMkdirResponse_);
	if (soap_out_PointerTosrm2__srmMkdirResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmMkdirResponse_(struct soap *soap, const char *tag, int id, struct srm2__srmMkdirResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmMkdirResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmMkdirResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmMkdirResponse_ ** SOAP_FMAC4 soap_get_PointerTosrm2__srmMkdirResponse_(struct soap *soap, struct srm2__srmMkdirResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmMkdirResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmMkdirResponse_ ** SOAP_FMAC4 soap_in_PointerTosrm2__srmMkdirResponse_(struct soap *soap, const char *tag, struct srm2__srmMkdirResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmMkdirResponse_ **)soap_malloc(soap, sizeof(struct srm2__srmMkdirResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmMkdirResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmMkdirResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmMkdirResponse_, sizeof(struct srm2__srmMkdirResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmMkdirRequest(struct soap *soap, struct srm2__srmMkdirRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmMkdirRequest))
		soap_serialize_srm2__srmMkdirRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmMkdirRequest(struct soap *soap, struct srm2__srmMkdirRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmMkdirRequest);
	if (soap_out_PointerTosrm2__srmMkdirRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmMkdirRequest(struct soap *soap, const char *tag, int id, struct srm2__srmMkdirRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmMkdirRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmMkdirRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmMkdirRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__srmMkdirRequest(struct soap *soap, struct srm2__srmMkdirRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmMkdirRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmMkdirRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__srmMkdirRequest(struct soap *soap, const char *tag, struct srm2__srmMkdirRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmMkdirRequest **)soap_malloc(soap, sizeof(struct srm2__srmMkdirRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmMkdirRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmMkdirRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmMkdirRequest, sizeof(struct srm2__srmMkdirRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmMkdirResponse(struct soap *soap, struct srm2__srmMkdirResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmMkdirResponse))
		soap_serialize_srm2__srmMkdirResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmMkdirResponse(struct soap *soap, struct srm2__srmMkdirResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmMkdirResponse);
	if (soap_out_PointerTosrm2__srmMkdirResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmMkdirResponse(struct soap *soap, const char *tag, int id, struct srm2__srmMkdirResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmMkdirResponse);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmMkdirResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmMkdirResponse ** SOAP_FMAC4 soap_get_PointerTosrm2__srmMkdirResponse(struct soap *soap, struct srm2__srmMkdirResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmMkdirResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmMkdirResponse ** SOAP_FMAC4 soap_in_PointerTosrm2__srmMkdirResponse(struct soap *soap, const char *tag, struct srm2__srmMkdirResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmMkdirResponse **)soap_malloc(soap, sizeof(struct srm2__srmMkdirResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmMkdirResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmMkdirResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmMkdirResponse, sizeof(struct srm2__srmMkdirResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmGetPermissionResponse_(struct soap *soap, struct srm2__srmGetPermissionResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmGetPermissionResponse_))
		soap_serialize_srm2__srmGetPermissionResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmGetPermissionResponse_(struct soap *soap, struct srm2__srmGetPermissionResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmGetPermissionResponse_);
	if (soap_out_PointerTosrm2__srmGetPermissionResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmGetPermissionResponse_(struct soap *soap, const char *tag, int id, struct srm2__srmGetPermissionResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmGetPermissionResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmGetPermissionResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmGetPermissionResponse_ ** SOAP_FMAC4 soap_get_PointerTosrm2__srmGetPermissionResponse_(struct soap *soap, struct srm2__srmGetPermissionResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmGetPermissionResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetPermissionResponse_ ** SOAP_FMAC4 soap_in_PointerTosrm2__srmGetPermissionResponse_(struct soap *soap, const char *tag, struct srm2__srmGetPermissionResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmGetPermissionResponse_ **)soap_malloc(soap, sizeof(struct srm2__srmGetPermissionResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmGetPermissionResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetPermissionResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetPermissionResponse_, sizeof(struct srm2__srmGetPermissionResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmGetPermissionRequest(struct soap *soap, struct srm2__srmGetPermissionRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmGetPermissionRequest))
		soap_serialize_srm2__srmGetPermissionRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmGetPermissionRequest(struct soap *soap, struct srm2__srmGetPermissionRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmGetPermissionRequest);
	if (soap_out_PointerTosrm2__srmGetPermissionRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmGetPermissionRequest(struct soap *soap, const char *tag, int id, struct srm2__srmGetPermissionRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmGetPermissionRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmGetPermissionRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmGetPermissionRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__srmGetPermissionRequest(struct soap *soap, struct srm2__srmGetPermissionRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmGetPermissionRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetPermissionRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__srmGetPermissionRequest(struct soap *soap, const char *tag, struct srm2__srmGetPermissionRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmGetPermissionRequest **)soap_malloc(soap, sizeof(struct srm2__srmGetPermissionRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmGetPermissionRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetPermissionRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetPermissionRequest, sizeof(struct srm2__srmGetPermissionRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmGetPermissionResponse(struct soap *soap, struct srm2__srmGetPermissionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmGetPermissionResponse))
		soap_serialize_srm2__srmGetPermissionResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmGetPermissionResponse(struct soap *soap, struct srm2__srmGetPermissionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmGetPermissionResponse);
	if (soap_out_PointerTosrm2__srmGetPermissionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmGetPermissionResponse(struct soap *soap, const char *tag, int id, struct srm2__srmGetPermissionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmGetPermissionResponse);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmGetPermissionResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmGetPermissionResponse ** SOAP_FMAC4 soap_get_PointerTosrm2__srmGetPermissionResponse(struct soap *soap, struct srm2__srmGetPermissionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmGetPermissionResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetPermissionResponse ** SOAP_FMAC4 soap_in_PointerTosrm2__srmGetPermissionResponse(struct soap *soap, const char *tag, struct srm2__srmGetPermissionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmGetPermissionResponse **)soap_malloc(soap, sizeof(struct srm2__srmGetPermissionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmGetPermissionResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetPermissionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetPermissionResponse, sizeof(struct srm2__srmGetPermissionResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmCheckPermissionResponse_(struct soap *soap, struct srm2__srmCheckPermissionResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmCheckPermissionResponse_))
		soap_serialize_srm2__srmCheckPermissionResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmCheckPermissionResponse_(struct soap *soap, struct srm2__srmCheckPermissionResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmCheckPermissionResponse_);
	if (soap_out_PointerTosrm2__srmCheckPermissionResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmCheckPermissionResponse_(struct soap *soap, const char *tag, int id, struct srm2__srmCheckPermissionResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmCheckPermissionResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmCheckPermissionResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmCheckPermissionResponse_ ** SOAP_FMAC4 soap_get_PointerTosrm2__srmCheckPermissionResponse_(struct soap *soap, struct srm2__srmCheckPermissionResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmCheckPermissionResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmCheckPermissionResponse_ ** SOAP_FMAC4 soap_in_PointerTosrm2__srmCheckPermissionResponse_(struct soap *soap, const char *tag, struct srm2__srmCheckPermissionResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmCheckPermissionResponse_ **)soap_malloc(soap, sizeof(struct srm2__srmCheckPermissionResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmCheckPermissionResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmCheckPermissionResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmCheckPermissionResponse_, sizeof(struct srm2__srmCheckPermissionResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmCheckPermissionRequest(struct soap *soap, struct srm2__srmCheckPermissionRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmCheckPermissionRequest))
		soap_serialize_srm2__srmCheckPermissionRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmCheckPermissionRequest(struct soap *soap, struct srm2__srmCheckPermissionRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmCheckPermissionRequest);
	if (soap_out_PointerTosrm2__srmCheckPermissionRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmCheckPermissionRequest(struct soap *soap, const char *tag, int id, struct srm2__srmCheckPermissionRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmCheckPermissionRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmCheckPermissionRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmCheckPermissionRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__srmCheckPermissionRequest(struct soap *soap, struct srm2__srmCheckPermissionRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmCheckPermissionRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmCheckPermissionRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__srmCheckPermissionRequest(struct soap *soap, const char *tag, struct srm2__srmCheckPermissionRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmCheckPermissionRequest **)soap_malloc(soap, sizeof(struct srm2__srmCheckPermissionRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmCheckPermissionRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmCheckPermissionRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmCheckPermissionRequest, sizeof(struct srm2__srmCheckPermissionRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmCheckPermissionResponse(struct soap *soap, struct srm2__srmCheckPermissionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmCheckPermissionResponse))
		soap_serialize_srm2__srmCheckPermissionResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmCheckPermissionResponse(struct soap *soap, struct srm2__srmCheckPermissionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmCheckPermissionResponse);
	if (soap_out_PointerTosrm2__srmCheckPermissionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmCheckPermissionResponse(struct soap *soap, const char *tag, int id, struct srm2__srmCheckPermissionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmCheckPermissionResponse);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmCheckPermissionResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmCheckPermissionResponse ** SOAP_FMAC4 soap_get_PointerTosrm2__srmCheckPermissionResponse(struct soap *soap, struct srm2__srmCheckPermissionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmCheckPermissionResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmCheckPermissionResponse ** SOAP_FMAC4 soap_in_PointerTosrm2__srmCheckPermissionResponse(struct soap *soap, const char *tag, struct srm2__srmCheckPermissionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmCheckPermissionResponse **)soap_malloc(soap, sizeof(struct srm2__srmCheckPermissionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmCheckPermissionResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmCheckPermissionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmCheckPermissionResponse, sizeof(struct srm2__srmCheckPermissionResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmSetPermissionResponse_(struct soap *soap, struct srm2__srmSetPermissionResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmSetPermissionResponse_))
		soap_serialize_srm2__srmSetPermissionResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmSetPermissionResponse_(struct soap *soap, struct srm2__srmSetPermissionResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmSetPermissionResponse_);
	if (soap_out_PointerTosrm2__srmSetPermissionResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmSetPermissionResponse_(struct soap *soap, const char *tag, int id, struct srm2__srmSetPermissionResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmSetPermissionResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmSetPermissionResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmSetPermissionResponse_ ** SOAP_FMAC4 soap_get_PointerTosrm2__srmSetPermissionResponse_(struct soap *soap, struct srm2__srmSetPermissionResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmSetPermissionResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmSetPermissionResponse_ ** SOAP_FMAC4 soap_in_PointerTosrm2__srmSetPermissionResponse_(struct soap *soap, const char *tag, struct srm2__srmSetPermissionResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmSetPermissionResponse_ **)soap_malloc(soap, sizeof(struct srm2__srmSetPermissionResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmSetPermissionResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmSetPermissionResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmSetPermissionResponse_, sizeof(struct srm2__srmSetPermissionResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmSetPermissionRequest(struct soap *soap, struct srm2__srmSetPermissionRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmSetPermissionRequest))
		soap_serialize_srm2__srmSetPermissionRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmSetPermissionRequest(struct soap *soap, struct srm2__srmSetPermissionRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmSetPermissionRequest);
	if (soap_out_PointerTosrm2__srmSetPermissionRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmSetPermissionRequest(struct soap *soap, const char *tag, int id, struct srm2__srmSetPermissionRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmSetPermissionRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmSetPermissionRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmSetPermissionRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__srmSetPermissionRequest(struct soap *soap, struct srm2__srmSetPermissionRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmSetPermissionRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmSetPermissionRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__srmSetPermissionRequest(struct soap *soap, const char *tag, struct srm2__srmSetPermissionRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmSetPermissionRequest **)soap_malloc(soap, sizeof(struct srm2__srmSetPermissionRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmSetPermissionRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmSetPermissionRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmSetPermissionRequest, sizeof(struct srm2__srmSetPermissionRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmSetPermissionResponse(struct soap *soap, struct srm2__srmSetPermissionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmSetPermissionResponse))
		soap_serialize_srm2__srmSetPermissionResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmSetPermissionResponse(struct soap *soap, struct srm2__srmSetPermissionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmSetPermissionResponse);
	if (soap_out_PointerTosrm2__srmSetPermissionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmSetPermissionResponse(struct soap *soap, const char *tag, int id, struct srm2__srmSetPermissionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmSetPermissionResponse);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmSetPermissionResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmSetPermissionResponse ** SOAP_FMAC4 soap_get_PointerTosrm2__srmSetPermissionResponse(struct soap *soap, struct srm2__srmSetPermissionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmSetPermissionResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmSetPermissionResponse ** SOAP_FMAC4 soap_in_PointerTosrm2__srmSetPermissionResponse(struct soap *soap, const char *tag, struct srm2__srmSetPermissionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmSetPermissionResponse **)soap_malloc(soap, sizeof(struct srm2__srmSetPermissionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmSetPermissionResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmSetPermissionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmSetPermissionResponse, sizeof(struct srm2__srmSetPermissionResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmGetSpaceTokensResponse_(struct soap *soap, struct srm2__srmGetSpaceTokensResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmGetSpaceTokensResponse_))
		soap_serialize_srm2__srmGetSpaceTokensResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmGetSpaceTokensResponse_(struct soap *soap, struct srm2__srmGetSpaceTokensResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmGetSpaceTokensResponse_);
	if (soap_out_PointerTosrm2__srmGetSpaceTokensResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmGetSpaceTokensResponse_(struct soap *soap, const char *tag, int id, struct srm2__srmGetSpaceTokensResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmGetSpaceTokensResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmGetSpaceTokensResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmGetSpaceTokensResponse_ ** SOAP_FMAC4 soap_get_PointerTosrm2__srmGetSpaceTokensResponse_(struct soap *soap, struct srm2__srmGetSpaceTokensResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmGetSpaceTokensResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetSpaceTokensResponse_ ** SOAP_FMAC4 soap_in_PointerTosrm2__srmGetSpaceTokensResponse_(struct soap *soap, const char *tag, struct srm2__srmGetSpaceTokensResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmGetSpaceTokensResponse_ **)soap_malloc(soap, sizeof(struct srm2__srmGetSpaceTokensResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmGetSpaceTokensResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetSpaceTokensResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetSpaceTokensResponse_, sizeof(struct srm2__srmGetSpaceTokensResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmGetSpaceTokensRequest(struct soap *soap, struct srm2__srmGetSpaceTokensRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmGetSpaceTokensRequest))
		soap_serialize_srm2__srmGetSpaceTokensRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmGetSpaceTokensRequest(struct soap *soap, struct srm2__srmGetSpaceTokensRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmGetSpaceTokensRequest);
	if (soap_out_PointerTosrm2__srmGetSpaceTokensRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmGetSpaceTokensRequest(struct soap *soap, const char *tag, int id, struct srm2__srmGetSpaceTokensRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmGetSpaceTokensRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmGetSpaceTokensRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmGetSpaceTokensRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__srmGetSpaceTokensRequest(struct soap *soap, struct srm2__srmGetSpaceTokensRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmGetSpaceTokensRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetSpaceTokensRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__srmGetSpaceTokensRequest(struct soap *soap, const char *tag, struct srm2__srmGetSpaceTokensRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmGetSpaceTokensRequest **)soap_malloc(soap, sizeof(struct srm2__srmGetSpaceTokensRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmGetSpaceTokensRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetSpaceTokensRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetSpaceTokensRequest, sizeof(struct srm2__srmGetSpaceTokensRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmGetSpaceTokensResponse(struct soap *soap, struct srm2__srmGetSpaceTokensResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmGetSpaceTokensResponse))
		soap_serialize_srm2__srmGetSpaceTokensResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmGetSpaceTokensResponse(struct soap *soap, struct srm2__srmGetSpaceTokensResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmGetSpaceTokensResponse);
	if (soap_out_PointerTosrm2__srmGetSpaceTokensResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmGetSpaceTokensResponse(struct soap *soap, const char *tag, int id, struct srm2__srmGetSpaceTokensResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmGetSpaceTokensResponse);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmGetSpaceTokensResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmGetSpaceTokensResponse ** SOAP_FMAC4 soap_get_PointerTosrm2__srmGetSpaceTokensResponse(struct soap *soap, struct srm2__srmGetSpaceTokensResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmGetSpaceTokensResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetSpaceTokensResponse ** SOAP_FMAC4 soap_in_PointerTosrm2__srmGetSpaceTokensResponse(struct soap *soap, const char *tag, struct srm2__srmGetSpaceTokensResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmGetSpaceTokensResponse **)soap_malloc(soap, sizeof(struct srm2__srmGetSpaceTokensResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmGetSpaceTokensResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetSpaceTokensResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetSpaceTokensResponse, sizeof(struct srm2__srmGetSpaceTokensResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmPurgeFromSpaceResponse_(struct soap *soap, struct srm2__srmPurgeFromSpaceResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmPurgeFromSpaceResponse_))
		soap_serialize_srm2__srmPurgeFromSpaceResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmPurgeFromSpaceResponse_(struct soap *soap, struct srm2__srmPurgeFromSpaceResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmPurgeFromSpaceResponse_);
	if (soap_out_PointerTosrm2__srmPurgeFromSpaceResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmPurgeFromSpaceResponse_(struct soap *soap, const char *tag, int id, struct srm2__srmPurgeFromSpaceResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmPurgeFromSpaceResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmPurgeFromSpaceResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmPurgeFromSpaceResponse_ ** SOAP_FMAC4 soap_get_PointerTosrm2__srmPurgeFromSpaceResponse_(struct soap *soap, struct srm2__srmPurgeFromSpaceResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmPurgeFromSpaceResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmPurgeFromSpaceResponse_ ** SOAP_FMAC4 soap_in_PointerTosrm2__srmPurgeFromSpaceResponse_(struct soap *soap, const char *tag, struct srm2__srmPurgeFromSpaceResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmPurgeFromSpaceResponse_ **)soap_malloc(soap, sizeof(struct srm2__srmPurgeFromSpaceResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmPurgeFromSpaceResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmPurgeFromSpaceResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmPurgeFromSpaceResponse_, sizeof(struct srm2__srmPurgeFromSpaceResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmPurgeFromSpaceRequest(struct soap *soap, struct srm2__srmPurgeFromSpaceRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmPurgeFromSpaceRequest))
		soap_serialize_srm2__srmPurgeFromSpaceRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmPurgeFromSpaceRequest(struct soap *soap, struct srm2__srmPurgeFromSpaceRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmPurgeFromSpaceRequest);
	if (soap_out_PointerTosrm2__srmPurgeFromSpaceRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmPurgeFromSpaceRequest(struct soap *soap, const char *tag, int id, struct srm2__srmPurgeFromSpaceRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmPurgeFromSpaceRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmPurgeFromSpaceRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmPurgeFromSpaceRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__srmPurgeFromSpaceRequest(struct soap *soap, struct srm2__srmPurgeFromSpaceRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmPurgeFromSpaceRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmPurgeFromSpaceRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__srmPurgeFromSpaceRequest(struct soap *soap, const char *tag, struct srm2__srmPurgeFromSpaceRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmPurgeFromSpaceRequest **)soap_malloc(soap, sizeof(struct srm2__srmPurgeFromSpaceRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmPurgeFromSpaceRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmPurgeFromSpaceRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmPurgeFromSpaceRequest, sizeof(struct srm2__srmPurgeFromSpaceRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmPurgeFromSpaceResponse(struct soap *soap, struct srm2__srmPurgeFromSpaceResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmPurgeFromSpaceResponse))
		soap_serialize_srm2__srmPurgeFromSpaceResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmPurgeFromSpaceResponse(struct soap *soap, struct srm2__srmPurgeFromSpaceResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmPurgeFromSpaceResponse);
	if (soap_out_PointerTosrm2__srmPurgeFromSpaceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmPurgeFromSpaceResponse(struct soap *soap, const char *tag, int id, struct srm2__srmPurgeFromSpaceResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmPurgeFromSpaceResponse);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmPurgeFromSpaceResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmPurgeFromSpaceResponse ** SOAP_FMAC4 soap_get_PointerTosrm2__srmPurgeFromSpaceResponse(struct soap *soap, struct srm2__srmPurgeFromSpaceResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmPurgeFromSpaceResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmPurgeFromSpaceResponse ** SOAP_FMAC4 soap_in_PointerTosrm2__srmPurgeFromSpaceResponse(struct soap *soap, const char *tag, struct srm2__srmPurgeFromSpaceResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmPurgeFromSpaceResponse **)soap_malloc(soap, sizeof(struct srm2__srmPurgeFromSpaceResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmPurgeFromSpaceResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmPurgeFromSpaceResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmPurgeFromSpaceResponse, sizeof(struct srm2__srmPurgeFromSpaceResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmExtendFileLifeTimeInSpaceResponse_(struct soap *soap, struct srm2__srmExtendFileLifeTimeInSpaceResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpaceResponse_))
		soap_serialize_srm2__srmExtendFileLifeTimeInSpaceResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmExtendFileLifeTimeInSpaceResponse_(struct soap *soap, struct srm2__srmExtendFileLifeTimeInSpaceResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmExtendFileLifeTimeInSpaceResponse_);
	if (soap_out_PointerTosrm2__srmExtendFileLifeTimeInSpaceResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmExtendFileLifeTimeInSpaceResponse_(struct soap *soap, const char *tag, int id, struct srm2__srmExtendFileLifeTimeInSpaceResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpaceResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmExtendFileLifeTimeInSpaceResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmExtendFileLifeTimeInSpaceResponse_ ** SOAP_FMAC4 soap_get_PointerTosrm2__srmExtendFileLifeTimeInSpaceResponse_(struct soap *soap, struct srm2__srmExtendFileLifeTimeInSpaceResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmExtendFileLifeTimeInSpaceResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmExtendFileLifeTimeInSpaceResponse_ ** SOAP_FMAC4 soap_in_PointerTosrm2__srmExtendFileLifeTimeInSpaceResponse_(struct soap *soap, const char *tag, struct srm2__srmExtendFileLifeTimeInSpaceResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmExtendFileLifeTimeInSpaceResponse_ **)soap_malloc(soap, sizeof(struct srm2__srmExtendFileLifeTimeInSpaceResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmExtendFileLifeTimeInSpaceResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmExtendFileLifeTimeInSpaceResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpaceResponse_, sizeof(struct srm2__srmExtendFileLifeTimeInSpaceResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmExtendFileLifeTimeInSpaceRequest(struct soap *soap, struct srm2__srmExtendFileLifeTimeInSpaceRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpaceRequest))
		soap_serialize_srm2__srmExtendFileLifeTimeInSpaceRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmExtendFileLifeTimeInSpaceRequest(struct soap *soap, struct srm2__srmExtendFileLifeTimeInSpaceRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmExtendFileLifeTimeInSpaceRequest);
	if (soap_out_PointerTosrm2__srmExtendFileLifeTimeInSpaceRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmExtendFileLifeTimeInSpaceRequest(struct soap *soap, const char *tag, int id, struct srm2__srmExtendFileLifeTimeInSpaceRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpaceRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmExtendFileLifeTimeInSpaceRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmExtendFileLifeTimeInSpaceRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__srmExtendFileLifeTimeInSpaceRequest(struct soap *soap, struct srm2__srmExtendFileLifeTimeInSpaceRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmExtendFileLifeTimeInSpaceRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmExtendFileLifeTimeInSpaceRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__srmExtendFileLifeTimeInSpaceRequest(struct soap *soap, const char *tag, struct srm2__srmExtendFileLifeTimeInSpaceRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmExtendFileLifeTimeInSpaceRequest **)soap_malloc(soap, sizeof(struct srm2__srmExtendFileLifeTimeInSpaceRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmExtendFileLifeTimeInSpaceRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmExtendFileLifeTimeInSpaceRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpaceRequest, sizeof(struct srm2__srmExtendFileLifeTimeInSpaceRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmExtendFileLifeTimeInSpaceResponse(struct soap *soap, struct srm2__srmExtendFileLifeTimeInSpaceResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpaceResponse))
		soap_serialize_srm2__srmExtendFileLifeTimeInSpaceResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmExtendFileLifeTimeInSpaceResponse(struct soap *soap, struct srm2__srmExtendFileLifeTimeInSpaceResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmExtendFileLifeTimeInSpaceResponse);
	if (soap_out_PointerTosrm2__srmExtendFileLifeTimeInSpaceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmExtendFileLifeTimeInSpaceResponse(struct soap *soap, const char *tag, int id, struct srm2__srmExtendFileLifeTimeInSpaceResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpaceResponse);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmExtendFileLifeTimeInSpaceResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmExtendFileLifeTimeInSpaceResponse ** SOAP_FMAC4 soap_get_PointerTosrm2__srmExtendFileLifeTimeInSpaceResponse(struct soap *soap, struct srm2__srmExtendFileLifeTimeInSpaceResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmExtendFileLifeTimeInSpaceResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmExtendFileLifeTimeInSpaceResponse ** SOAP_FMAC4 soap_in_PointerTosrm2__srmExtendFileLifeTimeInSpaceResponse(struct soap *soap, const char *tag, struct srm2__srmExtendFileLifeTimeInSpaceResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmExtendFileLifeTimeInSpaceResponse **)soap_malloc(soap, sizeof(struct srm2__srmExtendFileLifeTimeInSpaceResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmExtendFileLifeTimeInSpaceResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmExtendFileLifeTimeInSpaceResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmExtendFileLifeTimeInSpaceResponse, sizeof(struct srm2__srmExtendFileLifeTimeInSpaceResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestResponse_(struct soap *soap, struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequestResponse_))
		soap_serialize_srm2__srmStatusOfChangeSpaceForFilesRequestResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestResponse_(struct soap *soap, struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestResponse_);
	if (soap_out_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestResponse_(struct soap *soap, const char *tag, int id, struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequestResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmStatusOfChangeSpaceForFilesRequestResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse_ ** SOAP_FMAC4 soap_get_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestResponse_(struct soap *soap, struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse_ ** SOAP_FMAC4 soap_in_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestResponse_(struct soap *soap, const char *tag, struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse_ **)soap_malloc(soap, sizeof(struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmStatusOfChangeSpaceForFilesRequestResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequestResponse_, sizeof(struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestRequest(struct soap *soap, struct srm2__srmStatusOfChangeSpaceForFilesRequestRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequestRequest))
		soap_serialize_srm2__srmStatusOfChangeSpaceForFilesRequestRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestRequest(struct soap *soap, struct srm2__srmStatusOfChangeSpaceForFilesRequestRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestRequest);
	if (soap_out_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestRequest(struct soap *soap, const char *tag, int id, struct srm2__srmStatusOfChangeSpaceForFilesRequestRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequestRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmStatusOfChangeSpaceForFilesRequestRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmStatusOfChangeSpaceForFilesRequestRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestRequest(struct soap *soap, struct srm2__srmStatusOfChangeSpaceForFilesRequestRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfChangeSpaceForFilesRequestRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestRequest(struct soap *soap, const char *tag, struct srm2__srmStatusOfChangeSpaceForFilesRequestRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmStatusOfChangeSpaceForFilesRequestRequest **)soap_malloc(soap, sizeof(struct srm2__srmStatusOfChangeSpaceForFilesRequestRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmStatusOfChangeSpaceForFilesRequestRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfChangeSpaceForFilesRequestRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequestRequest, sizeof(struct srm2__srmStatusOfChangeSpaceForFilesRequestRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestResponse(struct soap *soap, struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequestResponse))
		soap_serialize_srm2__srmStatusOfChangeSpaceForFilesRequestResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestResponse(struct soap *soap, struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestResponse);
	if (soap_out_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestResponse(struct soap *soap, const char *tag, int id, struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequestResponse);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmStatusOfChangeSpaceForFilesRequestResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse ** SOAP_FMAC4 soap_get_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestResponse(struct soap *soap, struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse ** SOAP_FMAC4 soap_in_PointerTosrm2__srmStatusOfChangeSpaceForFilesRequestResponse(struct soap *soap, const char *tag, struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse **)soap_malloc(soap, sizeof(struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmStatusOfChangeSpaceForFilesRequestResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfChangeSpaceForFilesRequestResponse, sizeof(struct srm2__srmStatusOfChangeSpaceForFilesRequestResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmChangeSpaceForFilesResponse_(struct soap *soap, struct srm2__srmChangeSpaceForFilesResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmChangeSpaceForFilesResponse_))
		soap_serialize_srm2__srmChangeSpaceForFilesResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmChangeSpaceForFilesResponse_(struct soap *soap, struct srm2__srmChangeSpaceForFilesResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmChangeSpaceForFilesResponse_);
	if (soap_out_PointerTosrm2__srmChangeSpaceForFilesResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmChangeSpaceForFilesResponse_(struct soap *soap, const char *tag, int id, struct srm2__srmChangeSpaceForFilesResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmChangeSpaceForFilesResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmChangeSpaceForFilesResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmChangeSpaceForFilesResponse_ ** SOAP_FMAC4 soap_get_PointerTosrm2__srmChangeSpaceForFilesResponse_(struct soap *soap, struct srm2__srmChangeSpaceForFilesResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmChangeSpaceForFilesResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmChangeSpaceForFilesResponse_ ** SOAP_FMAC4 soap_in_PointerTosrm2__srmChangeSpaceForFilesResponse_(struct soap *soap, const char *tag, struct srm2__srmChangeSpaceForFilesResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmChangeSpaceForFilesResponse_ **)soap_malloc(soap, sizeof(struct srm2__srmChangeSpaceForFilesResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmChangeSpaceForFilesResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmChangeSpaceForFilesResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmChangeSpaceForFilesResponse_, sizeof(struct srm2__srmChangeSpaceForFilesResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmChangeSpaceForFilesRequest(struct soap *soap, struct srm2__srmChangeSpaceForFilesRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmChangeSpaceForFilesRequest))
		soap_serialize_srm2__srmChangeSpaceForFilesRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmChangeSpaceForFilesRequest(struct soap *soap, struct srm2__srmChangeSpaceForFilesRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmChangeSpaceForFilesRequest);
	if (soap_out_PointerTosrm2__srmChangeSpaceForFilesRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmChangeSpaceForFilesRequest(struct soap *soap, const char *tag, int id, struct srm2__srmChangeSpaceForFilesRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmChangeSpaceForFilesRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmChangeSpaceForFilesRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmChangeSpaceForFilesRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__srmChangeSpaceForFilesRequest(struct soap *soap, struct srm2__srmChangeSpaceForFilesRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmChangeSpaceForFilesRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmChangeSpaceForFilesRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__srmChangeSpaceForFilesRequest(struct soap *soap, const char *tag, struct srm2__srmChangeSpaceForFilesRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmChangeSpaceForFilesRequest **)soap_malloc(soap, sizeof(struct srm2__srmChangeSpaceForFilesRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmChangeSpaceForFilesRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmChangeSpaceForFilesRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmChangeSpaceForFilesRequest, sizeof(struct srm2__srmChangeSpaceForFilesRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmChangeSpaceForFilesResponse(struct soap *soap, struct srm2__srmChangeSpaceForFilesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmChangeSpaceForFilesResponse))
		soap_serialize_srm2__srmChangeSpaceForFilesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmChangeSpaceForFilesResponse(struct soap *soap, struct srm2__srmChangeSpaceForFilesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmChangeSpaceForFilesResponse);
	if (soap_out_PointerTosrm2__srmChangeSpaceForFilesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmChangeSpaceForFilesResponse(struct soap *soap, const char *tag, int id, struct srm2__srmChangeSpaceForFilesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmChangeSpaceForFilesResponse);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmChangeSpaceForFilesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmChangeSpaceForFilesResponse ** SOAP_FMAC4 soap_get_PointerTosrm2__srmChangeSpaceForFilesResponse(struct soap *soap, struct srm2__srmChangeSpaceForFilesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmChangeSpaceForFilesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmChangeSpaceForFilesResponse ** SOAP_FMAC4 soap_in_PointerTosrm2__srmChangeSpaceForFilesResponse(struct soap *soap, const char *tag, struct srm2__srmChangeSpaceForFilesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmChangeSpaceForFilesResponse **)soap_malloc(soap, sizeof(struct srm2__srmChangeSpaceForFilesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmChangeSpaceForFilesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmChangeSpaceForFilesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmChangeSpaceForFilesResponse, sizeof(struct srm2__srmChangeSpaceForFilesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmGetSpaceMetaDataResponse_(struct soap *soap, struct srm2__srmGetSpaceMetaDataResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmGetSpaceMetaDataResponse_))
		soap_serialize_srm2__srmGetSpaceMetaDataResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmGetSpaceMetaDataResponse_(struct soap *soap, struct srm2__srmGetSpaceMetaDataResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmGetSpaceMetaDataResponse_);
	if (soap_out_PointerTosrm2__srmGetSpaceMetaDataResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmGetSpaceMetaDataResponse_(struct soap *soap, const char *tag, int id, struct srm2__srmGetSpaceMetaDataResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmGetSpaceMetaDataResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmGetSpaceMetaDataResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmGetSpaceMetaDataResponse_ ** SOAP_FMAC4 soap_get_PointerTosrm2__srmGetSpaceMetaDataResponse_(struct soap *soap, struct srm2__srmGetSpaceMetaDataResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmGetSpaceMetaDataResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetSpaceMetaDataResponse_ ** SOAP_FMAC4 soap_in_PointerTosrm2__srmGetSpaceMetaDataResponse_(struct soap *soap, const char *tag, struct srm2__srmGetSpaceMetaDataResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmGetSpaceMetaDataResponse_ **)soap_malloc(soap, sizeof(struct srm2__srmGetSpaceMetaDataResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmGetSpaceMetaDataResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetSpaceMetaDataResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetSpaceMetaDataResponse_, sizeof(struct srm2__srmGetSpaceMetaDataResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmGetSpaceMetaDataRequest(struct soap *soap, struct srm2__srmGetSpaceMetaDataRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmGetSpaceMetaDataRequest))
		soap_serialize_srm2__srmGetSpaceMetaDataRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmGetSpaceMetaDataRequest(struct soap *soap, struct srm2__srmGetSpaceMetaDataRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmGetSpaceMetaDataRequest);
	if (soap_out_PointerTosrm2__srmGetSpaceMetaDataRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmGetSpaceMetaDataRequest(struct soap *soap, const char *tag, int id, struct srm2__srmGetSpaceMetaDataRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmGetSpaceMetaDataRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmGetSpaceMetaDataRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmGetSpaceMetaDataRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__srmGetSpaceMetaDataRequest(struct soap *soap, struct srm2__srmGetSpaceMetaDataRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmGetSpaceMetaDataRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetSpaceMetaDataRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__srmGetSpaceMetaDataRequest(struct soap *soap, const char *tag, struct srm2__srmGetSpaceMetaDataRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmGetSpaceMetaDataRequest **)soap_malloc(soap, sizeof(struct srm2__srmGetSpaceMetaDataRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmGetSpaceMetaDataRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetSpaceMetaDataRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetSpaceMetaDataRequest, sizeof(struct srm2__srmGetSpaceMetaDataRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmGetSpaceMetaDataResponse(struct soap *soap, struct srm2__srmGetSpaceMetaDataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmGetSpaceMetaDataResponse))
		soap_serialize_srm2__srmGetSpaceMetaDataResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmGetSpaceMetaDataResponse(struct soap *soap, struct srm2__srmGetSpaceMetaDataResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmGetSpaceMetaDataResponse);
	if (soap_out_PointerTosrm2__srmGetSpaceMetaDataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmGetSpaceMetaDataResponse(struct soap *soap, const char *tag, int id, struct srm2__srmGetSpaceMetaDataResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmGetSpaceMetaDataResponse);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmGetSpaceMetaDataResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmGetSpaceMetaDataResponse ** SOAP_FMAC4 soap_get_PointerTosrm2__srmGetSpaceMetaDataResponse(struct soap *soap, struct srm2__srmGetSpaceMetaDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmGetSpaceMetaDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmGetSpaceMetaDataResponse ** SOAP_FMAC4 soap_in_PointerTosrm2__srmGetSpaceMetaDataResponse(struct soap *soap, const char *tag, struct srm2__srmGetSpaceMetaDataResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmGetSpaceMetaDataResponse **)soap_malloc(soap, sizeof(struct srm2__srmGetSpaceMetaDataResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmGetSpaceMetaDataResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmGetSpaceMetaDataResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmGetSpaceMetaDataResponse, sizeof(struct srm2__srmGetSpaceMetaDataResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmStatusOfUpdateSpaceRequestResponse_(struct soap *soap, struct srm2__srmStatusOfUpdateSpaceRequestResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequestResponse_))
		soap_serialize_srm2__srmStatusOfUpdateSpaceRequestResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmStatusOfUpdateSpaceRequestResponse_(struct soap *soap, struct srm2__srmStatusOfUpdateSpaceRequestResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmStatusOfUpdateSpaceRequestResponse_);
	if (soap_out_PointerTosrm2__srmStatusOfUpdateSpaceRequestResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmStatusOfUpdateSpaceRequestResponse_(struct soap *soap, const char *tag, int id, struct srm2__srmStatusOfUpdateSpaceRequestResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequestResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmStatusOfUpdateSpaceRequestResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmStatusOfUpdateSpaceRequestResponse_ ** SOAP_FMAC4 soap_get_PointerTosrm2__srmStatusOfUpdateSpaceRequestResponse_(struct soap *soap, struct srm2__srmStatusOfUpdateSpaceRequestResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmStatusOfUpdateSpaceRequestResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfUpdateSpaceRequestResponse_ ** SOAP_FMAC4 soap_in_PointerTosrm2__srmStatusOfUpdateSpaceRequestResponse_(struct soap *soap, const char *tag, struct srm2__srmStatusOfUpdateSpaceRequestResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmStatusOfUpdateSpaceRequestResponse_ **)soap_malloc(soap, sizeof(struct srm2__srmStatusOfUpdateSpaceRequestResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmStatusOfUpdateSpaceRequestResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfUpdateSpaceRequestResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequestResponse_, sizeof(struct srm2__srmStatusOfUpdateSpaceRequestResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmStatusOfUpdateSpaceRequestRequest(struct soap *soap, struct srm2__srmStatusOfUpdateSpaceRequestRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequestRequest))
		soap_serialize_srm2__srmStatusOfUpdateSpaceRequestRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmStatusOfUpdateSpaceRequestRequest(struct soap *soap, struct srm2__srmStatusOfUpdateSpaceRequestRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmStatusOfUpdateSpaceRequestRequest);
	if (soap_out_PointerTosrm2__srmStatusOfUpdateSpaceRequestRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmStatusOfUpdateSpaceRequestRequest(struct soap *soap, const char *tag, int id, struct srm2__srmStatusOfUpdateSpaceRequestRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequestRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmStatusOfUpdateSpaceRequestRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmStatusOfUpdateSpaceRequestRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__srmStatusOfUpdateSpaceRequestRequest(struct soap *soap, struct srm2__srmStatusOfUpdateSpaceRequestRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmStatusOfUpdateSpaceRequestRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfUpdateSpaceRequestRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__srmStatusOfUpdateSpaceRequestRequest(struct soap *soap, const char *tag, struct srm2__srmStatusOfUpdateSpaceRequestRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmStatusOfUpdateSpaceRequestRequest **)soap_malloc(soap, sizeof(struct srm2__srmStatusOfUpdateSpaceRequestRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmStatusOfUpdateSpaceRequestRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfUpdateSpaceRequestRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequestRequest, sizeof(struct srm2__srmStatusOfUpdateSpaceRequestRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmStatusOfUpdateSpaceRequestResponse(struct soap *soap, struct srm2__srmStatusOfUpdateSpaceRequestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequestResponse))
		soap_serialize_srm2__srmStatusOfUpdateSpaceRequestResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmStatusOfUpdateSpaceRequestResponse(struct soap *soap, struct srm2__srmStatusOfUpdateSpaceRequestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmStatusOfUpdateSpaceRequestResponse);
	if (soap_out_PointerTosrm2__srmStatusOfUpdateSpaceRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmStatusOfUpdateSpaceRequestResponse(struct soap *soap, const char *tag, int id, struct srm2__srmStatusOfUpdateSpaceRequestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequestResponse);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmStatusOfUpdateSpaceRequestResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmStatusOfUpdateSpaceRequestResponse ** SOAP_FMAC4 soap_get_PointerTosrm2__srmStatusOfUpdateSpaceRequestResponse(struct soap *soap, struct srm2__srmStatusOfUpdateSpaceRequestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmStatusOfUpdateSpaceRequestResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfUpdateSpaceRequestResponse ** SOAP_FMAC4 soap_in_PointerTosrm2__srmStatusOfUpdateSpaceRequestResponse(struct soap *soap, const char *tag, struct srm2__srmStatusOfUpdateSpaceRequestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmStatusOfUpdateSpaceRequestResponse **)soap_malloc(soap, sizeof(struct srm2__srmStatusOfUpdateSpaceRequestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmStatusOfUpdateSpaceRequestResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfUpdateSpaceRequestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfUpdateSpaceRequestResponse, sizeof(struct srm2__srmStatusOfUpdateSpaceRequestResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmUpdateSpaceResponse_(struct soap *soap, struct srm2__srmUpdateSpaceResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmUpdateSpaceResponse_))
		soap_serialize_srm2__srmUpdateSpaceResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmUpdateSpaceResponse_(struct soap *soap, struct srm2__srmUpdateSpaceResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmUpdateSpaceResponse_);
	if (soap_out_PointerTosrm2__srmUpdateSpaceResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmUpdateSpaceResponse_(struct soap *soap, const char *tag, int id, struct srm2__srmUpdateSpaceResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmUpdateSpaceResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmUpdateSpaceResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmUpdateSpaceResponse_ ** SOAP_FMAC4 soap_get_PointerTosrm2__srmUpdateSpaceResponse_(struct soap *soap, struct srm2__srmUpdateSpaceResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmUpdateSpaceResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmUpdateSpaceResponse_ ** SOAP_FMAC4 soap_in_PointerTosrm2__srmUpdateSpaceResponse_(struct soap *soap, const char *tag, struct srm2__srmUpdateSpaceResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmUpdateSpaceResponse_ **)soap_malloc(soap, sizeof(struct srm2__srmUpdateSpaceResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmUpdateSpaceResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmUpdateSpaceResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmUpdateSpaceResponse_, sizeof(struct srm2__srmUpdateSpaceResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmUpdateSpaceRequest(struct soap *soap, struct srm2__srmUpdateSpaceRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmUpdateSpaceRequest))
		soap_serialize_srm2__srmUpdateSpaceRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmUpdateSpaceRequest(struct soap *soap, struct srm2__srmUpdateSpaceRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmUpdateSpaceRequest);
	if (soap_out_PointerTosrm2__srmUpdateSpaceRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmUpdateSpaceRequest(struct soap *soap, const char *tag, int id, struct srm2__srmUpdateSpaceRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmUpdateSpaceRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmUpdateSpaceRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmUpdateSpaceRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__srmUpdateSpaceRequest(struct soap *soap, struct srm2__srmUpdateSpaceRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmUpdateSpaceRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmUpdateSpaceRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__srmUpdateSpaceRequest(struct soap *soap, const char *tag, struct srm2__srmUpdateSpaceRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmUpdateSpaceRequest **)soap_malloc(soap, sizeof(struct srm2__srmUpdateSpaceRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmUpdateSpaceRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmUpdateSpaceRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmUpdateSpaceRequest, sizeof(struct srm2__srmUpdateSpaceRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmUpdateSpaceResponse(struct soap *soap, struct srm2__srmUpdateSpaceResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmUpdateSpaceResponse))
		soap_serialize_srm2__srmUpdateSpaceResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmUpdateSpaceResponse(struct soap *soap, struct srm2__srmUpdateSpaceResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmUpdateSpaceResponse);
	if (soap_out_PointerTosrm2__srmUpdateSpaceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmUpdateSpaceResponse(struct soap *soap, const char *tag, int id, struct srm2__srmUpdateSpaceResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmUpdateSpaceResponse);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmUpdateSpaceResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmUpdateSpaceResponse ** SOAP_FMAC4 soap_get_PointerTosrm2__srmUpdateSpaceResponse(struct soap *soap, struct srm2__srmUpdateSpaceResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmUpdateSpaceResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmUpdateSpaceResponse ** SOAP_FMAC4 soap_in_PointerTosrm2__srmUpdateSpaceResponse(struct soap *soap, const char *tag, struct srm2__srmUpdateSpaceResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmUpdateSpaceResponse **)soap_malloc(soap, sizeof(struct srm2__srmUpdateSpaceResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmUpdateSpaceResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmUpdateSpaceResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmUpdateSpaceResponse, sizeof(struct srm2__srmUpdateSpaceResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmReleaseSpaceResponse_(struct soap *soap, struct srm2__srmReleaseSpaceResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmReleaseSpaceResponse_))
		soap_serialize_srm2__srmReleaseSpaceResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmReleaseSpaceResponse_(struct soap *soap, struct srm2__srmReleaseSpaceResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmReleaseSpaceResponse_);
	if (soap_out_PointerTosrm2__srmReleaseSpaceResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmReleaseSpaceResponse_(struct soap *soap, const char *tag, int id, struct srm2__srmReleaseSpaceResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmReleaseSpaceResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmReleaseSpaceResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmReleaseSpaceResponse_ ** SOAP_FMAC4 soap_get_PointerTosrm2__srmReleaseSpaceResponse_(struct soap *soap, struct srm2__srmReleaseSpaceResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmReleaseSpaceResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmReleaseSpaceResponse_ ** SOAP_FMAC4 soap_in_PointerTosrm2__srmReleaseSpaceResponse_(struct soap *soap, const char *tag, struct srm2__srmReleaseSpaceResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmReleaseSpaceResponse_ **)soap_malloc(soap, sizeof(struct srm2__srmReleaseSpaceResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmReleaseSpaceResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmReleaseSpaceResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmReleaseSpaceResponse_, sizeof(struct srm2__srmReleaseSpaceResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmReleaseSpaceRequest(struct soap *soap, struct srm2__srmReleaseSpaceRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmReleaseSpaceRequest))
		soap_serialize_srm2__srmReleaseSpaceRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmReleaseSpaceRequest(struct soap *soap, struct srm2__srmReleaseSpaceRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmReleaseSpaceRequest);
	if (soap_out_PointerTosrm2__srmReleaseSpaceRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmReleaseSpaceRequest(struct soap *soap, const char *tag, int id, struct srm2__srmReleaseSpaceRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmReleaseSpaceRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmReleaseSpaceRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmReleaseSpaceRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__srmReleaseSpaceRequest(struct soap *soap, struct srm2__srmReleaseSpaceRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmReleaseSpaceRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmReleaseSpaceRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__srmReleaseSpaceRequest(struct soap *soap, const char *tag, struct srm2__srmReleaseSpaceRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmReleaseSpaceRequest **)soap_malloc(soap, sizeof(struct srm2__srmReleaseSpaceRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmReleaseSpaceRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmReleaseSpaceRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmReleaseSpaceRequest, sizeof(struct srm2__srmReleaseSpaceRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmReleaseSpaceResponse(struct soap *soap, struct srm2__srmReleaseSpaceResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmReleaseSpaceResponse))
		soap_serialize_srm2__srmReleaseSpaceResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmReleaseSpaceResponse(struct soap *soap, struct srm2__srmReleaseSpaceResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmReleaseSpaceResponse);
	if (soap_out_PointerTosrm2__srmReleaseSpaceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmReleaseSpaceResponse(struct soap *soap, const char *tag, int id, struct srm2__srmReleaseSpaceResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmReleaseSpaceResponse);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmReleaseSpaceResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmReleaseSpaceResponse ** SOAP_FMAC4 soap_get_PointerTosrm2__srmReleaseSpaceResponse(struct soap *soap, struct srm2__srmReleaseSpaceResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmReleaseSpaceResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmReleaseSpaceResponse ** SOAP_FMAC4 soap_in_PointerTosrm2__srmReleaseSpaceResponse(struct soap *soap, const char *tag, struct srm2__srmReleaseSpaceResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmReleaseSpaceResponse **)soap_malloc(soap, sizeof(struct srm2__srmReleaseSpaceResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmReleaseSpaceResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmReleaseSpaceResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmReleaseSpaceResponse, sizeof(struct srm2__srmReleaseSpaceResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmStatusOfReserveSpaceRequestResponse_(struct soap *soap, struct srm2__srmStatusOfReserveSpaceRequestResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequestResponse_))
		soap_serialize_srm2__srmStatusOfReserveSpaceRequestResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmStatusOfReserveSpaceRequestResponse_(struct soap *soap, struct srm2__srmStatusOfReserveSpaceRequestResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmStatusOfReserveSpaceRequestResponse_);
	if (soap_out_PointerTosrm2__srmStatusOfReserveSpaceRequestResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmStatusOfReserveSpaceRequestResponse_(struct soap *soap, const char *tag, int id, struct srm2__srmStatusOfReserveSpaceRequestResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequestResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmStatusOfReserveSpaceRequestResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmStatusOfReserveSpaceRequestResponse_ ** SOAP_FMAC4 soap_get_PointerTosrm2__srmStatusOfReserveSpaceRequestResponse_(struct soap *soap, struct srm2__srmStatusOfReserveSpaceRequestResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmStatusOfReserveSpaceRequestResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfReserveSpaceRequestResponse_ ** SOAP_FMAC4 soap_in_PointerTosrm2__srmStatusOfReserveSpaceRequestResponse_(struct soap *soap, const char *tag, struct srm2__srmStatusOfReserveSpaceRequestResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmStatusOfReserveSpaceRequestResponse_ **)soap_malloc(soap, sizeof(struct srm2__srmStatusOfReserveSpaceRequestResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmStatusOfReserveSpaceRequestResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfReserveSpaceRequestResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequestResponse_, sizeof(struct srm2__srmStatusOfReserveSpaceRequestResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmStatusOfReserveSpaceRequestRequest(struct soap *soap, struct srm2__srmStatusOfReserveSpaceRequestRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequestRequest))
		soap_serialize_srm2__srmStatusOfReserveSpaceRequestRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmStatusOfReserveSpaceRequestRequest(struct soap *soap, struct srm2__srmStatusOfReserveSpaceRequestRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmStatusOfReserveSpaceRequestRequest);
	if (soap_out_PointerTosrm2__srmStatusOfReserveSpaceRequestRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmStatusOfReserveSpaceRequestRequest(struct soap *soap, const char *tag, int id, struct srm2__srmStatusOfReserveSpaceRequestRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequestRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmStatusOfReserveSpaceRequestRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmStatusOfReserveSpaceRequestRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__srmStatusOfReserveSpaceRequestRequest(struct soap *soap, struct srm2__srmStatusOfReserveSpaceRequestRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmStatusOfReserveSpaceRequestRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfReserveSpaceRequestRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__srmStatusOfReserveSpaceRequestRequest(struct soap *soap, const char *tag, struct srm2__srmStatusOfReserveSpaceRequestRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmStatusOfReserveSpaceRequestRequest **)soap_malloc(soap, sizeof(struct srm2__srmStatusOfReserveSpaceRequestRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmStatusOfReserveSpaceRequestRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfReserveSpaceRequestRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequestRequest, sizeof(struct srm2__srmStatusOfReserveSpaceRequestRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmStatusOfReserveSpaceRequestResponse(struct soap *soap, struct srm2__srmStatusOfReserveSpaceRequestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequestResponse))
		soap_serialize_srm2__srmStatusOfReserveSpaceRequestResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmStatusOfReserveSpaceRequestResponse(struct soap *soap, struct srm2__srmStatusOfReserveSpaceRequestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmStatusOfReserveSpaceRequestResponse);
	if (soap_out_PointerTosrm2__srmStatusOfReserveSpaceRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmStatusOfReserveSpaceRequestResponse(struct soap *soap, const char *tag, int id, struct srm2__srmStatusOfReserveSpaceRequestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequestResponse);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmStatusOfReserveSpaceRequestResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmStatusOfReserveSpaceRequestResponse ** SOAP_FMAC4 soap_get_PointerTosrm2__srmStatusOfReserveSpaceRequestResponse(struct soap *soap, struct srm2__srmStatusOfReserveSpaceRequestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmStatusOfReserveSpaceRequestResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmStatusOfReserveSpaceRequestResponse ** SOAP_FMAC4 soap_in_PointerTosrm2__srmStatusOfReserveSpaceRequestResponse(struct soap *soap, const char *tag, struct srm2__srmStatusOfReserveSpaceRequestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmStatusOfReserveSpaceRequestResponse **)soap_malloc(soap, sizeof(struct srm2__srmStatusOfReserveSpaceRequestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmStatusOfReserveSpaceRequestResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmStatusOfReserveSpaceRequestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmStatusOfReserveSpaceRequestResponse, sizeof(struct srm2__srmStatusOfReserveSpaceRequestResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmReserveSpaceResponse_(struct soap *soap, struct srm2__srmReserveSpaceResponse_ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmReserveSpaceResponse_))
		soap_serialize_srm2__srmReserveSpaceResponse_(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmReserveSpaceResponse_(struct soap *soap, struct srm2__srmReserveSpaceResponse_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmReserveSpaceResponse_);
	if (soap_out_PointerTosrm2__srmReserveSpaceResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmReserveSpaceResponse_(struct soap *soap, const char *tag, int id, struct srm2__srmReserveSpaceResponse_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmReserveSpaceResponse_);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmReserveSpaceResponse_(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmReserveSpaceResponse_ ** SOAP_FMAC4 soap_get_PointerTosrm2__srmReserveSpaceResponse_(struct soap *soap, struct srm2__srmReserveSpaceResponse_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmReserveSpaceResponse_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmReserveSpaceResponse_ ** SOAP_FMAC4 soap_in_PointerTosrm2__srmReserveSpaceResponse_(struct soap *soap, const char *tag, struct srm2__srmReserveSpaceResponse_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmReserveSpaceResponse_ **)soap_malloc(soap, sizeof(struct srm2__srmReserveSpaceResponse_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmReserveSpaceResponse_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmReserveSpaceResponse_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmReserveSpaceResponse_, sizeof(struct srm2__srmReserveSpaceResponse_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmReserveSpaceRequest(struct soap *soap, struct srm2__srmReserveSpaceRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmReserveSpaceRequest))
		soap_serialize_srm2__srmReserveSpaceRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmReserveSpaceRequest(struct soap *soap, struct srm2__srmReserveSpaceRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmReserveSpaceRequest);
	if (soap_out_PointerTosrm2__srmReserveSpaceRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmReserveSpaceRequest(struct soap *soap, const char *tag, int id, struct srm2__srmReserveSpaceRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmReserveSpaceRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmReserveSpaceRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmReserveSpaceRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__srmReserveSpaceRequest(struct soap *soap, struct srm2__srmReserveSpaceRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmReserveSpaceRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmReserveSpaceRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__srmReserveSpaceRequest(struct soap *soap, const char *tag, struct srm2__srmReserveSpaceRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmReserveSpaceRequest **)soap_malloc(soap, sizeof(struct srm2__srmReserveSpaceRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmReserveSpaceRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmReserveSpaceRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmReserveSpaceRequest, sizeof(struct srm2__srmReserveSpaceRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__srmReserveSpaceResponse(struct soap *soap, struct srm2__srmReserveSpaceResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__srmReserveSpaceResponse))
		soap_serialize_srm2__srmReserveSpaceResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__srmReserveSpaceResponse(struct soap *soap, struct srm2__srmReserveSpaceResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__srmReserveSpaceResponse);
	if (soap_out_PointerTosrm2__srmReserveSpaceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__srmReserveSpaceResponse(struct soap *soap, const char *tag, int id, struct srm2__srmReserveSpaceResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__srmReserveSpaceResponse);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__srmReserveSpaceResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__srmReserveSpaceResponse ** SOAP_FMAC4 soap_get_PointerTosrm2__srmReserveSpaceResponse(struct soap *soap, struct srm2__srmReserveSpaceResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__srmReserveSpaceResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__srmReserveSpaceResponse ** SOAP_FMAC4 soap_in_PointerTosrm2__srmReserveSpaceResponse(struct soap *soap, const char *tag, struct srm2__srmReserveSpaceResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__srmReserveSpaceResponse **)soap_malloc(soap, sizeof(struct srm2__srmReserveSpaceResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__srmReserveSpaceResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__srmReserveSpaceResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__srmReserveSpaceResponse, sizeof(struct srm2__srmReserveSpaceResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__ArrayOfTSupportedTransferProtocol(struct soap *soap, struct srm2__ArrayOfTSupportedTransferProtocol *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__ArrayOfTSupportedTransferProtocol))
		soap_serialize_srm2__ArrayOfTSupportedTransferProtocol(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__ArrayOfTSupportedTransferProtocol(struct soap *soap, struct srm2__ArrayOfTSupportedTransferProtocol *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__ArrayOfTSupportedTransferProtocol);
	if (soap_out_PointerTosrm2__ArrayOfTSupportedTransferProtocol(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__ArrayOfTSupportedTransferProtocol(struct soap *soap, const char *tag, int id, struct srm2__ArrayOfTSupportedTransferProtocol *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__ArrayOfTSupportedTransferProtocol);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__ArrayOfTSupportedTransferProtocol(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__ArrayOfTSupportedTransferProtocol ** SOAP_FMAC4 soap_get_PointerTosrm2__ArrayOfTSupportedTransferProtocol(struct soap *soap, struct srm2__ArrayOfTSupportedTransferProtocol **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__ArrayOfTSupportedTransferProtocol(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfTSupportedTransferProtocol ** SOAP_FMAC4 soap_in_PointerTosrm2__ArrayOfTSupportedTransferProtocol(struct soap *soap, const char *tag, struct srm2__ArrayOfTSupportedTransferProtocol **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__ArrayOfTSupportedTransferProtocol **)soap_malloc(soap, sizeof(struct srm2__ArrayOfTSupportedTransferProtocol *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__ArrayOfTSupportedTransferProtocol(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfTSupportedTransferProtocol **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfTSupportedTransferProtocol, sizeof(struct srm2__ArrayOfTSupportedTransferProtocol), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__ArrayOfTRequestTokenReturn(struct soap *soap, struct srm2__ArrayOfTRequestTokenReturn *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__ArrayOfTRequestTokenReturn))
		soap_serialize_srm2__ArrayOfTRequestTokenReturn(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__ArrayOfTRequestTokenReturn(struct soap *soap, struct srm2__ArrayOfTRequestTokenReturn *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__ArrayOfTRequestTokenReturn);
	if (soap_out_PointerTosrm2__ArrayOfTRequestTokenReturn(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__ArrayOfTRequestTokenReturn(struct soap *soap, const char *tag, int id, struct srm2__ArrayOfTRequestTokenReturn *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__ArrayOfTRequestTokenReturn);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__ArrayOfTRequestTokenReturn(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__ArrayOfTRequestTokenReturn ** SOAP_FMAC4 soap_get_PointerTosrm2__ArrayOfTRequestTokenReturn(struct soap *soap, struct srm2__ArrayOfTRequestTokenReturn **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__ArrayOfTRequestTokenReturn(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfTRequestTokenReturn ** SOAP_FMAC4 soap_in_PointerTosrm2__ArrayOfTRequestTokenReturn(struct soap *soap, const char *tag, struct srm2__ArrayOfTRequestTokenReturn **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__ArrayOfTRequestTokenReturn **)soap_malloc(soap, sizeof(struct srm2__ArrayOfTRequestTokenReturn *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__ArrayOfTRequestTokenReturn(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfTRequestTokenReturn **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfTRequestTokenReturn, sizeof(struct srm2__ArrayOfTRequestTokenReturn), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__ArrayOfTRequestSummary(struct soap *soap, struct srm2__ArrayOfTRequestSummary *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__ArrayOfTRequestSummary))
		soap_serialize_srm2__ArrayOfTRequestSummary(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__ArrayOfTRequestSummary(struct soap *soap, struct srm2__ArrayOfTRequestSummary *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__ArrayOfTRequestSummary);
	if (soap_out_PointerTosrm2__ArrayOfTRequestSummary(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__ArrayOfTRequestSummary(struct soap *soap, const char *tag, int id, struct srm2__ArrayOfTRequestSummary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__ArrayOfTRequestSummary);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__ArrayOfTRequestSummary(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__ArrayOfTRequestSummary ** SOAP_FMAC4 soap_get_PointerTosrm2__ArrayOfTRequestSummary(struct soap *soap, struct srm2__ArrayOfTRequestSummary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__ArrayOfTRequestSummary(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfTRequestSummary ** SOAP_FMAC4 soap_in_PointerTosrm2__ArrayOfTRequestSummary(struct soap *soap, const char *tag, struct srm2__ArrayOfTRequestSummary **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__ArrayOfTRequestSummary **)soap_malloc(soap, sizeof(struct srm2__ArrayOfTRequestSummary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__ArrayOfTRequestSummary(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfTRequestSummary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfTRequestSummary, sizeof(struct srm2__ArrayOfTRequestSummary), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__ArrayOfTCopyRequestFileStatus(struct soap *soap, struct srm2__ArrayOfTCopyRequestFileStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__ArrayOfTCopyRequestFileStatus))
		soap_serialize_srm2__ArrayOfTCopyRequestFileStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__ArrayOfTCopyRequestFileStatus(struct soap *soap, struct srm2__ArrayOfTCopyRequestFileStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__ArrayOfTCopyRequestFileStatus);
	if (soap_out_PointerTosrm2__ArrayOfTCopyRequestFileStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__ArrayOfTCopyRequestFileStatus(struct soap *soap, const char *tag, int id, struct srm2__ArrayOfTCopyRequestFileStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__ArrayOfTCopyRequestFileStatus);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__ArrayOfTCopyRequestFileStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__ArrayOfTCopyRequestFileStatus ** SOAP_FMAC4 soap_get_PointerTosrm2__ArrayOfTCopyRequestFileStatus(struct soap *soap, struct srm2__ArrayOfTCopyRequestFileStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__ArrayOfTCopyRequestFileStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfTCopyRequestFileStatus ** SOAP_FMAC4 soap_in_PointerTosrm2__ArrayOfTCopyRequestFileStatus(struct soap *soap, const char *tag, struct srm2__ArrayOfTCopyRequestFileStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__ArrayOfTCopyRequestFileStatus **)soap_malloc(soap, sizeof(struct srm2__ArrayOfTCopyRequestFileStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__ArrayOfTCopyRequestFileStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfTCopyRequestFileStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfTCopyRequestFileStatus, sizeof(struct srm2__ArrayOfTCopyRequestFileStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__ArrayOfTCopyFileRequest(struct soap *soap, struct srm2__ArrayOfTCopyFileRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__ArrayOfTCopyFileRequest))
		soap_serialize_srm2__ArrayOfTCopyFileRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__ArrayOfTCopyFileRequest(struct soap *soap, struct srm2__ArrayOfTCopyFileRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__ArrayOfTCopyFileRequest);
	if (soap_out_PointerTosrm2__ArrayOfTCopyFileRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__ArrayOfTCopyFileRequest(struct soap *soap, const char *tag, int id, struct srm2__ArrayOfTCopyFileRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__ArrayOfTCopyFileRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__ArrayOfTCopyFileRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__ArrayOfTCopyFileRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__ArrayOfTCopyFileRequest(struct soap *soap, struct srm2__ArrayOfTCopyFileRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__ArrayOfTCopyFileRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfTCopyFileRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__ArrayOfTCopyFileRequest(struct soap *soap, const char *tag, struct srm2__ArrayOfTCopyFileRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__ArrayOfTCopyFileRequest **)soap_malloc(soap, sizeof(struct srm2__ArrayOfTCopyFileRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__ArrayOfTCopyFileRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfTCopyFileRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfTCopyFileRequest, sizeof(struct srm2__ArrayOfTCopyFileRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__ArrayOfTPutRequestFileStatus(struct soap *soap, struct srm2__ArrayOfTPutRequestFileStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__ArrayOfTPutRequestFileStatus))
		soap_serialize_srm2__ArrayOfTPutRequestFileStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__ArrayOfTPutRequestFileStatus(struct soap *soap, struct srm2__ArrayOfTPutRequestFileStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__ArrayOfTPutRequestFileStatus);
	if (soap_out_PointerTosrm2__ArrayOfTPutRequestFileStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__ArrayOfTPutRequestFileStatus(struct soap *soap, const char *tag, int id, struct srm2__ArrayOfTPutRequestFileStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__ArrayOfTPutRequestFileStatus);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__ArrayOfTPutRequestFileStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__ArrayOfTPutRequestFileStatus ** SOAP_FMAC4 soap_get_PointerTosrm2__ArrayOfTPutRequestFileStatus(struct soap *soap, struct srm2__ArrayOfTPutRequestFileStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__ArrayOfTPutRequestFileStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfTPutRequestFileStatus ** SOAP_FMAC4 soap_in_PointerTosrm2__ArrayOfTPutRequestFileStatus(struct soap *soap, const char *tag, struct srm2__ArrayOfTPutRequestFileStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__ArrayOfTPutRequestFileStatus **)soap_malloc(soap, sizeof(struct srm2__ArrayOfTPutRequestFileStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__ArrayOfTPutRequestFileStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfTPutRequestFileStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfTPutRequestFileStatus, sizeof(struct srm2__ArrayOfTPutRequestFileStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__TOverwriteMode(struct soap *soap, enum srm2__TOverwriteMode *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_srm2__TOverwriteMode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__TOverwriteMode(struct soap *soap, enum srm2__TOverwriteMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__TOverwriteMode);
	if (soap_out_PointerTosrm2__TOverwriteMode(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__TOverwriteMode(struct soap *soap, const char *tag, int id, enum srm2__TOverwriteMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__TOverwriteMode);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__TOverwriteMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum srm2__TOverwriteMode ** SOAP_FMAC4 soap_get_PointerTosrm2__TOverwriteMode(struct soap *soap, enum srm2__TOverwriteMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__TOverwriteMode(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum srm2__TOverwriteMode ** SOAP_FMAC4 soap_in_PointerTosrm2__TOverwriteMode(struct soap *soap, const char *tag, enum srm2__TOverwriteMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (enum srm2__TOverwriteMode **)soap_malloc(soap, sizeof(enum srm2__TOverwriteMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__TOverwriteMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum srm2__TOverwriteMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TOverwriteMode, sizeof(enum srm2__TOverwriteMode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__ArrayOfTPutFileRequest(struct soap *soap, struct srm2__ArrayOfTPutFileRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__ArrayOfTPutFileRequest))
		soap_serialize_srm2__ArrayOfTPutFileRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__ArrayOfTPutFileRequest(struct soap *soap, struct srm2__ArrayOfTPutFileRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__ArrayOfTPutFileRequest);
	if (soap_out_PointerTosrm2__ArrayOfTPutFileRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__ArrayOfTPutFileRequest(struct soap *soap, const char *tag, int id, struct srm2__ArrayOfTPutFileRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__ArrayOfTPutFileRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__ArrayOfTPutFileRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__ArrayOfTPutFileRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__ArrayOfTPutFileRequest(struct soap *soap, struct srm2__ArrayOfTPutFileRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__ArrayOfTPutFileRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfTPutFileRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__ArrayOfTPutFileRequest(struct soap *soap, const char *tag, struct srm2__ArrayOfTPutFileRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__ArrayOfTPutFileRequest **)soap_malloc(soap, sizeof(struct srm2__ArrayOfTPutFileRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__ArrayOfTPutFileRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfTPutFileRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfTPutFileRequest, sizeof(struct srm2__ArrayOfTPutFileRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__ArrayOfTBringOnlineRequestFileStatus(struct soap *soap, struct srm2__ArrayOfTBringOnlineRequestFileStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__ArrayOfTBringOnlineRequestFileStatus))
		soap_serialize_srm2__ArrayOfTBringOnlineRequestFileStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__ArrayOfTBringOnlineRequestFileStatus(struct soap *soap, struct srm2__ArrayOfTBringOnlineRequestFileStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__ArrayOfTBringOnlineRequestFileStatus);
	if (soap_out_PointerTosrm2__ArrayOfTBringOnlineRequestFileStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__ArrayOfTBringOnlineRequestFileStatus(struct soap *soap, const char *tag, int id, struct srm2__ArrayOfTBringOnlineRequestFileStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__ArrayOfTBringOnlineRequestFileStatus);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__ArrayOfTBringOnlineRequestFileStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__ArrayOfTBringOnlineRequestFileStatus ** SOAP_FMAC4 soap_get_PointerTosrm2__ArrayOfTBringOnlineRequestFileStatus(struct soap *soap, struct srm2__ArrayOfTBringOnlineRequestFileStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__ArrayOfTBringOnlineRequestFileStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfTBringOnlineRequestFileStatus ** SOAP_FMAC4 soap_in_PointerTosrm2__ArrayOfTBringOnlineRequestFileStatus(struct soap *soap, const char *tag, struct srm2__ArrayOfTBringOnlineRequestFileStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__ArrayOfTBringOnlineRequestFileStatus **)soap_malloc(soap, sizeof(struct srm2__ArrayOfTBringOnlineRequestFileStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__ArrayOfTBringOnlineRequestFileStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfTBringOnlineRequestFileStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfTBringOnlineRequestFileStatus, sizeof(struct srm2__ArrayOfTBringOnlineRequestFileStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__ArrayOfTGetRequestFileStatus(struct soap *soap, struct srm2__ArrayOfTGetRequestFileStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__ArrayOfTGetRequestFileStatus))
		soap_serialize_srm2__ArrayOfTGetRequestFileStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__ArrayOfTGetRequestFileStatus(struct soap *soap, struct srm2__ArrayOfTGetRequestFileStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__ArrayOfTGetRequestFileStatus);
	if (soap_out_PointerTosrm2__ArrayOfTGetRequestFileStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__ArrayOfTGetRequestFileStatus(struct soap *soap, const char *tag, int id, struct srm2__ArrayOfTGetRequestFileStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__ArrayOfTGetRequestFileStatus);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__ArrayOfTGetRequestFileStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__ArrayOfTGetRequestFileStatus ** SOAP_FMAC4 soap_get_PointerTosrm2__ArrayOfTGetRequestFileStatus(struct soap *soap, struct srm2__ArrayOfTGetRequestFileStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__ArrayOfTGetRequestFileStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfTGetRequestFileStatus ** SOAP_FMAC4 soap_in_PointerTosrm2__ArrayOfTGetRequestFileStatus(struct soap *soap, const char *tag, struct srm2__ArrayOfTGetRequestFileStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__ArrayOfTGetRequestFileStatus **)soap_malloc(soap, sizeof(struct srm2__ArrayOfTGetRequestFileStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__ArrayOfTGetRequestFileStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfTGetRequestFileStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfTGetRequestFileStatus, sizeof(struct srm2__ArrayOfTGetRequestFileStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__ArrayOfTGetFileRequest(struct soap *soap, struct srm2__ArrayOfTGetFileRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__ArrayOfTGetFileRequest))
		soap_serialize_srm2__ArrayOfTGetFileRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__ArrayOfTGetFileRequest(struct soap *soap, struct srm2__ArrayOfTGetFileRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__ArrayOfTGetFileRequest);
	if (soap_out_PointerTosrm2__ArrayOfTGetFileRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__ArrayOfTGetFileRequest(struct soap *soap, const char *tag, int id, struct srm2__ArrayOfTGetFileRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__ArrayOfTGetFileRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__ArrayOfTGetFileRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__ArrayOfTGetFileRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__ArrayOfTGetFileRequest(struct soap *soap, struct srm2__ArrayOfTGetFileRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__ArrayOfTGetFileRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfTGetFileRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__ArrayOfTGetFileRequest(struct soap *soap, const char *tag, struct srm2__ArrayOfTGetFileRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__ArrayOfTGetFileRequest **)soap_malloc(soap, sizeof(struct srm2__ArrayOfTGetFileRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__ArrayOfTGetFileRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfTGetFileRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfTGetFileRequest, sizeof(struct srm2__ArrayOfTGetFileRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__ArrayOfTPermissionReturn(struct soap *soap, struct srm2__ArrayOfTPermissionReturn *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__ArrayOfTPermissionReturn))
		soap_serialize_srm2__ArrayOfTPermissionReturn(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__ArrayOfTPermissionReturn(struct soap *soap, struct srm2__ArrayOfTPermissionReturn *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__ArrayOfTPermissionReturn);
	if (soap_out_PointerTosrm2__ArrayOfTPermissionReturn(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__ArrayOfTPermissionReturn(struct soap *soap, const char *tag, int id, struct srm2__ArrayOfTPermissionReturn *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__ArrayOfTPermissionReturn);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__ArrayOfTPermissionReturn(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__ArrayOfTPermissionReturn ** SOAP_FMAC4 soap_get_PointerTosrm2__ArrayOfTPermissionReturn(struct soap *soap, struct srm2__ArrayOfTPermissionReturn **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__ArrayOfTPermissionReturn(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfTPermissionReturn ** SOAP_FMAC4 soap_in_PointerTosrm2__ArrayOfTPermissionReturn(struct soap *soap, const char *tag, struct srm2__ArrayOfTPermissionReturn **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__ArrayOfTPermissionReturn **)soap_malloc(soap, sizeof(struct srm2__ArrayOfTPermissionReturn *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__ArrayOfTPermissionReturn(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfTPermissionReturn **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfTPermissionReturn, sizeof(struct srm2__ArrayOfTPermissionReturn), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__ArrayOfTSURLPermissionReturn(struct soap *soap, struct srm2__ArrayOfTSURLPermissionReturn *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__ArrayOfTSURLPermissionReturn))
		soap_serialize_srm2__ArrayOfTSURLPermissionReturn(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__ArrayOfTSURLPermissionReturn(struct soap *soap, struct srm2__ArrayOfTSURLPermissionReturn *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__ArrayOfTSURLPermissionReturn);
	if (soap_out_PointerTosrm2__ArrayOfTSURLPermissionReturn(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__ArrayOfTSURLPermissionReturn(struct soap *soap, const char *tag, int id, struct srm2__ArrayOfTSURLPermissionReturn *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__ArrayOfTSURLPermissionReturn);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__ArrayOfTSURLPermissionReturn(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__ArrayOfTSURLPermissionReturn ** SOAP_FMAC4 soap_get_PointerTosrm2__ArrayOfTSURLPermissionReturn(struct soap *soap, struct srm2__ArrayOfTSURLPermissionReturn **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__ArrayOfTSURLPermissionReturn(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfTSURLPermissionReturn ** SOAP_FMAC4 soap_in_PointerTosrm2__ArrayOfTSURLPermissionReturn(struct soap *soap, const char *tag, struct srm2__ArrayOfTSURLPermissionReturn **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__ArrayOfTSURLPermissionReturn **)soap_malloc(soap, sizeof(struct srm2__ArrayOfTSURLPermissionReturn *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__ArrayOfTSURLPermissionReturn(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfTSURLPermissionReturn **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfTSURLPermissionReturn, sizeof(struct srm2__ArrayOfTSURLPermissionReturn), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__ArrayOfTSURLLifetimeReturnStatus(struct soap *soap, struct srm2__ArrayOfTSURLLifetimeReturnStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__ArrayOfTSURLLifetimeReturnStatus))
		soap_serialize_srm2__ArrayOfTSURLLifetimeReturnStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__ArrayOfTSURLLifetimeReturnStatus(struct soap *soap, struct srm2__ArrayOfTSURLLifetimeReturnStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__ArrayOfTSURLLifetimeReturnStatus);
	if (soap_out_PointerTosrm2__ArrayOfTSURLLifetimeReturnStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__ArrayOfTSURLLifetimeReturnStatus(struct soap *soap, const char *tag, int id, struct srm2__ArrayOfTSURLLifetimeReturnStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__ArrayOfTSURLLifetimeReturnStatus);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__ArrayOfTSURLLifetimeReturnStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__ArrayOfTSURLLifetimeReturnStatus ** SOAP_FMAC4 soap_get_PointerTosrm2__ArrayOfTSURLLifetimeReturnStatus(struct soap *soap, struct srm2__ArrayOfTSURLLifetimeReturnStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__ArrayOfTSURLLifetimeReturnStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfTSURLLifetimeReturnStatus ** SOAP_FMAC4 soap_in_PointerTosrm2__ArrayOfTSURLLifetimeReturnStatus(struct soap *soap, const char *tag, struct srm2__ArrayOfTSURLLifetimeReturnStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__ArrayOfTSURLLifetimeReturnStatus **)soap_malloc(soap, sizeof(struct srm2__ArrayOfTSURLLifetimeReturnStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__ArrayOfTSURLLifetimeReturnStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfTSURLLifetimeReturnStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfTSURLLifetimeReturnStatus, sizeof(struct srm2__ArrayOfTSURLLifetimeReturnStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__ArrayOfTSURLReturnStatus(struct soap *soap, struct srm2__ArrayOfTSURLReturnStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__ArrayOfTSURLReturnStatus))
		soap_serialize_srm2__ArrayOfTSURLReturnStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__ArrayOfTSURLReturnStatus(struct soap *soap, struct srm2__ArrayOfTSURLReturnStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__ArrayOfTSURLReturnStatus);
	if (soap_out_PointerTosrm2__ArrayOfTSURLReturnStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__ArrayOfTSURLReturnStatus(struct soap *soap, const char *tag, int id, struct srm2__ArrayOfTSURLReturnStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__ArrayOfTSURLReturnStatus);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__ArrayOfTSURLReturnStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__ArrayOfTSURLReturnStatus ** SOAP_FMAC4 soap_get_PointerTosrm2__ArrayOfTSURLReturnStatus(struct soap *soap, struct srm2__ArrayOfTSURLReturnStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__ArrayOfTSURLReturnStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfTSURLReturnStatus ** SOAP_FMAC4 soap_in_PointerTosrm2__ArrayOfTSURLReturnStatus(struct soap *soap, const char *tag, struct srm2__ArrayOfTSURLReturnStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__ArrayOfTSURLReturnStatus **)soap_malloc(soap, sizeof(struct srm2__ArrayOfTSURLReturnStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__ArrayOfTSURLReturnStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfTSURLReturnStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfTSURLReturnStatus, sizeof(struct srm2__ArrayOfTSURLReturnStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__ArrayOfAnyURI(struct soap *soap, struct srm2__ArrayOfAnyURI *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__ArrayOfAnyURI))
		soap_serialize_srm2__ArrayOfAnyURI(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__ArrayOfAnyURI(struct soap *soap, struct srm2__ArrayOfAnyURI *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__ArrayOfAnyURI);
	if (soap_out_PointerTosrm2__ArrayOfAnyURI(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__ArrayOfAnyURI(struct soap *soap, const char *tag, int id, struct srm2__ArrayOfAnyURI *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__ArrayOfAnyURI);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__ArrayOfAnyURI(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__ArrayOfAnyURI ** SOAP_FMAC4 soap_get_PointerTosrm2__ArrayOfAnyURI(struct soap *soap, struct srm2__ArrayOfAnyURI **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__ArrayOfAnyURI(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfAnyURI ** SOAP_FMAC4 soap_in_PointerTosrm2__ArrayOfAnyURI(struct soap *soap, const char *tag, struct srm2__ArrayOfAnyURI **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__ArrayOfAnyURI **)soap_malloc(soap, sizeof(struct srm2__ArrayOfAnyURI *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__ArrayOfAnyURI(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfAnyURI **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfAnyURI, sizeof(struct srm2__ArrayOfAnyURI), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__ArrayOfTMetaDataSpace(struct soap *soap, struct srm2__ArrayOfTMetaDataSpace *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__ArrayOfTMetaDataSpace))
		soap_serialize_srm2__ArrayOfTMetaDataSpace(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__ArrayOfTMetaDataSpace(struct soap *soap, struct srm2__ArrayOfTMetaDataSpace *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__ArrayOfTMetaDataSpace);
	if (soap_out_PointerTosrm2__ArrayOfTMetaDataSpace(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__ArrayOfTMetaDataSpace(struct soap *soap, const char *tag, int id, struct srm2__ArrayOfTMetaDataSpace *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__ArrayOfTMetaDataSpace);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__ArrayOfTMetaDataSpace(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__ArrayOfTMetaDataSpace ** SOAP_FMAC4 soap_get_PointerTosrm2__ArrayOfTMetaDataSpace(struct soap *soap, struct srm2__ArrayOfTMetaDataSpace **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__ArrayOfTMetaDataSpace(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfTMetaDataSpace ** SOAP_FMAC4 soap_in_PointerTosrm2__ArrayOfTMetaDataSpace(struct soap *soap, const char *tag, struct srm2__ArrayOfTMetaDataSpace **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__ArrayOfTMetaDataSpace **)soap_malloc(soap, sizeof(struct srm2__ArrayOfTMetaDataSpace *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__ArrayOfTMetaDataSpace(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfTMetaDataSpace **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfTMetaDataSpace, sizeof(struct srm2__ArrayOfTMetaDataSpace), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__TTransferParameters(struct soap *soap, struct srm2__TTransferParameters *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__TTransferParameters))
		soap_serialize_srm2__TTransferParameters(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__TTransferParameters(struct soap *soap, struct srm2__TTransferParameters *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__TTransferParameters);
	if (soap_out_PointerTosrm2__TTransferParameters(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__TTransferParameters(struct soap *soap, const char *tag, int id, struct srm2__TTransferParameters *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__TTransferParameters);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__TTransferParameters(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TTransferParameters ** SOAP_FMAC4 soap_get_PointerTosrm2__TTransferParameters(struct soap *soap, struct srm2__TTransferParameters **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__TTransferParameters(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TTransferParameters ** SOAP_FMAC4 soap_in_PointerTosrm2__TTransferParameters(struct soap *soap, const char *tag, struct srm2__TTransferParameters **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TTransferParameters **)soap_malloc(soap, sizeof(struct srm2__TTransferParameters *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__TTransferParameters(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TTransferParameters **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TTransferParameters, sizeof(struct srm2__TTransferParameters), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__ArrayOfUnsignedLong(struct soap *soap, struct srm2__ArrayOfUnsignedLong *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__ArrayOfUnsignedLong))
		soap_serialize_srm2__ArrayOfUnsignedLong(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__ArrayOfUnsignedLong(struct soap *soap, struct srm2__ArrayOfUnsignedLong *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__ArrayOfUnsignedLong);
	if (soap_out_PointerTosrm2__ArrayOfUnsignedLong(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__ArrayOfUnsignedLong(struct soap *soap, const char *tag, int id, struct srm2__ArrayOfUnsignedLong *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__ArrayOfUnsignedLong);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__ArrayOfUnsignedLong(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__ArrayOfUnsignedLong ** SOAP_FMAC4 soap_get_PointerTosrm2__ArrayOfUnsignedLong(struct soap *soap, struct srm2__ArrayOfUnsignedLong **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__ArrayOfUnsignedLong(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfUnsignedLong ** SOAP_FMAC4 soap_in_PointerTosrm2__ArrayOfUnsignedLong(struct soap *soap, const char *tag, struct srm2__ArrayOfUnsignedLong **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__ArrayOfUnsignedLong **)soap_malloc(soap, sizeof(struct srm2__ArrayOfUnsignedLong *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__ArrayOfUnsignedLong(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfUnsignedLong **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfUnsignedLong, sizeof(struct srm2__ArrayOfUnsignedLong), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTosrm2__TSupportedTransferProtocol(struct soap *soap, struct srm2__TSupportedTransferProtocol **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTosrm2__TSupportedTransferProtocol))
		soap_serialize_PointerTosrm2__TSupportedTransferProtocol(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTosrm2__TSupportedTransferProtocol(struct soap *soap, struct srm2__TSupportedTransferProtocol **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTosrm2__TSupportedTransferProtocol);
	if (soap_out_PointerToPointerTosrm2__TSupportedTransferProtocol(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTosrm2__TSupportedTransferProtocol(struct soap *soap, const char *tag, int id, struct srm2__TSupportedTransferProtocol **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTosrm2__TSupportedTransferProtocol);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTosrm2__TSupportedTransferProtocol(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TSupportedTransferProtocol *** SOAP_FMAC4 soap_get_PointerToPointerTosrm2__TSupportedTransferProtocol(struct soap *soap, struct srm2__TSupportedTransferProtocol ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTosrm2__TSupportedTransferProtocol(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TSupportedTransferProtocol *** SOAP_FMAC4 soap_in_PointerToPointerTosrm2__TSupportedTransferProtocol(struct soap *soap, const char *tag, struct srm2__TSupportedTransferProtocol ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TSupportedTransferProtocol ***)soap_malloc(soap, sizeof(struct srm2__TSupportedTransferProtocol **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTosrm2__TSupportedTransferProtocol(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TSupportedTransferProtocol ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTosrm2__TSupportedTransferProtocol, sizeof(struct srm2__TSupportedTransferProtocol *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__TSupportedTransferProtocol(struct soap *soap, struct srm2__TSupportedTransferProtocol *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__TSupportedTransferProtocol))
		soap_serialize_srm2__TSupportedTransferProtocol(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__TSupportedTransferProtocol(struct soap *soap, struct srm2__TSupportedTransferProtocol *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__TSupportedTransferProtocol);
	if (soap_out_PointerTosrm2__TSupportedTransferProtocol(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__TSupportedTransferProtocol(struct soap *soap, const char *tag, int id, struct srm2__TSupportedTransferProtocol *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__TSupportedTransferProtocol);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__TSupportedTransferProtocol(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TSupportedTransferProtocol ** SOAP_FMAC4 soap_get_PointerTosrm2__TSupportedTransferProtocol(struct soap *soap, struct srm2__TSupportedTransferProtocol **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__TSupportedTransferProtocol(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TSupportedTransferProtocol ** SOAP_FMAC4 soap_in_PointerTosrm2__TSupportedTransferProtocol(struct soap *soap, const char *tag, struct srm2__TSupportedTransferProtocol **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TSupportedTransferProtocol **)soap_malloc(soap, sizeof(struct srm2__TSupportedTransferProtocol *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__TSupportedTransferProtocol(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TSupportedTransferProtocol **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TSupportedTransferProtocol, sizeof(struct srm2__TSupportedTransferProtocol), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTosrm2__TRequestTokenReturn(struct soap *soap, struct srm2__TRequestTokenReturn **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTosrm2__TRequestTokenReturn))
		soap_serialize_PointerTosrm2__TRequestTokenReturn(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTosrm2__TRequestTokenReturn(struct soap *soap, struct srm2__TRequestTokenReturn **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTosrm2__TRequestTokenReturn);
	if (soap_out_PointerToPointerTosrm2__TRequestTokenReturn(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTosrm2__TRequestTokenReturn(struct soap *soap, const char *tag, int id, struct srm2__TRequestTokenReturn **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTosrm2__TRequestTokenReturn);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTosrm2__TRequestTokenReturn(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TRequestTokenReturn *** SOAP_FMAC4 soap_get_PointerToPointerTosrm2__TRequestTokenReturn(struct soap *soap, struct srm2__TRequestTokenReturn ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTosrm2__TRequestTokenReturn(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TRequestTokenReturn *** SOAP_FMAC4 soap_in_PointerToPointerTosrm2__TRequestTokenReturn(struct soap *soap, const char *tag, struct srm2__TRequestTokenReturn ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TRequestTokenReturn ***)soap_malloc(soap, sizeof(struct srm2__TRequestTokenReturn **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTosrm2__TRequestTokenReturn(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TRequestTokenReturn ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTosrm2__TRequestTokenReturn, sizeof(struct srm2__TRequestTokenReturn *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__TRequestTokenReturn(struct soap *soap, struct srm2__TRequestTokenReturn *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__TRequestTokenReturn))
		soap_serialize_srm2__TRequestTokenReturn(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__TRequestTokenReturn(struct soap *soap, struct srm2__TRequestTokenReturn *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__TRequestTokenReturn);
	if (soap_out_PointerTosrm2__TRequestTokenReturn(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__TRequestTokenReturn(struct soap *soap, const char *tag, int id, struct srm2__TRequestTokenReturn *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__TRequestTokenReturn);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__TRequestTokenReturn(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TRequestTokenReturn ** SOAP_FMAC4 soap_get_PointerTosrm2__TRequestTokenReturn(struct soap *soap, struct srm2__TRequestTokenReturn **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__TRequestTokenReturn(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TRequestTokenReturn ** SOAP_FMAC4 soap_in_PointerTosrm2__TRequestTokenReturn(struct soap *soap, const char *tag, struct srm2__TRequestTokenReturn **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TRequestTokenReturn **)soap_malloc(soap, sizeof(struct srm2__TRequestTokenReturn *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__TRequestTokenReturn(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TRequestTokenReturn **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TRequestTokenReturn, sizeof(struct srm2__TRequestTokenReturn), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTosrm2__TPermissionReturn(struct soap *soap, struct srm2__TPermissionReturn **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTosrm2__TPermissionReturn))
		soap_serialize_PointerTosrm2__TPermissionReturn(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTosrm2__TPermissionReturn(struct soap *soap, struct srm2__TPermissionReturn **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTosrm2__TPermissionReturn);
	if (soap_out_PointerToPointerTosrm2__TPermissionReturn(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTosrm2__TPermissionReturn(struct soap *soap, const char *tag, int id, struct srm2__TPermissionReturn **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTosrm2__TPermissionReturn);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTosrm2__TPermissionReturn(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TPermissionReturn *** SOAP_FMAC4 soap_get_PointerToPointerTosrm2__TPermissionReturn(struct soap *soap, struct srm2__TPermissionReturn ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTosrm2__TPermissionReturn(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TPermissionReturn *** SOAP_FMAC4 soap_in_PointerToPointerTosrm2__TPermissionReturn(struct soap *soap, const char *tag, struct srm2__TPermissionReturn ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TPermissionReturn ***)soap_malloc(soap, sizeof(struct srm2__TPermissionReturn **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTosrm2__TPermissionReturn(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TPermissionReturn ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTosrm2__TPermissionReturn, sizeof(struct srm2__TPermissionReturn *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__TPermissionReturn(struct soap *soap, struct srm2__TPermissionReturn *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__TPermissionReturn))
		soap_serialize_srm2__TPermissionReturn(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__TPermissionReturn(struct soap *soap, struct srm2__TPermissionReturn *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__TPermissionReturn);
	if (soap_out_PointerTosrm2__TPermissionReturn(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__TPermissionReturn(struct soap *soap, const char *tag, int id, struct srm2__TPermissionReturn *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__TPermissionReturn);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__TPermissionReturn(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TPermissionReturn ** SOAP_FMAC4 soap_get_PointerTosrm2__TPermissionReturn(struct soap *soap, struct srm2__TPermissionReturn **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__TPermissionReturn(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TPermissionReturn ** SOAP_FMAC4 soap_in_PointerTosrm2__TPermissionReturn(struct soap *soap, const char *tag, struct srm2__TPermissionReturn **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TPermissionReturn **)soap_malloc(soap, sizeof(struct srm2__TPermissionReturn *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__TPermissionReturn(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TPermissionReturn **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TPermissionReturn, sizeof(struct srm2__TPermissionReturn), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__ArrayOfTGroupPermission(struct soap *soap, struct srm2__ArrayOfTGroupPermission *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__ArrayOfTGroupPermission))
		soap_serialize_srm2__ArrayOfTGroupPermission(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__ArrayOfTGroupPermission(struct soap *soap, struct srm2__ArrayOfTGroupPermission *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__ArrayOfTGroupPermission);
	if (soap_out_PointerTosrm2__ArrayOfTGroupPermission(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__ArrayOfTGroupPermission(struct soap *soap, const char *tag, int id, struct srm2__ArrayOfTGroupPermission *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__ArrayOfTGroupPermission);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__ArrayOfTGroupPermission(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__ArrayOfTGroupPermission ** SOAP_FMAC4 soap_get_PointerTosrm2__ArrayOfTGroupPermission(struct soap *soap, struct srm2__ArrayOfTGroupPermission **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__ArrayOfTGroupPermission(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfTGroupPermission ** SOAP_FMAC4 soap_in_PointerTosrm2__ArrayOfTGroupPermission(struct soap *soap, const char *tag, struct srm2__ArrayOfTGroupPermission **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__ArrayOfTGroupPermission **)soap_malloc(soap, sizeof(struct srm2__ArrayOfTGroupPermission *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__ArrayOfTGroupPermission(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfTGroupPermission **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfTGroupPermission, sizeof(struct srm2__ArrayOfTGroupPermission), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__ArrayOfTUserPermission(struct soap *soap, struct srm2__ArrayOfTUserPermission *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__ArrayOfTUserPermission))
		soap_serialize_srm2__ArrayOfTUserPermission(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__ArrayOfTUserPermission(struct soap *soap, struct srm2__ArrayOfTUserPermission *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__ArrayOfTUserPermission);
	if (soap_out_PointerTosrm2__ArrayOfTUserPermission(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__ArrayOfTUserPermission(struct soap *soap, const char *tag, int id, struct srm2__ArrayOfTUserPermission *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__ArrayOfTUserPermission);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__ArrayOfTUserPermission(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__ArrayOfTUserPermission ** SOAP_FMAC4 soap_get_PointerTosrm2__ArrayOfTUserPermission(struct soap *soap, struct srm2__ArrayOfTUserPermission **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__ArrayOfTUserPermission(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfTUserPermission ** SOAP_FMAC4 soap_in_PointerTosrm2__ArrayOfTUserPermission(struct soap *soap, const char *tag, struct srm2__ArrayOfTUserPermission **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__ArrayOfTUserPermission **)soap_malloc(soap, sizeof(struct srm2__ArrayOfTUserPermission *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__ArrayOfTUserPermission(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfTUserPermission **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfTUserPermission, sizeof(struct srm2__ArrayOfTUserPermission), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTosrm2__TSURLPermissionReturn(struct soap *soap, struct srm2__TSURLPermissionReturn **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTosrm2__TSURLPermissionReturn))
		soap_serialize_PointerTosrm2__TSURLPermissionReturn(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTosrm2__TSURLPermissionReturn(struct soap *soap, struct srm2__TSURLPermissionReturn **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTosrm2__TSURLPermissionReturn);
	if (soap_out_PointerToPointerTosrm2__TSURLPermissionReturn(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTosrm2__TSURLPermissionReturn(struct soap *soap, const char *tag, int id, struct srm2__TSURLPermissionReturn **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTosrm2__TSURLPermissionReturn);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTosrm2__TSURLPermissionReturn(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TSURLPermissionReturn *** SOAP_FMAC4 soap_get_PointerToPointerTosrm2__TSURLPermissionReturn(struct soap *soap, struct srm2__TSURLPermissionReturn ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTosrm2__TSURLPermissionReturn(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TSURLPermissionReturn *** SOAP_FMAC4 soap_in_PointerToPointerTosrm2__TSURLPermissionReturn(struct soap *soap, const char *tag, struct srm2__TSURLPermissionReturn ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TSURLPermissionReturn ***)soap_malloc(soap, sizeof(struct srm2__TSURLPermissionReturn **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTosrm2__TSURLPermissionReturn(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TSURLPermissionReturn ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTosrm2__TSURLPermissionReturn, sizeof(struct srm2__TSURLPermissionReturn *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__TSURLPermissionReturn(struct soap *soap, struct srm2__TSURLPermissionReturn *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__TSURLPermissionReturn))
		soap_serialize_srm2__TSURLPermissionReturn(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__TSURLPermissionReturn(struct soap *soap, struct srm2__TSURLPermissionReturn *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__TSURLPermissionReturn);
	if (soap_out_PointerTosrm2__TSURLPermissionReturn(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__TSURLPermissionReturn(struct soap *soap, const char *tag, int id, struct srm2__TSURLPermissionReturn *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__TSURLPermissionReturn);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__TSURLPermissionReturn(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TSURLPermissionReturn ** SOAP_FMAC4 soap_get_PointerTosrm2__TSURLPermissionReturn(struct soap *soap, struct srm2__TSURLPermissionReturn **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__TSURLPermissionReturn(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TSURLPermissionReturn ** SOAP_FMAC4 soap_in_PointerTosrm2__TSURLPermissionReturn(struct soap *soap, const char *tag, struct srm2__TSURLPermissionReturn **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TSURLPermissionReturn **)soap_malloc(soap, sizeof(struct srm2__TSURLPermissionReturn *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__TSURLPermissionReturn(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TSURLPermissionReturn **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TSURLPermissionReturn, sizeof(struct srm2__TSURLPermissionReturn), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTosrm2__TRequestSummary(struct soap *soap, struct srm2__TRequestSummary **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTosrm2__TRequestSummary))
		soap_serialize_PointerTosrm2__TRequestSummary(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTosrm2__TRequestSummary(struct soap *soap, struct srm2__TRequestSummary **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTosrm2__TRequestSummary);
	if (soap_out_PointerToPointerTosrm2__TRequestSummary(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTosrm2__TRequestSummary(struct soap *soap, const char *tag, int id, struct srm2__TRequestSummary **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTosrm2__TRequestSummary);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTosrm2__TRequestSummary(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TRequestSummary *** SOAP_FMAC4 soap_get_PointerToPointerTosrm2__TRequestSummary(struct soap *soap, struct srm2__TRequestSummary ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTosrm2__TRequestSummary(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TRequestSummary *** SOAP_FMAC4 soap_in_PointerToPointerTosrm2__TRequestSummary(struct soap *soap, const char *tag, struct srm2__TRequestSummary ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TRequestSummary ***)soap_malloc(soap, sizeof(struct srm2__TRequestSummary **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTosrm2__TRequestSummary(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TRequestSummary ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTosrm2__TRequestSummary, sizeof(struct srm2__TRequestSummary *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__TRequestSummary(struct soap *soap, struct srm2__TRequestSummary *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__TRequestSummary))
		soap_serialize_srm2__TRequestSummary(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__TRequestSummary(struct soap *soap, struct srm2__TRequestSummary *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__TRequestSummary);
	if (soap_out_PointerTosrm2__TRequestSummary(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__TRequestSummary(struct soap *soap, const char *tag, int id, struct srm2__TRequestSummary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__TRequestSummary);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__TRequestSummary(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TRequestSummary ** SOAP_FMAC4 soap_get_PointerTosrm2__TRequestSummary(struct soap *soap, struct srm2__TRequestSummary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__TRequestSummary(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TRequestSummary ** SOAP_FMAC4 soap_in_PointerTosrm2__TRequestSummary(struct soap *soap, const char *tag, struct srm2__TRequestSummary **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TRequestSummary **)soap_malloc(soap, sizeof(struct srm2__TRequestSummary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__TRequestSummary(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TRequestSummary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TRequestSummary, sizeof(struct srm2__TRequestSummary), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__TRequestType(struct soap *soap, enum srm2__TRequestType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_srm2__TRequestType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__TRequestType(struct soap *soap, enum srm2__TRequestType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__TRequestType);
	if (soap_out_PointerTosrm2__TRequestType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__TRequestType(struct soap *soap, const char *tag, int id, enum srm2__TRequestType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__TRequestType);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__TRequestType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum srm2__TRequestType ** SOAP_FMAC4 soap_get_PointerTosrm2__TRequestType(struct soap *soap, enum srm2__TRequestType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__TRequestType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum srm2__TRequestType ** SOAP_FMAC4 soap_in_PointerTosrm2__TRequestType(struct soap *soap, const char *tag, enum srm2__TRequestType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (enum srm2__TRequestType **)soap_malloc(soap, sizeof(enum srm2__TRequestType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__TRequestType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum srm2__TRequestType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TRequestType, sizeof(enum srm2__TRequestType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTosrm2__TCopyRequestFileStatus(struct soap *soap, struct srm2__TCopyRequestFileStatus **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTosrm2__TCopyRequestFileStatus))
		soap_serialize_PointerTosrm2__TCopyRequestFileStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTosrm2__TCopyRequestFileStatus(struct soap *soap, struct srm2__TCopyRequestFileStatus **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTosrm2__TCopyRequestFileStatus);
	if (soap_out_PointerToPointerTosrm2__TCopyRequestFileStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTosrm2__TCopyRequestFileStatus(struct soap *soap, const char *tag, int id, struct srm2__TCopyRequestFileStatus **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTosrm2__TCopyRequestFileStatus);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTosrm2__TCopyRequestFileStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TCopyRequestFileStatus *** SOAP_FMAC4 soap_get_PointerToPointerTosrm2__TCopyRequestFileStatus(struct soap *soap, struct srm2__TCopyRequestFileStatus ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTosrm2__TCopyRequestFileStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TCopyRequestFileStatus *** SOAP_FMAC4 soap_in_PointerToPointerTosrm2__TCopyRequestFileStatus(struct soap *soap, const char *tag, struct srm2__TCopyRequestFileStatus ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TCopyRequestFileStatus ***)soap_malloc(soap, sizeof(struct srm2__TCopyRequestFileStatus **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTosrm2__TCopyRequestFileStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TCopyRequestFileStatus ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTosrm2__TCopyRequestFileStatus, sizeof(struct srm2__TCopyRequestFileStatus *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__TCopyRequestFileStatus(struct soap *soap, struct srm2__TCopyRequestFileStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__TCopyRequestFileStatus))
		soap_serialize_srm2__TCopyRequestFileStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__TCopyRequestFileStatus(struct soap *soap, struct srm2__TCopyRequestFileStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__TCopyRequestFileStatus);
	if (soap_out_PointerTosrm2__TCopyRequestFileStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__TCopyRequestFileStatus(struct soap *soap, const char *tag, int id, struct srm2__TCopyRequestFileStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__TCopyRequestFileStatus);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__TCopyRequestFileStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TCopyRequestFileStatus ** SOAP_FMAC4 soap_get_PointerTosrm2__TCopyRequestFileStatus(struct soap *soap, struct srm2__TCopyRequestFileStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__TCopyRequestFileStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TCopyRequestFileStatus ** SOAP_FMAC4 soap_in_PointerTosrm2__TCopyRequestFileStatus(struct soap *soap, const char *tag, struct srm2__TCopyRequestFileStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TCopyRequestFileStatus **)soap_malloc(soap, sizeof(struct srm2__TCopyRequestFileStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__TCopyRequestFileStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TCopyRequestFileStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TCopyRequestFileStatus, sizeof(struct srm2__TCopyRequestFileStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTosrm2__TPutRequestFileStatus(struct soap *soap, struct srm2__TPutRequestFileStatus **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTosrm2__TPutRequestFileStatus))
		soap_serialize_PointerTosrm2__TPutRequestFileStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTosrm2__TPutRequestFileStatus(struct soap *soap, struct srm2__TPutRequestFileStatus **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTosrm2__TPutRequestFileStatus);
	if (soap_out_PointerToPointerTosrm2__TPutRequestFileStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTosrm2__TPutRequestFileStatus(struct soap *soap, const char *tag, int id, struct srm2__TPutRequestFileStatus **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTosrm2__TPutRequestFileStatus);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTosrm2__TPutRequestFileStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TPutRequestFileStatus *** SOAP_FMAC4 soap_get_PointerToPointerTosrm2__TPutRequestFileStatus(struct soap *soap, struct srm2__TPutRequestFileStatus ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTosrm2__TPutRequestFileStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TPutRequestFileStatus *** SOAP_FMAC4 soap_in_PointerToPointerTosrm2__TPutRequestFileStatus(struct soap *soap, const char *tag, struct srm2__TPutRequestFileStatus ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TPutRequestFileStatus ***)soap_malloc(soap, sizeof(struct srm2__TPutRequestFileStatus **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTosrm2__TPutRequestFileStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TPutRequestFileStatus ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTosrm2__TPutRequestFileStatus, sizeof(struct srm2__TPutRequestFileStatus *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__TPutRequestFileStatus(struct soap *soap, struct srm2__TPutRequestFileStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__TPutRequestFileStatus))
		soap_serialize_srm2__TPutRequestFileStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__TPutRequestFileStatus(struct soap *soap, struct srm2__TPutRequestFileStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__TPutRequestFileStatus);
	if (soap_out_PointerTosrm2__TPutRequestFileStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__TPutRequestFileStatus(struct soap *soap, const char *tag, int id, struct srm2__TPutRequestFileStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__TPutRequestFileStatus);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__TPutRequestFileStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TPutRequestFileStatus ** SOAP_FMAC4 soap_get_PointerTosrm2__TPutRequestFileStatus(struct soap *soap, struct srm2__TPutRequestFileStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__TPutRequestFileStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TPutRequestFileStatus ** SOAP_FMAC4 soap_in_PointerTosrm2__TPutRequestFileStatus(struct soap *soap, const char *tag, struct srm2__TPutRequestFileStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TPutRequestFileStatus **)soap_malloc(soap, sizeof(struct srm2__TPutRequestFileStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__TPutRequestFileStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TPutRequestFileStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TPutRequestFileStatus, sizeof(struct srm2__TPutRequestFileStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTosrm2__TBringOnlineRequestFileStatus(struct soap *soap, struct srm2__TBringOnlineRequestFileStatus **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTosrm2__TBringOnlineRequestFileStatus))
		soap_serialize_PointerTosrm2__TBringOnlineRequestFileStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTosrm2__TBringOnlineRequestFileStatus(struct soap *soap, struct srm2__TBringOnlineRequestFileStatus **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTosrm2__TBringOnlineRequestFileStatus);
	if (soap_out_PointerToPointerTosrm2__TBringOnlineRequestFileStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTosrm2__TBringOnlineRequestFileStatus(struct soap *soap, const char *tag, int id, struct srm2__TBringOnlineRequestFileStatus **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTosrm2__TBringOnlineRequestFileStatus);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTosrm2__TBringOnlineRequestFileStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TBringOnlineRequestFileStatus *** SOAP_FMAC4 soap_get_PointerToPointerTosrm2__TBringOnlineRequestFileStatus(struct soap *soap, struct srm2__TBringOnlineRequestFileStatus ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTosrm2__TBringOnlineRequestFileStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TBringOnlineRequestFileStatus *** SOAP_FMAC4 soap_in_PointerToPointerTosrm2__TBringOnlineRequestFileStatus(struct soap *soap, const char *tag, struct srm2__TBringOnlineRequestFileStatus ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TBringOnlineRequestFileStatus ***)soap_malloc(soap, sizeof(struct srm2__TBringOnlineRequestFileStatus **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTosrm2__TBringOnlineRequestFileStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TBringOnlineRequestFileStatus ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTosrm2__TBringOnlineRequestFileStatus, sizeof(struct srm2__TBringOnlineRequestFileStatus *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__TBringOnlineRequestFileStatus(struct soap *soap, struct srm2__TBringOnlineRequestFileStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__TBringOnlineRequestFileStatus))
		soap_serialize_srm2__TBringOnlineRequestFileStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__TBringOnlineRequestFileStatus(struct soap *soap, struct srm2__TBringOnlineRequestFileStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__TBringOnlineRequestFileStatus);
	if (soap_out_PointerTosrm2__TBringOnlineRequestFileStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__TBringOnlineRequestFileStatus(struct soap *soap, const char *tag, int id, struct srm2__TBringOnlineRequestFileStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__TBringOnlineRequestFileStatus);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__TBringOnlineRequestFileStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TBringOnlineRequestFileStatus ** SOAP_FMAC4 soap_get_PointerTosrm2__TBringOnlineRequestFileStatus(struct soap *soap, struct srm2__TBringOnlineRequestFileStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__TBringOnlineRequestFileStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TBringOnlineRequestFileStatus ** SOAP_FMAC4 soap_in_PointerTosrm2__TBringOnlineRequestFileStatus(struct soap *soap, const char *tag, struct srm2__TBringOnlineRequestFileStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TBringOnlineRequestFileStatus **)soap_malloc(soap, sizeof(struct srm2__TBringOnlineRequestFileStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__TBringOnlineRequestFileStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TBringOnlineRequestFileStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TBringOnlineRequestFileStatus, sizeof(struct srm2__TBringOnlineRequestFileStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTosrm2__TGetRequestFileStatus(struct soap *soap, struct srm2__TGetRequestFileStatus **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTosrm2__TGetRequestFileStatus))
		soap_serialize_PointerTosrm2__TGetRequestFileStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTosrm2__TGetRequestFileStatus(struct soap *soap, struct srm2__TGetRequestFileStatus **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTosrm2__TGetRequestFileStatus);
	if (soap_out_PointerToPointerTosrm2__TGetRequestFileStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTosrm2__TGetRequestFileStatus(struct soap *soap, const char *tag, int id, struct srm2__TGetRequestFileStatus **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTosrm2__TGetRequestFileStatus);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTosrm2__TGetRequestFileStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TGetRequestFileStatus *** SOAP_FMAC4 soap_get_PointerToPointerTosrm2__TGetRequestFileStatus(struct soap *soap, struct srm2__TGetRequestFileStatus ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTosrm2__TGetRequestFileStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TGetRequestFileStatus *** SOAP_FMAC4 soap_in_PointerToPointerTosrm2__TGetRequestFileStatus(struct soap *soap, const char *tag, struct srm2__TGetRequestFileStatus ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TGetRequestFileStatus ***)soap_malloc(soap, sizeof(struct srm2__TGetRequestFileStatus **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTosrm2__TGetRequestFileStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TGetRequestFileStatus ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTosrm2__TGetRequestFileStatus, sizeof(struct srm2__TGetRequestFileStatus *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__TGetRequestFileStatus(struct soap *soap, struct srm2__TGetRequestFileStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__TGetRequestFileStatus))
		soap_serialize_srm2__TGetRequestFileStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__TGetRequestFileStatus(struct soap *soap, struct srm2__TGetRequestFileStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__TGetRequestFileStatus);
	if (soap_out_PointerTosrm2__TGetRequestFileStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__TGetRequestFileStatus(struct soap *soap, const char *tag, int id, struct srm2__TGetRequestFileStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__TGetRequestFileStatus);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__TGetRequestFileStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TGetRequestFileStatus ** SOAP_FMAC4 soap_get_PointerTosrm2__TGetRequestFileStatus(struct soap *soap, struct srm2__TGetRequestFileStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__TGetRequestFileStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TGetRequestFileStatus ** SOAP_FMAC4 soap_in_PointerTosrm2__TGetRequestFileStatus(struct soap *soap, const char *tag, struct srm2__TGetRequestFileStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TGetRequestFileStatus **)soap_malloc(soap, sizeof(struct srm2__TGetRequestFileStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__TGetRequestFileStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TGetRequestFileStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TGetRequestFileStatus, sizeof(struct srm2__TGetRequestFileStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__ArrayOfTExtraInfo(struct soap *soap, struct srm2__ArrayOfTExtraInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__ArrayOfTExtraInfo))
		soap_serialize_srm2__ArrayOfTExtraInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__ArrayOfTExtraInfo(struct soap *soap, struct srm2__ArrayOfTExtraInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__ArrayOfTExtraInfo);
	if (soap_out_PointerTosrm2__ArrayOfTExtraInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__ArrayOfTExtraInfo(struct soap *soap, const char *tag, int id, struct srm2__ArrayOfTExtraInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__ArrayOfTExtraInfo);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__ArrayOfTExtraInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__ArrayOfTExtraInfo ** SOAP_FMAC4 soap_get_PointerTosrm2__ArrayOfTExtraInfo(struct soap *soap, struct srm2__ArrayOfTExtraInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__ArrayOfTExtraInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfTExtraInfo ** SOAP_FMAC4 soap_in_PointerTosrm2__ArrayOfTExtraInfo(struct soap *soap, const char *tag, struct srm2__ArrayOfTExtraInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__ArrayOfTExtraInfo **)soap_malloc(soap, sizeof(struct srm2__ArrayOfTExtraInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__ArrayOfTExtraInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfTExtraInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfTExtraInfo, sizeof(struct srm2__ArrayOfTExtraInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTosrm2__TCopyFileRequest(struct soap *soap, struct srm2__TCopyFileRequest **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTosrm2__TCopyFileRequest))
		soap_serialize_PointerTosrm2__TCopyFileRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTosrm2__TCopyFileRequest(struct soap *soap, struct srm2__TCopyFileRequest **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTosrm2__TCopyFileRequest);
	if (soap_out_PointerToPointerTosrm2__TCopyFileRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTosrm2__TCopyFileRequest(struct soap *soap, const char *tag, int id, struct srm2__TCopyFileRequest **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTosrm2__TCopyFileRequest);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTosrm2__TCopyFileRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TCopyFileRequest *** SOAP_FMAC4 soap_get_PointerToPointerTosrm2__TCopyFileRequest(struct soap *soap, struct srm2__TCopyFileRequest ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTosrm2__TCopyFileRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TCopyFileRequest *** SOAP_FMAC4 soap_in_PointerToPointerTosrm2__TCopyFileRequest(struct soap *soap, const char *tag, struct srm2__TCopyFileRequest ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TCopyFileRequest ***)soap_malloc(soap, sizeof(struct srm2__TCopyFileRequest **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTosrm2__TCopyFileRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TCopyFileRequest ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTosrm2__TCopyFileRequest, sizeof(struct srm2__TCopyFileRequest *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__TCopyFileRequest(struct soap *soap, struct srm2__TCopyFileRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__TCopyFileRequest))
		soap_serialize_srm2__TCopyFileRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__TCopyFileRequest(struct soap *soap, struct srm2__TCopyFileRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__TCopyFileRequest);
	if (soap_out_PointerTosrm2__TCopyFileRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__TCopyFileRequest(struct soap *soap, const char *tag, int id, struct srm2__TCopyFileRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__TCopyFileRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__TCopyFileRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TCopyFileRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__TCopyFileRequest(struct soap *soap, struct srm2__TCopyFileRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__TCopyFileRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TCopyFileRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__TCopyFileRequest(struct soap *soap, const char *tag, struct srm2__TCopyFileRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TCopyFileRequest **)soap_malloc(soap, sizeof(struct srm2__TCopyFileRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__TCopyFileRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TCopyFileRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TCopyFileRequest, sizeof(struct srm2__TCopyFileRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTosrm2__TPutFileRequest(struct soap *soap, struct srm2__TPutFileRequest **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTosrm2__TPutFileRequest))
		soap_serialize_PointerTosrm2__TPutFileRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTosrm2__TPutFileRequest(struct soap *soap, struct srm2__TPutFileRequest **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTosrm2__TPutFileRequest);
	if (soap_out_PointerToPointerTosrm2__TPutFileRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTosrm2__TPutFileRequest(struct soap *soap, const char *tag, int id, struct srm2__TPutFileRequest **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTosrm2__TPutFileRequest);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTosrm2__TPutFileRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TPutFileRequest *** SOAP_FMAC4 soap_get_PointerToPointerTosrm2__TPutFileRequest(struct soap *soap, struct srm2__TPutFileRequest ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTosrm2__TPutFileRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TPutFileRequest *** SOAP_FMAC4 soap_in_PointerToPointerTosrm2__TPutFileRequest(struct soap *soap, const char *tag, struct srm2__TPutFileRequest ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TPutFileRequest ***)soap_malloc(soap, sizeof(struct srm2__TPutFileRequest **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTosrm2__TPutFileRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TPutFileRequest ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTosrm2__TPutFileRequest, sizeof(struct srm2__TPutFileRequest *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__TPutFileRequest(struct soap *soap, struct srm2__TPutFileRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__TPutFileRequest))
		soap_serialize_srm2__TPutFileRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__TPutFileRequest(struct soap *soap, struct srm2__TPutFileRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__TPutFileRequest);
	if (soap_out_PointerTosrm2__TPutFileRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__TPutFileRequest(struct soap *soap, const char *tag, int id, struct srm2__TPutFileRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__TPutFileRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__TPutFileRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TPutFileRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__TPutFileRequest(struct soap *soap, struct srm2__TPutFileRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__TPutFileRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TPutFileRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__TPutFileRequest(struct soap *soap, const char *tag, struct srm2__TPutFileRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TPutFileRequest **)soap_malloc(soap, sizeof(struct srm2__TPutFileRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__TPutFileRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TPutFileRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TPutFileRequest, sizeof(struct srm2__TPutFileRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTosrm2__TGetFileRequest(struct soap *soap, struct srm2__TGetFileRequest **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTosrm2__TGetFileRequest))
		soap_serialize_PointerTosrm2__TGetFileRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTosrm2__TGetFileRequest(struct soap *soap, struct srm2__TGetFileRequest **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTosrm2__TGetFileRequest);
	if (soap_out_PointerToPointerTosrm2__TGetFileRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTosrm2__TGetFileRequest(struct soap *soap, const char *tag, int id, struct srm2__TGetFileRequest **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTosrm2__TGetFileRequest);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTosrm2__TGetFileRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TGetFileRequest *** SOAP_FMAC4 soap_get_PointerToPointerTosrm2__TGetFileRequest(struct soap *soap, struct srm2__TGetFileRequest ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTosrm2__TGetFileRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TGetFileRequest *** SOAP_FMAC4 soap_in_PointerToPointerTosrm2__TGetFileRequest(struct soap *soap, const char *tag, struct srm2__TGetFileRequest ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TGetFileRequest ***)soap_malloc(soap, sizeof(struct srm2__TGetFileRequest **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTosrm2__TGetFileRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TGetFileRequest ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTosrm2__TGetFileRequest, sizeof(struct srm2__TGetFileRequest *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__TGetFileRequest(struct soap *soap, struct srm2__TGetFileRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__TGetFileRequest))
		soap_serialize_srm2__TGetFileRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__TGetFileRequest(struct soap *soap, struct srm2__TGetFileRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__TGetFileRequest);
	if (soap_out_PointerTosrm2__TGetFileRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__TGetFileRequest(struct soap *soap, const char *tag, int id, struct srm2__TGetFileRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__TGetFileRequest);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__TGetFileRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TGetFileRequest ** SOAP_FMAC4 soap_get_PointerTosrm2__TGetFileRequest(struct soap *soap, struct srm2__TGetFileRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__TGetFileRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TGetFileRequest ** SOAP_FMAC4 soap_in_PointerTosrm2__TGetFileRequest(struct soap *soap, const char *tag, struct srm2__TGetFileRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TGetFileRequest **)soap_malloc(soap, sizeof(struct srm2__TGetFileRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__TGetFileRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TGetFileRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TGetFileRequest, sizeof(struct srm2__TGetFileRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__TDirOption(struct soap *soap, struct srm2__TDirOption *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__TDirOption))
		soap_serialize_srm2__TDirOption(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__TDirOption(struct soap *soap, struct srm2__TDirOption *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__TDirOption);
	if (soap_out_PointerTosrm2__TDirOption(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__TDirOption(struct soap *soap, const char *tag, int id, struct srm2__TDirOption *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__TDirOption);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__TDirOption(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TDirOption ** SOAP_FMAC4 soap_get_PointerTosrm2__TDirOption(struct soap *soap, struct srm2__TDirOption **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__TDirOption(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TDirOption ** SOAP_FMAC4 soap_in_PointerTosrm2__TDirOption(struct soap *soap, const char *tag, struct srm2__TDirOption **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TDirOption **)soap_malloc(soap, sizeof(struct srm2__TDirOption *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__TDirOption(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TDirOption **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TDirOption, sizeof(struct srm2__TDirOption), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__TConnectionType(struct soap *soap, enum srm2__TConnectionType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_srm2__TConnectionType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__TConnectionType(struct soap *soap, enum srm2__TConnectionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__TConnectionType);
	if (soap_out_PointerTosrm2__TConnectionType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__TConnectionType(struct soap *soap, const char *tag, int id, enum srm2__TConnectionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__TConnectionType);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__TConnectionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum srm2__TConnectionType ** SOAP_FMAC4 soap_get_PointerTosrm2__TConnectionType(struct soap *soap, enum srm2__TConnectionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__TConnectionType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum srm2__TConnectionType ** SOAP_FMAC4 soap_in_PointerTosrm2__TConnectionType(struct soap *soap, const char *tag, enum srm2__TConnectionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (enum srm2__TConnectionType **)soap_malloc(soap, sizeof(enum srm2__TConnectionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__TConnectionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum srm2__TConnectionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TConnectionType, sizeof(enum srm2__TConnectionType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__TAccessPattern(struct soap *soap, enum srm2__TAccessPattern *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_srm2__TAccessPattern);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__TAccessPattern(struct soap *soap, enum srm2__TAccessPattern *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__TAccessPattern);
	if (soap_out_PointerTosrm2__TAccessPattern(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__TAccessPattern(struct soap *soap, const char *tag, int id, enum srm2__TAccessPattern *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__TAccessPattern);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__TAccessPattern(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum srm2__TAccessPattern ** SOAP_FMAC4 soap_get_PointerTosrm2__TAccessPattern(struct soap *soap, enum srm2__TAccessPattern **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__TAccessPattern(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum srm2__TAccessPattern ** SOAP_FMAC4 soap_in_PointerTosrm2__TAccessPattern(struct soap *soap, const char *tag, enum srm2__TAccessPattern **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (enum srm2__TAccessPattern **)soap_malloc(soap, sizeof(enum srm2__TAccessPattern *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__TAccessPattern(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum srm2__TAccessPattern **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TAccessPattern, sizeof(enum srm2__TAccessPattern), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyURI(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI))
		soap_serialize_xsd__anyURI(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyURI(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__anyURI);
	if (soap_out_PointerToxsd__anyURI(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyURI(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyURI);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__anyURI(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerToxsd__anyURI(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyURI(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerToxsd__anyURI(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__anyURI(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyURI, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTosrm2__TExtraInfo(struct soap *soap, struct srm2__TExtraInfo **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTosrm2__TExtraInfo))
		soap_serialize_PointerTosrm2__TExtraInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTosrm2__TExtraInfo(struct soap *soap, struct srm2__TExtraInfo **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTosrm2__TExtraInfo);
	if (soap_out_PointerToPointerTosrm2__TExtraInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTosrm2__TExtraInfo(struct soap *soap, const char *tag, int id, struct srm2__TExtraInfo **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTosrm2__TExtraInfo);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTosrm2__TExtraInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TExtraInfo *** SOAP_FMAC4 soap_get_PointerToPointerTosrm2__TExtraInfo(struct soap *soap, struct srm2__TExtraInfo ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTosrm2__TExtraInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TExtraInfo *** SOAP_FMAC4 soap_in_PointerToPointerTosrm2__TExtraInfo(struct soap *soap, const char *tag, struct srm2__TExtraInfo ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TExtraInfo ***)soap_malloc(soap, sizeof(struct srm2__TExtraInfo **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTosrm2__TExtraInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TExtraInfo ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTosrm2__TExtraInfo, sizeof(struct srm2__TExtraInfo *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__TExtraInfo(struct soap *soap, struct srm2__TExtraInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__TExtraInfo))
		soap_serialize_srm2__TExtraInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__TExtraInfo(struct soap *soap, struct srm2__TExtraInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__TExtraInfo);
	if (soap_out_PointerTosrm2__TExtraInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__TExtraInfo(struct soap *soap, const char *tag, int id, struct srm2__TExtraInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__TExtraInfo);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__TExtraInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TExtraInfo ** SOAP_FMAC4 soap_get_PointerTosrm2__TExtraInfo(struct soap *soap, struct srm2__TExtraInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__TExtraInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TExtraInfo ** SOAP_FMAC4 soap_in_PointerTosrm2__TExtraInfo(struct soap *soap, const char *tag, struct srm2__TExtraInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TExtraInfo **)soap_malloc(soap, sizeof(struct srm2__TExtraInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__TExtraInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TExtraInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TExtraInfo, sizeof(struct srm2__TExtraInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__boolean);
	if (soap_out_PointerToxsd__boolean(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__boolean(struct soap *soap, const char *tag, int id, enum xsd__boolean *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__boolean);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__boolean(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum xsd__boolean ** SOAP_FMAC4 soap_get_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__boolean(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum xsd__boolean ** SOAP_FMAC4 soap_in_PointerToxsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (enum xsd__boolean **)soap_malloc(soap, sizeof(enum xsd__boolean *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__boolean(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum xsd__boolean **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTosrm2__TMetaDataSpace(struct soap *soap, struct srm2__TMetaDataSpace **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTosrm2__TMetaDataSpace))
		soap_serialize_PointerTosrm2__TMetaDataSpace(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTosrm2__TMetaDataSpace(struct soap *soap, struct srm2__TMetaDataSpace **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTosrm2__TMetaDataSpace);
	if (soap_out_PointerToPointerTosrm2__TMetaDataSpace(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTosrm2__TMetaDataSpace(struct soap *soap, const char *tag, int id, struct srm2__TMetaDataSpace **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTosrm2__TMetaDataSpace);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTosrm2__TMetaDataSpace(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TMetaDataSpace *** SOAP_FMAC4 soap_get_PointerToPointerTosrm2__TMetaDataSpace(struct soap *soap, struct srm2__TMetaDataSpace ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTosrm2__TMetaDataSpace(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TMetaDataSpace *** SOAP_FMAC4 soap_in_PointerToPointerTosrm2__TMetaDataSpace(struct soap *soap, const char *tag, struct srm2__TMetaDataSpace ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TMetaDataSpace ***)soap_malloc(soap, sizeof(struct srm2__TMetaDataSpace **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTosrm2__TMetaDataSpace(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TMetaDataSpace ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTosrm2__TMetaDataSpace, sizeof(struct srm2__TMetaDataSpace *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__TMetaDataSpace(struct soap *soap, struct srm2__TMetaDataSpace *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__TMetaDataSpace))
		soap_serialize_srm2__TMetaDataSpace(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__TMetaDataSpace(struct soap *soap, struct srm2__TMetaDataSpace *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__TMetaDataSpace);
	if (soap_out_PointerTosrm2__TMetaDataSpace(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__TMetaDataSpace(struct soap *soap, const char *tag, int id, struct srm2__TMetaDataSpace *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__TMetaDataSpace);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__TMetaDataSpace(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TMetaDataSpace ** SOAP_FMAC4 soap_get_PointerTosrm2__TMetaDataSpace(struct soap *soap, struct srm2__TMetaDataSpace **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__TMetaDataSpace(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TMetaDataSpace ** SOAP_FMAC4 soap_in_PointerTosrm2__TMetaDataSpace(struct soap *soap, const char *tag, struct srm2__TMetaDataSpace **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TMetaDataSpace **)soap_malloc(soap, sizeof(struct srm2__TMetaDataSpace *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__TMetaDataSpace(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TMetaDataSpace **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TMetaDataSpace, sizeof(struct srm2__TMetaDataSpace), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTosrm2__TMetaDataPathDetail(struct soap *soap, struct srm2__TMetaDataPathDetail **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTosrm2__TMetaDataPathDetail))
		soap_serialize_PointerTosrm2__TMetaDataPathDetail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTosrm2__TMetaDataPathDetail(struct soap *soap, struct srm2__TMetaDataPathDetail **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTosrm2__TMetaDataPathDetail);
	if (soap_out_PointerToPointerTosrm2__TMetaDataPathDetail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTosrm2__TMetaDataPathDetail(struct soap *soap, const char *tag, int id, struct srm2__TMetaDataPathDetail **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTosrm2__TMetaDataPathDetail);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTosrm2__TMetaDataPathDetail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TMetaDataPathDetail *** SOAP_FMAC4 soap_get_PointerToPointerTosrm2__TMetaDataPathDetail(struct soap *soap, struct srm2__TMetaDataPathDetail ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTosrm2__TMetaDataPathDetail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TMetaDataPathDetail *** SOAP_FMAC4 soap_in_PointerToPointerTosrm2__TMetaDataPathDetail(struct soap *soap, const char *tag, struct srm2__TMetaDataPathDetail ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TMetaDataPathDetail ***)soap_malloc(soap, sizeof(struct srm2__TMetaDataPathDetail **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTosrm2__TMetaDataPathDetail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TMetaDataPathDetail ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTosrm2__TMetaDataPathDetail, sizeof(struct srm2__TMetaDataPathDetail *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__TMetaDataPathDetail(struct soap *soap, struct srm2__TMetaDataPathDetail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__TMetaDataPathDetail))
		soap_serialize_srm2__TMetaDataPathDetail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__TMetaDataPathDetail(struct soap *soap, struct srm2__TMetaDataPathDetail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__TMetaDataPathDetail);
	if (soap_out_PointerTosrm2__TMetaDataPathDetail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__TMetaDataPathDetail(struct soap *soap, const char *tag, int id, struct srm2__TMetaDataPathDetail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__TMetaDataPathDetail);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__TMetaDataPathDetail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TMetaDataPathDetail ** SOAP_FMAC4 soap_get_PointerTosrm2__TMetaDataPathDetail(struct soap *soap, struct srm2__TMetaDataPathDetail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__TMetaDataPathDetail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TMetaDataPathDetail ** SOAP_FMAC4 soap_in_PointerTosrm2__TMetaDataPathDetail(struct soap *soap, const char *tag, struct srm2__TMetaDataPathDetail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TMetaDataPathDetail **)soap_malloc(soap, sizeof(struct srm2__TMetaDataPathDetail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__TMetaDataPathDetail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TMetaDataPathDetail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TMetaDataPathDetail, sizeof(struct srm2__TMetaDataPathDetail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__ArrayOfTMetaDataPathDetail(struct soap *soap, struct srm2__ArrayOfTMetaDataPathDetail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__ArrayOfTMetaDataPathDetail))
		soap_serialize_srm2__ArrayOfTMetaDataPathDetail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__ArrayOfTMetaDataPathDetail(struct soap *soap, struct srm2__ArrayOfTMetaDataPathDetail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__ArrayOfTMetaDataPathDetail);
	if (soap_out_PointerTosrm2__ArrayOfTMetaDataPathDetail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__ArrayOfTMetaDataPathDetail(struct soap *soap, const char *tag, int id, struct srm2__ArrayOfTMetaDataPathDetail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__ArrayOfTMetaDataPathDetail);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__ArrayOfTMetaDataPathDetail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__ArrayOfTMetaDataPathDetail ** SOAP_FMAC4 soap_get_PointerTosrm2__ArrayOfTMetaDataPathDetail(struct soap *soap, struct srm2__ArrayOfTMetaDataPathDetail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__ArrayOfTMetaDataPathDetail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfTMetaDataPathDetail ** SOAP_FMAC4 soap_in_PointerTosrm2__ArrayOfTMetaDataPathDetail(struct soap *soap, const char *tag, struct srm2__ArrayOfTMetaDataPathDetail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__ArrayOfTMetaDataPathDetail **)soap_malloc(soap, sizeof(struct srm2__ArrayOfTMetaDataPathDetail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__ArrayOfTMetaDataPathDetail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfTMetaDataPathDetail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfTMetaDataPathDetail, sizeof(struct srm2__ArrayOfTMetaDataPathDetail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__TPermissionMode(struct soap *soap, enum srm2__TPermissionMode *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_srm2__TPermissionMode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__TPermissionMode(struct soap *soap, enum srm2__TPermissionMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__TPermissionMode);
	if (soap_out_PointerTosrm2__TPermissionMode(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__TPermissionMode(struct soap *soap, const char *tag, int id, enum srm2__TPermissionMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__TPermissionMode);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__TPermissionMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum srm2__TPermissionMode ** SOAP_FMAC4 soap_get_PointerTosrm2__TPermissionMode(struct soap *soap, enum srm2__TPermissionMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__TPermissionMode(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum srm2__TPermissionMode ** SOAP_FMAC4 soap_in_PointerTosrm2__TPermissionMode(struct soap *soap, const char *tag, enum srm2__TPermissionMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (enum srm2__TPermissionMode **)soap_malloc(soap, sizeof(enum srm2__TPermissionMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__TPermissionMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum srm2__TPermissionMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TPermissionMode, sizeof(enum srm2__TPermissionMode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__TFileType(struct soap *soap, enum srm2__TFileType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_srm2__TFileType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__TFileType(struct soap *soap, enum srm2__TFileType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__TFileType);
	if (soap_out_PointerTosrm2__TFileType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__TFileType(struct soap *soap, const char *tag, int id, enum srm2__TFileType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__TFileType);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__TFileType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum srm2__TFileType ** SOAP_FMAC4 soap_get_PointerTosrm2__TFileType(struct soap *soap, enum srm2__TFileType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__TFileType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum srm2__TFileType ** SOAP_FMAC4 soap_in_PointerTosrm2__TFileType(struct soap *soap, const char *tag, enum srm2__TFileType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (enum srm2__TFileType **)soap_malloc(soap, sizeof(enum srm2__TFileType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__TFileType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum srm2__TFileType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TFileType, sizeof(enum srm2__TFileType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__ArrayOfString(struct soap *soap, struct srm2__ArrayOfString *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__ArrayOfString))
		soap_serialize_srm2__ArrayOfString(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__ArrayOfString(struct soap *soap, struct srm2__ArrayOfString *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__ArrayOfString);
	if (soap_out_PointerTosrm2__ArrayOfString(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__ArrayOfString(struct soap *soap, const char *tag, int id, struct srm2__ArrayOfString *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__ArrayOfString);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__ArrayOfString(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__ArrayOfString ** SOAP_FMAC4 soap_get_PointerTosrm2__ArrayOfString(struct soap *soap, struct srm2__ArrayOfString **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__ArrayOfString(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__ArrayOfString ** SOAP_FMAC4 soap_in_PointerTosrm2__ArrayOfString(struct soap *soap, const char *tag, struct srm2__ArrayOfString **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__ArrayOfString **)soap_malloc(soap, sizeof(struct srm2__ArrayOfString *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__ArrayOfString(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__ArrayOfString **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__ArrayOfString, sizeof(struct srm2__ArrayOfString), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__TFileLocality(struct soap *soap, enum srm2__TFileLocality *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_srm2__TFileLocality);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__TFileLocality(struct soap *soap, enum srm2__TFileLocality *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__TFileLocality);
	if (soap_out_PointerTosrm2__TFileLocality(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__TFileLocality(struct soap *soap, const char *tag, int id, enum srm2__TFileLocality *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__TFileLocality);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__TFileLocality(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum srm2__TFileLocality ** SOAP_FMAC4 soap_get_PointerTosrm2__TFileLocality(struct soap *soap, enum srm2__TFileLocality **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__TFileLocality(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum srm2__TFileLocality ** SOAP_FMAC4 soap_in_PointerTosrm2__TFileLocality(struct soap *soap, const char *tag, enum srm2__TFileLocality **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (enum srm2__TFileLocality **)soap_malloc(soap, sizeof(enum srm2__TFileLocality *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__TFileLocality(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum srm2__TFileLocality **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TFileLocality, sizeof(enum srm2__TFileLocality), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__TRetentionPolicyInfo(struct soap *soap, struct srm2__TRetentionPolicyInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__TRetentionPolicyInfo))
		soap_serialize_srm2__TRetentionPolicyInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__TRetentionPolicyInfo(struct soap *soap, struct srm2__TRetentionPolicyInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__TRetentionPolicyInfo);
	if (soap_out_PointerTosrm2__TRetentionPolicyInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__TRetentionPolicyInfo(struct soap *soap, const char *tag, int id, struct srm2__TRetentionPolicyInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__TRetentionPolicyInfo);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__TRetentionPolicyInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TRetentionPolicyInfo ** SOAP_FMAC4 soap_get_PointerTosrm2__TRetentionPolicyInfo(struct soap *soap, struct srm2__TRetentionPolicyInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__TRetentionPolicyInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TRetentionPolicyInfo ** SOAP_FMAC4 soap_in_PointerTosrm2__TRetentionPolicyInfo(struct soap *soap, const char *tag, struct srm2__TRetentionPolicyInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TRetentionPolicyInfo **)soap_malloc(soap, sizeof(struct srm2__TRetentionPolicyInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__TRetentionPolicyInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TRetentionPolicyInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TRetentionPolicyInfo, sizeof(struct srm2__TRetentionPolicyInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__TFileStorageType(struct soap *soap, enum srm2__TFileStorageType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_srm2__TFileStorageType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__TFileStorageType(struct soap *soap, enum srm2__TFileStorageType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__TFileStorageType);
	if (soap_out_PointerTosrm2__TFileStorageType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__TFileStorageType(struct soap *soap, const char *tag, int id, enum srm2__TFileStorageType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__TFileStorageType);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__TFileStorageType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum srm2__TFileStorageType ** SOAP_FMAC4 soap_get_PointerTosrm2__TFileStorageType(struct soap *soap, enum srm2__TFileStorageType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__TFileStorageType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum srm2__TFileStorageType ** SOAP_FMAC4 soap_in_PointerTosrm2__TFileStorageType(struct soap *soap, const char *tag, enum srm2__TFileStorageType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (enum srm2__TFileStorageType **)soap_malloc(soap, sizeof(enum srm2__TFileStorageType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__TFileStorageType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum srm2__TFileStorageType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TFileStorageType, sizeof(enum srm2__TFileStorageType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTosrm2__TSURLLifetimeReturnStatus(struct soap *soap, struct srm2__TSURLLifetimeReturnStatus **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTosrm2__TSURLLifetimeReturnStatus))
		soap_serialize_PointerTosrm2__TSURLLifetimeReturnStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTosrm2__TSURLLifetimeReturnStatus(struct soap *soap, struct srm2__TSURLLifetimeReturnStatus **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTosrm2__TSURLLifetimeReturnStatus);
	if (soap_out_PointerToPointerTosrm2__TSURLLifetimeReturnStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTosrm2__TSURLLifetimeReturnStatus(struct soap *soap, const char *tag, int id, struct srm2__TSURLLifetimeReturnStatus **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTosrm2__TSURLLifetimeReturnStatus);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTosrm2__TSURLLifetimeReturnStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TSURLLifetimeReturnStatus *** SOAP_FMAC4 soap_get_PointerToPointerTosrm2__TSURLLifetimeReturnStatus(struct soap *soap, struct srm2__TSURLLifetimeReturnStatus ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTosrm2__TSURLLifetimeReturnStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TSURLLifetimeReturnStatus *** SOAP_FMAC4 soap_in_PointerToPointerTosrm2__TSURLLifetimeReturnStatus(struct soap *soap, const char *tag, struct srm2__TSURLLifetimeReturnStatus ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TSURLLifetimeReturnStatus ***)soap_malloc(soap, sizeof(struct srm2__TSURLLifetimeReturnStatus **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTosrm2__TSURLLifetimeReturnStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TSURLLifetimeReturnStatus ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTosrm2__TSURLLifetimeReturnStatus, sizeof(struct srm2__TSURLLifetimeReturnStatus *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__TSURLLifetimeReturnStatus(struct soap *soap, struct srm2__TSURLLifetimeReturnStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__TSURLLifetimeReturnStatus))
		soap_serialize_srm2__TSURLLifetimeReturnStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__TSURLLifetimeReturnStatus(struct soap *soap, struct srm2__TSURLLifetimeReturnStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__TSURLLifetimeReturnStatus);
	if (soap_out_PointerTosrm2__TSURLLifetimeReturnStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__TSURLLifetimeReturnStatus(struct soap *soap, const char *tag, int id, struct srm2__TSURLLifetimeReturnStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__TSURLLifetimeReturnStatus);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__TSURLLifetimeReturnStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TSURLLifetimeReturnStatus ** SOAP_FMAC4 soap_get_PointerTosrm2__TSURLLifetimeReturnStatus(struct soap *soap, struct srm2__TSURLLifetimeReturnStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__TSURLLifetimeReturnStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TSURLLifetimeReturnStatus ** SOAP_FMAC4 soap_in_PointerTosrm2__TSURLLifetimeReturnStatus(struct soap *soap, const char *tag, struct srm2__TSURLLifetimeReturnStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TSURLLifetimeReturnStatus **)soap_malloc(soap, sizeof(struct srm2__TSURLLifetimeReturnStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__TSURLLifetimeReturnStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TSURLLifetimeReturnStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TSURLLifetimeReturnStatus, sizeof(struct srm2__TSURLLifetimeReturnStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTosrm2__TSURLReturnStatus(struct soap *soap, struct srm2__TSURLReturnStatus **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTosrm2__TSURLReturnStatus))
		soap_serialize_PointerTosrm2__TSURLReturnStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTosrm2__TSURLReturnStatus(struct soap *soap, struct srm2__TSURLReturnStatus **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTosrm2__TSURLReturnStatus);
	if (soap_out_PointerToPointerTosrm2__TSURLReturnStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTosrm2__TSURLReturnStatus(struct soap *soap, const char *tag, int id, struct srm2__TSURLReturnStatus **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTosrm2__TSURLReturnStatus);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTosrm2__TSURLReturnStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TSURLReturnStatus *** SOAP_FMAC4 soap_get_PointerToPointerTosrm2__TSURLReturnStatus(struct soap *soap, struct srm2__TSURLReturnStatus ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTosrm2__TSURLReturnStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TSURLReturnStatus *** SOAP_FMAC4 soap_in_PointerToPointerTosrm2__TSURLReturnStatus(struct soap *soap, const char *tag, struct srm2__TSURLReturnStatus ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TSURLReturnStatus ***)soap_malloc(soap, sizeof(struct srm2__TSURLReturnStatus **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTosrm2__TSURLReturnStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TSURLReturnStatus ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTosrm2__TSURLReturnStatus, sizeof(struct srm2__TSURLReturnStatus *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__TSURLReturnStatus(struct soap *soap, struct srm2__TSURLReturnStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__TSURLReturnStatus))
		soap_serialize_srm2__TSURLReturnStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__TSURLReturnStatus(struct soap *soap, struct srm2__TSURLReturnStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__TSURLReturnStatus);
	if (soap_out_PointerTosrm2__TSURLReturnStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__TSURLReturnStatus(struct soap *soap, const char *tag, int id, struct srm2__TSURLReturnStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__TSURLReturnStatus);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__TSURLReturnStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TSURLReturnStatus ** SOAP_FMAC4 soap_get_PointerTosrm2__TSURLReturnStatus(struct soap *soap, struct srm2__TSURLReturnStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__TSURLReturnStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TSURLReturnStatus ** SOAP_FMAC4 soap_in_PointerTosrm2__TSURLReturnStatus(struct soap *soap, const char *tag, struct srm2__TSURLReturnStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TSURLReturnStatus **)soap_malloc(soap, sizeof(struct srm2__TSURLReturnStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__TSURLReturnStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TSURLReturnStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TSURLReturnStatus, sizeof(struct srm2__TSURLReturnStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__TReturnStatus(struct soap *soap, struct srm2__TReturnStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__TReturnStatus))
		soap_serialize_srm2__TReturnStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__TReturnStatus(struct soap *soap, struct srm2__TReturnStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__TReturnStatus);
	if (soap_out_PointerTosrm2__TReturnStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__TReturnStatus(struct soap *soap, const char *tag, int id, struct srm2__TReturnStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__TReturnStatus);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__TReturnStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TReturnStatus ** SOAP_FMAC4 soap_get_PointerTosrm2__TReturnStatus(struct soap *soap, struct srm2__TReturnStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__TReturnStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TReturnStatus ** SOAP_FMAC4 soap_in_PointerTosrm2__TReturnStatus(struct soap *soap, const char *tag, struct srm2__TReturnStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TReturnStatus **)soap_malloc(soap, sizeof(struct srm2__TReturnStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__TReturnStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TReturnStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TReturnStatus, sizeof(struct srm2__TReturnStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
	if (soap_out_PointerTostring(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedLONG64(struct soap *soap, ULONG64 *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_unsignedLONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedLONG64(struct soap *soap, ULONG64 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedLONG64);
	if (soap_out_PointerTounsignedLONG64(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedLONG64(struct soap *soap, const char *tag, int id, ULONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedLONG64);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedLONG64(soap, tag, id, *a, type);
}

SOAP_FMAC3 ULONG64 ** SOAP_FMAC4 soap_get_PointerTounsignedLONG64(struct soap *soap, ULONG64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedLONG64(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ULONG64 ** SOAP_FMAC4 soap_in_PointerTounsignedLONG64(struct soap *soap, const char *tag, ULONG64 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ULONG64 **)soap_malloc(soap, sizeof(ULONG64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedLONG64(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ULONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedLONG64, sizeof(ULONG64), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTosrm2__TGroupPermission(struct soap *soap, struct srm2__TGroupPermission **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTosrm2__TGroupPermission))
		soap_serialize_PointerTosrm2__TGroupPermission(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTosrm2__TGroupPermission(struct soap *soap, struct srm2__TGroupPermission **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTosrm2__TGroupPermission);
	if (soap_out_PointerToPointerTosrm2__TGroupPermission(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTosrm2__TGroupPermission(struct soap *soap, const char *tag, int id, struct srm2__TGroupPermission **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTosrm2__TGroupPermission);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTosrm2__TGroupPermission(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TGroupPermission *** SOAP_FMAC4 soap_get_PointerToPointerTosrm2__TGroupPermission(struct soap *soap, struct srm2__TGroupPermission ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTosrm2__TGroupPermission(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TGroupPermission *** SOAP_FMAC4 soap_in_PointerToPointerTosrm2__TGroupPermission(struct soap *soap, const char *tag, struct srm2__TGroupPermission ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TGroupPermission ***)soap_malloc(soap, sizeof(struct srm2__TGroupPermission **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTosrm2__TGroupPermission(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TGroupPermission ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTosrm2__TGroupPermission, sizeof(struct srm2__TGroupPermission *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__TGroupPermission(struct soap *soap, struct srm2__TGroupPermission *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__TGroupPermission))
		soap_serialize_srm2__TGroupPermission(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__TGroupPermission(struct soap *soap, struct srm2__TGroupPermission *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__TGroupPermission);
	if (soap_out_PointerTosrm2__TGroupPermission(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__TGroupPermission(struct soap *soap, const char *tag, int id, struct srm2__TGroupPermission *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__TGroupPermission);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__TGroupPermission(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TGroupPermission ** SOAP_FMAC4 soap_get_PointerTosrm2__TGroupPermission(struct soap *soap, struct srm2__TGroupPermission **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__TGroupPermission(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TGroupPermission ** SOAP_FMAC4 soap_in_PointerTosrm2__TGroupPermission(struct soap *soap, const char *tag, struct srm2__TGroupPermission **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TGroupPermission **)soap_malloc(soap, sizeof(struct srm2__TGroupPermission *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__TGroupPermission(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TGroupPermission **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TGroupPermission, sizeof(struct srm2__TGroupPermission), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTosrm2__TUserPermission(struct soap *soap, struct srm2__TUserPermission **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTosrm2__TUserPermission))
		soap_serialize_PointerTosrm2__TUserPermission(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTosrm2__TUserPermission(struct soap *soap, struct srm2__TUserPermission **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTosrm2__TUserPermission);
	if (soap_out_PointerToPointerTosrm2__TUserPermission(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTosrm2__TUserPermission(struct soap *soap, const char *tag, int id, struct srm2__TUserPermission **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTosrm2__TUserPermission);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTosrm2__TUserPermission(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TUserPermission *** SOAP_FMAC4 soap_get_PointerToPointerTosrm2__TUserPermission(struct soap *soap, struct srm2__TUserPermission ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTosrm2__TUserPermission(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TUserPermission *** SOAP_FMAC4 soap_in_PointerToPointerTosrm2__TUserPermission(struct soap *soap, const char *tag, struct srm2__TUserPermission ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TUserPermission ***)soap_malloc(soap, sizeof(struct srm2__TUserPermission **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTosrm2__TUserPermission(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TUserPermission ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTosrm2__TUserPermission, sizeof(struct srm2__TUserPermission *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__TUserPermission(struct soap *soap, struct srm2__TUserPermission *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_srm2__TUserPermission))
		soap_serialize_srm2__TUserPermission(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__TUserPermission(struct soap *soap, struct srm2__TUserPermission *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__TUserPermission);
	if (soap_out_PointerTosrm2__TUserPermission(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__TUserPermission(struct soap *soap, const char *tag, int id, struct srm2__TUserPermission *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__TUserPermission);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__TUserPermission(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct srm2__TUserPermission ** SOAP_FMAC4 soap_get_PointerTosrm2__TUserPermission(struct soap *soap, struct srm2__TUserPermission **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__TUserPermission(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct srm2__TUserPermission ** SOAP_FMAC4 soap_in_PointerTosrm2__TUserPermission(struct soap *soap, const char *tag, struct srm2__TUserPermission **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct srm2__TUserPermission **)soap_malloc(soap, sizeof(struct srm2__TUserPermission *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__TUserPermission(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct srm2__TUserPermission **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TUserPermission, sizeof(struct srm2__TUserPermission), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosrm2__TAccessLatency(struct soap *soap, enum srm2__TAccessLatency *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_srm2__TAccessLatency);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosrm2__TAccessLatency(struct soap *soap, enum srm2__TAccessLatency *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosrm2__TAccessLatency);
	if (soap_out_PointerTosrm2__TAccessLatency(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosrm2__TAccessLatency(struct soap *soap, const char *tag, int id, enum srm2__TAccessLatency *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_srm2__TAccessLatency);
	if (id < 0)
		return soap->error;
	return soap_out_srm2__TAccessLatency(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum srm2__TAccessLatency ** SOAP_FMAC4 soap_get_PointerTosrm2__TAccessLatency(struct soap *soap, enum srm2__TAccessLatency **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosrm2__TAccessLatency(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum srm2__TAccessLatency ** SOAP_FMAC4 soap_in_PointerTosrm2__TAccessLatency(struct soap *soap, const char *tag, enum srm2__TAccessLatency **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (enum srm2__TAccessLatency **)soap_malloc(soap, sizeof(enum srm2__TAccessLatency *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_srm2__TAccessLatency(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum srm2__TAccessLatency **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_srm2__TAccessLatency, sizeof(enum srm2__TAccessLatency), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__anyURI(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anyURI);
	if (soap_out_xsd__anyURI(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__anyURI);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__anyURI, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
}

#ifdef __cplusplus
}
#endif

/* End of srmv2C.c */
